// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "opendrive_16_junction.hxx"

namespace simulation
{
  namespace standard
  {
    namespace opendrive_schema
    {
      // e_contactPoint
      // 

      e_contactPoint::
      e_contactPoint (value v)
      : ::xml_schema::string (_xsd_e_contactPoint_literals_[v])
      {
      }

      e_contactPoint::
      e_contactPoint (const char* v)
      : ::xml_schema::string (v)
      {
      }

      e_contactPoint::
      e_contactPoint (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_contactPoint::
      e_contactPoint (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_contactPoint::
      e_contactPoint (const e_contactPoint& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      e_contactPoint& e_contactPoint::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_e_contactPoint_literals_[v]);

        return *this;
      }


      // e_elementDir
      // 

      e_elementDir::
      e_elementDir (value v)
      : ::xml_schema::string (_xsd_e_elementDir_literals_[v])
      {
      }

      e_elementDir::
      e_elementDir (const char* v)
      : ::xml_schema::string (v)
      {
      }

      e_elementDir::
      e_elementDir (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_elementDir::
      e_elementDir (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_elementDir::
      e_elementDir (const e_elementDir& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      e_elementDir& e_elementDir::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_e_elementDir_literals_[v]);

        return *this;
      }


      // e_junction_type
      // 

      e_junction_type::
      e_junction_type (value v)
      : ::xml_schema::string (_xsd_e_junction_type_literals_[v])
      {
      }

      e_junction_type::
      e_junction_type (const char* v)
      : ::xml_schema::string (v)
      {
      }

      e_junction_type::
      e_junction_type (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_junction_type::
      e_junction_type (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_junction_type::
      e_junction_type (const e_junction_type& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      e_junction_type& e_junction_type::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_e_junction_type_literals_[v]);

        return *this;
      }


      // e_junctionGroup_type
      // 

      e_junctionGroup_type::
      e_junctionGroup_type (value v)
      : ::xml_schema::string (_xsd_e_junctionGroup_type_literals_[v])
      {
      }

      e_junctionGroup_type::
      e_junctionGroup_type (const char* v)
      : ::xml_schema::string (v)
      {
      }

      e_junctionGroup_type::
      e_junctionGroup_type (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_junctionGroup_type::
      e_junctionGroup_type (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_junctionGroup_type::
      e_junctionGroup_type (const e_junctionGroup_type& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      e_junctionGroup_type& e_junctionGroup_type::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_e_junctionGroup_type_literals_[v]);

        return *this;
      }


      // e_road_surface_CRG_mode
      // 

      e_road_surface_CRG_mode::
      e_road_surface_CRG_mode (value v)
      : ::xml_schema::string (_xsd_e_road_surface_CRG_mode_literals_[v])
      {
      }

      e_road_surface_CRG_mode::
      e_road_surface_CRG_mode (const char* v)
      : ::xml_schema::string (v)
      {
      }

      e_road_surface_CRG_mode::
      e_road_surface_CRG_mode (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_road_surface_CRG_mode::
      e_road_surface_CRG_mode (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_road_surface_CRG_mode::
      e_road_surface_CRG_mode (const e_road_surface_CRG_mode& v,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      e_road_surface_CRG_mode& e_road_surface_CRG_mode::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_e_road_surface_CRG_mode_literals_[v]);

        return *this;
      }


      // e_road_surface_CRG_purpose
      // 

      e_road_surface_CRG_purpose::
      e_road_surface_CRG_purpose (value v)
      : ::xml_schema::string (_xsd_e_road_surface_CRG_purpose_literals_[v])
      {
      }

      e_road_surface_CRG_purpose::
      e_road_surface_CRG_purpose (const char* v)
      : ::xml_schema::string (v)
      {
      }

      e_road_surface_CRG_purpose::
      e_road_surface_CRG_purpose (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_road_surface_CRG_purpose::
      e_road_surface_CRG_purpose (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_road_surface_CRG_purpose::
      e_road_surface_CRG_purpose (const e_road_surface_CRG_purpose& v,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      e_road_surface_CRG_purpose& e_road_surface_CRG_purpose::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_e_road_surface_CRG_purpose_literals_[v]);

        return *this;
      }


      // t_junction
      // 

      const t_junction::connection_sequence& t_junction::
      connection () const
      {
        return this->connection_;
      }

      t_junction::connection_sequence& t_junction::
      connection ()
      {
        return this->connection_;
      }

      void t_junction::
      connection (const connection_sequence& s)
      {
        this->connection_ = s;
      }

      const t_junction::priority_sequence& t_junction::
      priority () const
      {
        return this->priority_;
      }

      t_junction::priority_sequence& t_junction::
      priority ()
      {
        return this->priority_;
      }

      void t_junction::
      priority (const priority_sequence& s)
      {
        this->priority_ = s;
      }

      const t_junction::controller_sequence& t_junction::
      controller () const
      {
        return this->controller_;
      }

      t_junction::controller_sequence& t_junction::
      controller ()
      {
        return this->controller_;
      }

      void t_junction::
      controller (const controller_sequence& s)
      {
        this->controller_ = s;
      }

      const t_junction::surface_optional& t_junction::
      surface () const
      {
        return this->surface_;
      }

      t_junction::surface_optional& t_junction::
      surface ()
      {
        return this->surface_;
      }

      void t_junction::
      surface (const surface_type& x)
      {
        this->surface_.set (x);
      }

      void t_junction::
      surface (const surface_optional& x)
      {
        this->surface_ = x;
      }

      void t_junction::
      surface (::std::unique_ptr< surface_type > x)
      {
        this->surface_.set (std::move (x));
      }

      const t_junction::include_sequence& t_junction::
      include () const
      {
        return this->include_;
      }

      t_junction::include_sequence& t_junction::
      include ()
      {
        return this->include_;
      }

      void t_junction::
      include (const include_sequence& s)
      {
        this->include_ = s;
      }

      const t_junction::userData_sequence& t_junction::
      userData () const
      {
        return this->userData_;
      }

      t_junction::userData_sequence& t_junction::
      userData ()
      {
        return this->userData_;
      }

      void t_junction::
      userData (const userData_sequence& s)
      {
        this->userData_ = s;
      }

      const t_junction::dataQuality_sequence& t_junction::
      dataQuality () const
      {
        return this->dataQuality_;
      }

      t_junction::dataQuality_sequence& t_junction::
      dataQuality ()
      {
        return this->dataQuality_;
      }

      void t_junction::
      dataQuality (const dataQuality_sequence& s)
      {
        this->dataQuality_ = s;
      }

      const t_junction::name_optional& t_junction::
      name () const
      {
        return this->name_;
      }

      t_junction::name_optional& t_junction::
      name ()
      {
        return this->name_;
      }

      void t_junction::
      name (const name_type& x)
      {
        this->name_.set (x);
      }

      void t_junction::
      name (const name_optional& x)
      {
        this->name_ = x;
      }

      void t_junction::
      name (::std::unique_ptr< name_type > x)
      {
        this->name_.set (std::move (x));
      }

      const t_junction::id_type& t_junction::
      id () const
      {
        return this->id_.get ();
      }

      t_junction::id_type& t_junction::
      id ()
      {
        return this->id_.get ();
      }

      void t_junction::
      id (const id_type& x)
      {
        this->id_.set (x);
      }

      void t_junction::
      id (::std::unique_ptr< id_type > x)
      {
        this->id_.set (std::move (x));
      }

      const t_junction::type_optional& t_junction::
      type () const
      {
        return this->type_;
      }

      t_junction::type_optional& t_junction::
      type ()
      {
        return this->type_;
      }

      void t_junction::
      type (const type_type& x)
      {
        this->type_.set (x);
      }

      void t_junction::
      type (const type_optional& x)
      {
        this->type_ = x;
      }

      void t_junction::
      type (::std::unique_ptr< type_type > x)
      {
        this->type_.set (std::move (x));
      }


      // t_junction_connection
      // 

      const t_junction_connection::predecessor_optional& t_junction_connection::
      predecessor () const
      {
        return this->predecessor_;
      }

      t_junction_connection::predecessor_optional& t_junction_connection::
      predecessor ()
      {
        return this->predecessor_;
      }

      void t_junction_connection::
      predecessor (const predecessor_type& x)
      {
        this->predecessor_.set (x);
      }

      void t_junction_connection::
      predecessor (const predecessor_optional& x)
      {
        this->predecessor_ = x;
      }

      void t_junction_connection::
      predecessor (::std::unique_ptr< predecessor_type > x)
      {
        this->predecessor_.set (std::move (x));
      }

      const t_junction_connection::successor_optional& t_junction_connection::
      successor () const
      {
        return this->successor_;
      }

      t_junction_connection::successor_optional& t_junction_connection::
      successor ()
      {
        return this->successor_;
      }

      void t_junction_connection::
      successor (const successor_type& x)
      {
        this->successor_.set (x);
      }

      void t_junction_connection::
      successor (const successor_optional& x)
      {
        this->successor_ = x;
      }

      void t_junction_connection::
      successor (::std::unique_ptr< successor_type > x)
      {
        this->successor_.set (std::move (x));
      }

      const t_junction_connection::laneLink_sequence& t_junction_connection::
      laneLink () const
      {
        return this->laneLink_;
      }

      t_junction_connection::laneLink_sequence& t_junction_connection::
      laneLink ()
      {
        return this->laneLink_;
      }

      void t_junction_connection::
      laneLink (const laneLink_sequence& s)
      {
        this->laneLink_ = s;
      }

      const t_junction_connection::id_type& t_junction_connection::
      id () const
      {
        return this->id_.get ();
      }

      t_junction_connection::id_type& t_junction_connection::
      id ()
      {
        return this->id_.get ();
      }

      void t_junction_connection::
      id (const id_type& x)
      {
        this->id_.set (x);
      }

      void t_junction_connection::
      id (::std::unique_ptr< id_type > x)
      {
        this->id_.set (std::move (x));
      }

      const t_junction_connection::type_optional& t_junction_connection::
      type () const
      {
        return this->type_;
      }

      t_junction_connection::type_optional& t_junction_connection::
      type ()
      {
        return this->type_;
      }

      void t_junction_connection::
      type (const type_type& x)
      {
        this->type_.set (x);
      }

      void t_junction_connection::
      type (const type_optional& x)
      {
        this->type_ = x;
      }

      void t_junction_connection::
      type (::std::unique_ptr< type_type > x)
      {
        this->type_.set (std::move (x));
      }

      const t_junction_connection::incomingRoad_optional& t_junction_connection::
      incomingRoad () const
      {
        return this->incomingRoad_;
      }

      t_junction_connection::incomingRoad_optional& t_junction_connection::
      incomingRoad ()
      {
        return this->incomingRoad_;
      }

      void t_junction_connection::
      incomingRoad (const incomingRoad_type& x)
      {
        this->incomingRoad_.set (x);
      }

      void t_junction_connection::
      incomingRoad (const incomingRoad_optional& x)
      {
        this->incomingRoad_ = x;
      }

      void t_junction_connection::
      incomingRoad (::std::unique_ptr< incomingRoad_type > x)
      {
        this->incomingRoad_.set (std::move (x));
      }

      const t_junction_connection::connectingRoad_optional& t_junction_connection::
      connectingRoad () const
      {
        return this->connectingRoad_;
      }

      t_junction_connection::connectingRoad_optional& t_junction_connection::
      connectingRoad ()
      {
        return this->connectingRoad_;
      }

      void t_junction_connection::
      connectingRoad (const connectingRoad_type& x)
      {
        this->connectingRoad_.set (x);
      }

      void t_junction_connection::
      connectingRoad (const connectingRoad_optional& x)
      {
        this->connectingRoad_ = x;
      }

      void t_junction_connection::
      connectingRoad (::std::unique_ptr< connectingRoad_type > x)
      {
        this->connectingRoad_.set (std::move (x));
      }

      const t_junction_connection::contactPoint_optional& t_junction_connection::
      contactPoint () const
      {
        return this->contactPoint_;
      }

      t_junction_connection::contactPoint_optional& t_junction_connection::
      contactPoint ()
      {
        return this->contactPoint_;
      }

      void t_junction_connection::
      contactPoint (const contactPoint_type& x)
      {
        this->contactPoint_.set (x);
      }

      void t_junction_connection::
      contactPoint (const contactPoint_optional& x)
      {
        this->contactPoint_ = x;
      }

      void t_junction_connection::
      contactPoint (::std::unique_ptr< contactPoint_type > x)
      {
        this->contactPoint_.set (std::move (x));
      }


      // t_junction_connection_laneLink
      // 

      const t_junction_connection_laneLink::from_type& t_junction_connection_laneLink::
      from () const
      {
        return this->from_.get ();
      }

      t_junction_connection_laneLink::from_type& t_junction_connection_laneLink::
      from ()
      {
        return this->from_.get ();
      }

      void t_junction_connection_laneLink::
      from (const from_type& x)
      {
        this->from_.set (x);
      }

      const t_junction_connection_laneLink::to_type& t_junction_connection_laneLink::
      to () const
      {
        return this->to_.get ();
      }

      t_junction_connection_laneLink::to_type& t_junction_connection_laneLink::
      to ()
      {
        return this->to_.get ();
      }

      void t_junction_connection_laneLink::
      to (const to_type& x)
      {
        this->to_.set (x);
      }


      // t_junction_controller
      // 

      const t_junction_controller::id_type& t_junction_controller::
      id () const
      {
        return this->id_.get ();
      }

      t_junction_controller::id_type& t_junction_controller::
      id ()
      {
        return this->id_.get ();
      }

      void t_junction_controller::
      id (const id_type& x)
      {
        this->id_.set (x);
      }

      void t_junction_controller::
      id (::std::unique_ptr< id_type > x)
      {
        this->id_.set (std::move (x));
      }

      const t_junction_controller::type_optional& t_junction_controller::
      type () const
      {
        return this->type_;
      }

      t_junction_controller::type_optional& t_junction_controller::
      type ()
      {
        return this->type_;
      }

      void t_junction_controller::
      type (const type_type& x)
      {
        this->type_.set (x);
      }

      void t_junction_controller::
      type (const type_optional& x)
      {
        this->type_ = x;
      }

      void t_junction_controller::
      type (::std::unique_ptr< type_type > x)
      {
        this->type_.set (std::move (x));
      }

      const t_junction_controller::sequence_optional& t_junction_controller::
      sequence () const
      {
        return this->sequence_;
      }

      t_junction_controller::sequence_optional& t_junction_controller::
      sequence ()
      {
        return this->sequence_;
      }

      void t_junction_controller::
      sequence (const sequence_type& x)
      {
        this->sequence_.set (x);
      }

      void t_junction_controller::
      sequence (const sequence_optional& x)
      {
        this->sequence_ = x;
      }


      // t_junction_predecessorSuccessor
      // 

      const t_junction_predecessorSuccessor::elementType_type& t_junction_predecessorSuccessor::
      elementType () const
      {
        return this->elementType_.get ();
      }

      const t_junction_predecessorSuccessor::elementType_type& t_junction_predecessorSuccessor::
      elementType_default_value ()
      {
        return elementType_default_value_;
      }

      const t_junction_predecessorSuccessor::elementId_type& t_junction_predecessorSuccessor::
      elementId () const
      {
        return this->elementId_.get ();
      }

      t_junction_predecessorSuccessor::elementId_type& t_junction_predecessorSuccessor::
      elementId ()
      {
        return this->elementId_.get ();
      }

      void t_junction_predecessorSuccessor::
      elementId (const elementId_type& x)
      {
        this->elementId_.set (x);
      }

      void t_junction_predecessorSuccessor::
      elementId (::std::unique_ptr< elementId_type > x)
      {
        this->elementId_.set (std::move (x));
      }

      const t_junction_predecessorSuccessor::elementS_type& t_junction_predecessorSuccessor::
      elementS () const
      {
        return this->elementS_.get ();
      }

      t_junction_predecessorSuccessor::elementS_type& t_junction_predecessorSuccessor::
      elementS ()
      {
        return this->elementS_.get ();
      }

      void t_junction_predecessorSuccessor::
      elementS (const elementS_type& x)
      {
        this->elementS_.set (x);
      }

      void t_junction_predecessorSuccessor::
      elementS (::std::unique_ptr< elementS_type > x)
      {
        this->elementS_.set (std::move (x));
      }

      const t_junction_predecessorSuccessor::elementDir_type& t_junction_predecessorSuccessor::
      elementDir () const
      {
        return this->elementDir_.get ();
      }

      t_junction_predecessorSuccessor::elementDir_type& t_junction_predecessorSuccessor::
      elementDir ()
      {
        return this->elementDir_.get ();
      }

      void t_junction_predecessorSuccessor::
      elementDir (const elementDir_type& x)
      {
        this->elementDir_.set (x);
      }

      void t_junction_predecessorSuccessor::
      elementDir (::std::unique_ptr< elementDir_type > x)
      {
        this->elementDir_.set (std::move (x));
      }


      // t_junction_priority
      // 

      const t_junction_priority::high_optional& t_junction_priority::
      high () const
      {
        return this->high_;
      }

      t_junction_priority::high_optional& t_junction_priority::
      high ()
      {
        return this->high_;
      }

      void t_junction_priority::
      high (const high_type& x)
      {
        this->high_.set (x);
      }

      void t_junction_priority::
      high (const high_optional& x)
      {
        this->high_ = x;
      }

      void t_junction_priority::
      high (::std::unique_ptr< high_type > x)
      {
        this->high_.set (std::move (x));
      }

      const t_junction_priority::low_optional& t_junction_priority::
      low () const
      {
        return this->low_;
      }

      t_junction_priority::low_optional& t_junction_priority::
      low ()
      {
        return this->low_;
      }

      void t_junction_priority::
      low (const low_type& x)
      {
        this->low_.set (x);
      }

      void t_junction_priority::
      low (const low_optional& x)
      {
        this->low_ = x;
      }

      void t_junction_priority::
      low (::std::unique_ptr< low_type > x)
      {
        this->low_.set (std::move (x));
      }


      // t_junction_surface
      // 

      const t_junction_surface::CRG_sequence& t_junction_surface::
      CRG () const
      {
        return this->CRG_;
      }

      t_junction_surface::CRG_sequence& t_junction_surface::
      CRG ()
      {
        return this->CRG_;
      }

      void t_junction_surface::
      CRG (const CRG_sequence& s)
      {
        this->CRG_ = s;
      }

      const t_junction_surface::include_sequence& t_junction_surface::
      include () const
      {
        return this->include_;
      }

      t_junction_surface::include_sequence& t_junction_surface::
      include ()
      {
        return this->include_;
      }

      void t_junction_surface::
      include (const include_sequence& s)
      {
        this->include_ = s;
      }

      const t_junction_surface::userData_sequence& t_junction_surface::
      userData () const
      {
        return this->userData_;
      }

      t_junction_surface::userData_sequence& t_junction_surface::
      userData ()
      {
        return this->userData_;
      }

      void t_junction_surface::
      userData (const userData_sequence& s)
      {
        this->userData_ = s;
      }

      const t_junction_surface::dataQuality_sequence& t_junction_surface::
      dataQuality () const
      {
        return this->dataQuality_;
      }

      t_junction_surface::dataQuality_sequence& t_junction_surface::
      dataQuality ()
      {
        return this->dataQuality_;
      }

      void t_junction_surface::
      dataQuality (const dataQuality_sequence& s)
      {
        this->dataQuality_ = s;
      }


      // t_junction_surface_CRG
      // 

      const t_junction_surface_CRG::file_type& t_junction_surface_CRG::
      file () const
      {
        return this->file_.get ();
      }

      t_junction_surface_CRG::file_type& t_junction_surface_CRG::
      file ()
      {
        return this->file_.get ();
      }

      void t_junction_surface_CRG::
      file (const file_type& x)
      {
        this->file_.set (x);
      }

      void t_junction_surface_CRG::
      file (::std::unique_ptr< file_type > x)
      {
        this->file_.set (std::move (x));
      }

      const t_junction_surface_CRG::mode_type& t_junction_surface_CRG::
      mode () const
      {
        return this->mode_.get ();
      }

      const t_junction_surface_CRG::mode_type& t_junction_surface_CRG::
      mode_default_value ()
      {
        return mode_default_value_;
      }

      const t_junction_surface_CRG::purpose_optional& t_junction_surface_CRG::
      purpose () const
      {
        return this->purpose_;
      }

      t_junction_surface_CRG::purpose_optional& t_junction_surface_CRG::
      purpose ()
      {
        return this->purpose_;
      }

      void t_junction_surface_CRG::
      purpose (const purpose_type& x)
      {
        this->purpose_.set (x);
      }

      void t_junction_surface_CRG::
      purpose (const purpose_optional& x)
      {
        this->purpose_ = x;
      }

      void t_junction_surface_CRG::
      purpose (::std::unique_ptr< purpose_type > x)
      {
        this->purpose_.set (std::move (x));
      }

      const t_junction_surface_CRG::zOffset_optional& t_junction_surface_CRG::
      zOffset () const
      {
        return this->zOffset_;
      }

      t_junction_surface_CRG::zOffset_optional& t_junction_surface_CRG::
      zOffset ()
      {
        return this->zOffset_;
      }

      void t_junction_surface_CRG::
      zOffset (const zOffset_type& x)
      {
        this->zOffset_.set (x);
      }

      void t_junction_surface_CRG::
      zOffset (const zOffset_optional& x)
      {
        this->zOffset_ = x;
      }

      const t_junction_surface_CRG::zScale_optional& t_junction_surface_CRG::
      zScale () const
      {
        return this->zScale_;
      }

      t_junction_surface_CRG::zScale_optional& t_junction_surface_CRG::
      zScale ()
      {
        return this->zScale_;
      }

      void t_junction_surface_CRG::
      zScale (const zScale_type& x)
      {
        this->zScale_.set (x);
      }

      void t_junction_surface_CRG::
      zScale (const zScale_optional& x)
      {
        this->zScale_ = x;
      }


      // t_junctionGroup
      // 

      const t_junctionGroup::junctionReference_sequence& t_junctionGroup::
      junctionReference () const
      {
        return this->junctionReference_;
      }

      t_junctionGroup::junctionReference_sequence& t_junctionGroup::
      junctionReference ()
      {
        return this->junctionReference_;
      }

      void t_junctionGroup::
      junctionReference (const junctionReference_sequence& s)
      {
        this->junctionReference_ = s;
      }

      const t_junctionGroup::include_sequence& t_junctionGroup::
      include () const
      {
        return this->include_;
      }

      t_junctionGroup::include_sequence& t_junctionGroup::
      include ()
      {
        return this->include_;
      }

      void t_junctionGroup::
      include (const include_sequence& s)
      {
        this->include_ = s;
      }

      const t_junctionGroup::userData_sequence& t_junctionGroup::
      userData () const
      {
        return this->userData_;
      }

      t_junctionGroup::userData_sequence& t_junctionGroup::
      userData ()
      {
        return this->userData_;
      }

      void t_junctionGroup::
      userData (const userData_sequence& s)
      {
        this->userData_ = s;
      }

      const t_junctionGroup::dataQuality_sequence& t_junctionGroup::
      dataQuality () const
      {
        return this->dataQuality_;
      }

      t_junctionGroup::dataQuality_sequence& t_junctionGroup::
      dataQuality ()
      {
        return this->dataQuality_;
      }

      void t_junctionGroup::
      dataQuality (const dataQuality_sequence& s)
      {
        this->dataQuality_ = s;
      }

      const t_junctionGroup::name_optional& t_junctionGroup::
      name () const
      {
        return this->name_;
      }

      t_junctionGroup::name_optional& t_junctionGroup::
      name ()
      {
        return this->name_;
      }

      void t_junctionGroup::
      name (const name_type& x)
      {
        this->name_.set (x);
      }

      void t_junctionGroup::
      name (const name_optional& x)
      {
        this->name_ = x;
      }

      void t_junctionGroup::
      name (::std::unique_ptr< name_type > x)
      {
        this->name_.set (std::move (x));
      }

      const t_junctionGroup::id_type& t_junctionGroup::
      id () const
      {
        return this->id_.get ();
      }

      t_junctionGroup::id_type& t_junctionGroup::
      id ()
      {
        return this->id_.get ();
      }

      void t_junctionGroup::
      id (const id_type& x)
      {
        this->id_.set (x);
      }

      void t_junctionGroup::
      id (::std::unique_ptr< id_type > x)
      {
        this->id_.set (std::move (x));
      }

      const t_junctionGroup::type_type& t_junctionGroup::
      type () const
      {
        return this->type_.get ();
      }

      t_junctionGroup::type_type& t_junctionGroup::
      type ()
      {
        return this->type_.get ();
      }

      void t_junctionGroup::
      type (const type_type& x)
      {
        this->type_.set (x);
      }

      void t_junctionGroup::
      type (::std::unique_ptr< type_type > x)
      {
        this->type_.set (std::move (x));
      }


      // t_junctionGroup_junctionReference
      // 

      const t_junctionGroup_junctionReference::junction_type& t_junctionGroup_junctionReference::
      junction () const
      {
        return this->junction_.get ();
      }

      t_junctionGroup_junctionReference::junction_type& t_junctionGroup_junctionReference::
      junction ()
      {
        return this->junction_.get ();
      }

      void t_junctionGroup_junctionReference::
      junction (const junction_type& x)
      {
        this->junction_.set (x);
      }

      void t_junctionGroup_junctionReference::
      junction (::std::unique_ptr< junction_type > x)
      {
        this->junction_.set (std::move (x));
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace simulation
{
  namespace standard
  {
    namespace opendrive_schema
    {
      // e_contactPoint
      //

      e_contactPoint::
      e_contactPoint (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_e_contactPoint_convert ();
      }

      e_contactPoint::
      e_contactPoint (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_e_contactPoint_convert ();
      }

      e_contactPoint::
      e_contactPoint (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_e_contactPoint_convert ();
      }

      e_contactPoint* e_contactPoint::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class e_contactPoint (*this, f, c);
      }

      e_contactPoint::value e_contactPoint::
      _xsd_e_contactPoint_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_contactPoint_literals_);
        const value* i (::std::lower_bound (
                          _xsd_e_contactPoint_indexes_,
                          _xsd_e_contactPoint_indexes_ + 2,
                          *this,
                          c));

        if (i == _xsd_e_contactPoint_indexes_ + 2 || _xsd_e_contactPoint_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const e_contactPoint::
      _xsd_e_contactPoint_literals_[2] =
      {
        "start",
        "end"
      };

      const e_contactPoint::value e_contactPoint::
      _xsd_e_contactPoint_indexes_[2] =
      {
        ::simulation::standard::opendrive_schema::e_contactPoint::end,
        ::simulation::standard::opendrive_schema::e_contactPoint::start
      };

      // e_elementDir
      //

      e_elementDir::
      e_elementDir (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_e_elementDir_convert ();
      }

      e_elementDir::
      e_elementDir (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_e_elementDir_convert ();
      }

      e_elementDir::
      e_elementDir (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_e_elementDir_convert ();
      }

      e_elementDir* e_elementDir::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class e_elementDir (*this, f, c);
      }

      e_elementDir::value e_elementDir::
      _xsd_e_elementDir_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_elementDir_literals_);
        const value* i (::std::lower_bound (
                          _xsd_e_elementDir_indexes_,
                          _xsd_e_elementDir_indexes_ + 2,
                          *this,
                          c));

        if (i == _xsd_e_elementDir_indexes_ + 2 || _xsd_e_elementDir_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const e_elementDir::
      _xsd_e_elementDir_literals_[2] =
      {
        "+",
        "-"
      };

      const e_elementDir::value e_elementDir::
      _xsd_e_elementDir_indexes_[2] =
      {
        ::simulation::standard::opendrive_schema::e_elementDir::cxx_,
        ::simulation::standard::opendrive_schema::e_elementDir::cxx_1
      };

      // e_junction_type
      //

      e_junction_type::
      e_junction_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_e_junction_type_convert ();
      }

      e_junction_type::
      e_junction_type (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_e_junction_type_convert ();
      }

      e_junction_type::
      e_junction_type (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_e_junction_type_convert ();
      }

      e_junction_type* e_junction_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class e_junction_type (*this, f, c);
      }

      e_junction_type::value e_junction_type::
      _xsd_e_junction_type_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_junction_type_literals_);
        const value* i (::std::lower_bound (
                          _xsd_e_junction_type_indexes_,
                          _xsd_e_junction_type_indexes_ + 2,
                          *this,
                          c));

        if (i == _xsd_e_junction_type_indexes_ + 2 || _xsd_e_junction_type_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const e_junction_type::
      _xsd_e_junction_type_literals_[2] =
      {
        "default",
        "virtual"
      };

      const e_junction_type::value e_junction_type::
      _xsd_e_junction_type_indexes_[2] =
      {
        ::simulation::standard::opendrive_schema::e_junction_type::default_,
        ::simulation::standard::opendrive_schema::e_junction_type::virtual_
      };

      // e_junctionGroup_type
      //

      e_junctionGroup_type::
      e_junctionGroup_type (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_e_junctionGroup_type_convert ();
      }

      e_junctionGroup_type::
      e_junctionGroup_type (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_e_junctionGroup_type_convert ();
      }

      e_junctionGroup_type::
      e_junctionGroup_type (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_e_junctionGroup_type_convert ();
      }

      e_junctionGroup_type* e_junctionGroup_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class e_junctionGroup_type (*this, f, c);
      }

      e_junctionGroup_type::value e_junctionGroup_type::
      _xsd_e_junctionGroup_type_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_junctionGroup_type_literals_);
        const value* i (::std::lower_bound (
                          _xsd_e_junctionGroup_type_indexes_,
                          _xsd_e_junctionGroup_type_indexes_ + 2,
                          *this,
                          c));

        if (i == _xsd_e_junctionGroup_type_indexes_ + 2 || _xsd_e_junctionGroup_type_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const e_junctionGroup_type::
      _xsd_e_junctionGroup_type_literals_[2] =
      {
        "roundabout",
        "unknown"
      };

      const e_junctionGroup_type::value e_junctionGroup_type::
      _xsd_e_junctionGroup_type_indexes_[2] =
      {
        ::simulation::standard::opendrive_schema::e_junctionGroup_type::roundabout,
        ::simulation::standard::opendrive_schema::e_junctionGroup_type::unknown
      };

      // e_road_surface_CRG_mode
      //

      e_road_surface_CRG_mode::
      e_road_surface_CRG_mode (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_e_road_surface_CRG_mode_convert ();
      }

      e_road_surface_CRG_mode::
      e_road_surface_CRG_mode (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_e_road_surface_CRG_mode_convert ();
      }

      e_road_surface_CRG_mode::
      e_road_surface_CRG_mode (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_e_road_surface_CRG_mode_convert ();
      }

      e_road_surface_CRG_mode* e_road_surface_CRG_mode::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class e_road_surface_CRG_mode (*this, f, c);
      }

      e_road_surface_CRG_mode::value e_road_surface_CRG_mode::
      _xsd_e_road_surface_CRG_mode_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_surface_CRG_mode_literals_);
        const value* i (::std::lower_bound (
                          _xsd_e_road_surface_CRG_mode_indexes_,
                          _xsd_e_road_surface_CRG_mode_indexes_ + 4,
                          *this,
                          c));

        if (i == _xsd_e_road_surface_CRG_mode_indexes_ + 4 || _xsd_e_road_surface_CRG_mode_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const e_road_surface_CRG_mode::
      _xsd_e_road_surface_CRG_mode_literals_[4] =
      {
        "attached",
        "attached0",
        "genuine",
        "global"
      };

      const e_road_surface_CRG_mode::value e_road_surface_CRG_mode::
      _xsd_e_road_surface_CRG_mode_indexes_[4] =
      {
        ::simulation::standard::opendrive_schema::e_road_surface_CRG_mode::attached,
        ::simulation::standard::opendrive_schema::e_road_surface_CRG_mode::attached0,
        ::simulation::standard::opendrive_schema::e_road_surface_CRG_mode::genuine,
        ::simulation::standard::opendrive_schema::e_road_surface_CRG_mode::global
      };

      // e_road_surface_CRG_purpose
      //

      e_road_surface_CRG_purpose::
      e_road_surface_CRG_purpose (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_e_road_surface_CRG_purpose_convert ();
      }

      e_road_surface_CRG_purpose::
      e_road_surface_CRG_purpose (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_e_road_surface_CRG_purpose_convert ();
      }

      e_road_surface_CRG_purpose::
      e_road_surface_CRG_purpose (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_e_road_surface_CRG_purpose_convert ();
      }

      e_road_surface_CRG_purpose* e_road_surface_CRG_purpose::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class e_road_surface_CRG_purpose (*this, f, c);
      }

      e_road_surface_CRG_purpose::value e_road_surface_CRG_purpose::
      _xsd_e_road_surface_CRG_purpose_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_surface_CRG_purpose_literals_);
        const value* i (::std::lower_bound (
                          _xsd_e_road_surface_CRG_purpose_indexes_,
                          _xsd_e_road_surface_CRG_purpose_indexes_ + 2,
                          *this,
                          c));

        if (i == _xsd_e_road_surface_CRG_purpose_indexes_ + 2 || _xsd_e_road_surface_CRG_purpose_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const e_road_surface_CRG_purpose::
      _xsd_e_road_surface_CRG_purpose_literals_[2] =
      {
        "elevation",
        "friction"
      };

      const e_road_surface_CRG_purpose::value e_road_surface_CRG_purpose::
      _xsd_e_road_surface_CRG_purpose_indexes_[2] =
      {
        ::simulation::standard::opendrive_schema::e_road_surface_CRG_purpose::elevation,
        ::simulation::standard::opendrive_schema::e_road_surface_CRG_purpose::friction
      };

      // t_junction
      //

      t_junction::
      t_junction (const id_type& id)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        connection_ (this),
        priority_ (this),
        controller_ (this),
        surface_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        name_ (this),
        id_ (id, this),
        type_ (this)
      {
      }

      t_junction::
      t_junction (const t_junction& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        connection_ (x.connection_, f, this),
        priority_ (x.priority_, f, this),
        controller_ (x.controller_, f, this),
        surface_ (x.surface_, f, this),
        include_ (x.include_, f, this),
        userData_ (x.userData_, f, this),
        dataQuality_ (x.dataQuality_, f, this),
        name_ (x.name_, f, this),
        id_ (x.id_, f, this),
        type_ (x.type_, f, this)
      {
      }

      t_junction::
      t_junction (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        connection_ (this),
        priority_ (this),
        controller_ (this),
        surface_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        name_ (this),
        id_ (this),
        type_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void t_junction::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // connection
          //
          if (n.name () == "connection" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< connection_type > r (
              connection_traits::create (i, f, this));

            this->connection_.push_back (::std::move (r));
            continue;
          }

          // priority
          //
          if (n.name () == "priority" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< priority_type > r (
              priority_traits::create (i, f, this));

            this->priority_.push_back (::std::move (r));
            continue;
          }

          // controller
          //
          if (n.name () == "controller" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< controller_type > r (
              controller_traits::create (i, f, this));

            this->controller_.push_back (::std::move (r));
            continue;
          }

          // surface
          //
          if (n.name () == "surface" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< surface_type > r (
              surface_traits::create (i, f, this));

            if (!this->surface_)
            {
              this->surface_.set (::std::move (r));
              continue;
            }
          }

          // include
          //
          if (n.name () == "include" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< include_type > r (
              include_traits::create (i, f, this));

            this->include_.push_back (::std::move (r));
            continue;
          }

          // userData
          //
          if (n.name () == "userData" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< userData_type > r (
              userData_traits::create (i, f, this));

            this->userData_.push_back (::std::move (r));
            continue;
          }

          // dataQuality
          //
          if (n.name () == "dataQuality" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< dataQuality_type > r (
              dataQuality_traits::create (i, f, this));

            this->dataQuality_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            this->name_.set (name_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (id_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "type" && n.namespace_ ().empty ())
          {
            this->type_.set (type_traits::create (i, f, this));
            continue;
          }
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "id",
            "");
        }
      }

      t_junction* t_junction::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_junction (*this, f, c);
      }

      t_junction& t_junction::
      operator= (const t_junction& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->connection_ = x.connection_;
          this->priority_ = x.priority_;
          this->controller_ = x.controller_;
          this->surface_ = x.surface_;
          this->include_ = x.include_;
          this->userData_ = x.userData_;
          this->dataQuality_ = x.dataQuality_;
          this->name_ = x.name_;
          this->id_ = x.id_;
          this->type_ = x.type_;
        }

        return *this;
      }

      t_junction::
      ~t_junction ()
      {
      }

      // t_junction_connection
      //

      t_junction_connection::
      t_junction_connection (const id_type& id)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        predecessor_ (this),
        successor_ (this),
        laneLink_ (this),
        id_ (id, this),
        type_ (this),
        incomingRoad_ (this),
        connectingRoad_ (this),
        contactPoint_ (this)
      {
      }

      t_junction_connection::
      t_junction_connection (const t_junction_connection& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        predecessor_ (x.predecessor_, f, this),
        successor_ (x.successor_, f, this),
        laneLink_ (x.laneLink_, f, this),
        id_ (x.id_, f, this),
        type_ (x.type_, f, this),
        incomingRoad_ (x.incomingRoad_, f, this),
        connectingRoad_ (x.connectingRoad_, f, this),
        contactPoint_ (x.contactPoint_, f, this)
      {
      }

      t_junction_connection::
      t_junction_connection (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        predecessor_ (this),
        successor_ (this),
        laneLink_ (this),
        id_ (this),
        type_ (this),
        incomingRoad_ (this),
        connectingRoad_ (this),
        contactPoint_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void t_junction_connection::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // predecessor
          //
          if (n.name () == "predecessor" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< predecessor_type > r (
              predecessor_traits::create (i, f, this));

            if (!this->predecessor_)
            {
              this->predecessor_.set (::std::move (r));
              continue;
            }
          }

          // successor
          //
          if (n.name () == "successor" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< successor_type > r (
              successor_traits::create (i, f, this));

            if (!this->successor_)
            {
              this->successor_.set (::std::move (r));
              continue;
            }
          }

          // laneLink
          //
          if (n.name () == "laneLink" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< laneLink_type > r (
              laneLink_traits::create (i, f, this));

            this->laneLink_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (id_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "type" && n.namespace_ ().empty ())
          {
            this->type_.set (type_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "incomingRoad" && n.namespace_ ().empty ())
          {
            this->incomingRoad_.set (incomingRoad_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "connectingRoad" && n.namespace_ ().empty ())
          {
            this->connectingRoad_.set (connectingRoad_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "contactPoint" && n.namespace_ ().empty ())
          {
            this->contactPoint_.set (contactPoint_traits::create (i, f, this));
            continue;
          }
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "id",
            "");
        }
      }

      t_junction_connection* t_junction_connection::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_junction_connection (*this, f, c);
      }

      t_junction_connection& t_junction_connection::
      operator= (const t_junction_connection& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->predecessor_ = x.predecessor_;
          this->successor_ = x.successor_;
          this->laneLink_ = x.laneLink_;
          this->id_ = x.id_;
          this->type_ = x.type_;
          this->incomingRoad_ = x.incomingRoad_;
          this->connectingRoad_ = x.connectingRoad_;
          this->contactPoint_ = x.contactPoint_;
        }

        return *this;
      }

      t_junction_connection::
      ~t_junction_connection ()
      {
      }

      // t_junction_connection_laneLink
      //

      t_junction_connection_laneLink::
      t_junction_connection_laneLink (const from_type& from,
                                      const to_type& to)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        from_ (from, this),
        to_ (to, this)
      {
      }

      t_junction_connection_laneLink::
      t_junction_connection_laneLink (const t_junction_connection_laneLink& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        from_ (x.from_, f, this),
        to_ (x.to_, f, this)
      {
      }

      t_junction_connection_laneLink::
      t_junction_connection_laneLink (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        from_ (this),
        to_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void t_junction_connection_laneLink::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "from" && n.namespace_ ().empty ())
          {
            this->from_.set (from_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "to" && n.namespace_ ().empty ())
          {
            this->to_.set (to_traits::create (i, f, this));
            continue;
          }
        }

        if (!from_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "from",
            "");
        }

        if (!to_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "to",
            "");
        }
      }

      t_junction_connection_laneLink* t_junction_connection_laneLink::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_junction_connection_laneLink (*this, f, c);
      }

      t_junction_connection_laneLink& t_junction_connection_laneLink::
      operator= (const t_junction_connection_laneLink& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->from_ = x.from_;
          this->to_ = x.to_;
        }

        return *this;
      }

      t_junction_connection_laneLink::
      ~t_junction_connection_laneLink ()
      {
      }

      // t_junction_controller
      //

      t_junction_controller::
      t_junction_controller (const id_type& id)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        id_ (id, this),
        type_ (this),
        sequence_ (this)
      {
      }

      t_junction_controller::
      t_junction_controller (const t_junction_controller& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        id_ (x.id_, f, this),
        type_ (x.type_, f, this),
        sequence_ (x.sequence_, f, this)
      {
      }

      t_junction_controller::
      t_junction_controller (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        id_ (this),
        type_ (this),
        sequence_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void t_junction_controller::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (id_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "type" && n.namespace_ ().empty ())
          {
            this->type_.set (type_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "sequence" && n.namespace_ ().empty ())
          {
            this->sequence_.set (sequence_traits::create (i, f, this));
            continue;
          }
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "id",
            "");
        }
      }

      t_junction_controller* t_junction_controller::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_junction_controller (*this, f, c);
      }

      t_junction_controller& t_junction_controller::
      operator= (const t_junction_controller& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->id_ = x.id_;
          this->type_ = x.type_;
          this->sequence_ = x.sequence_;
        }

        return *this;
      }

      t_junction_controller::
      ~t_junction_controller ()
      {
      }

      // t_junction_predecessorSuccessor
      //

      const t_junction_predecessorSuccessor::elementType_type t_junction_predecessorSuccessor::elementType_default_value_ (
        "road");

      t_junction_predecessorSuccessor::
      t_junction_predecessorSuccessor (const elementId_type& elementId,
                                       const elementS_type& elementS,
                                       const elementDir_type& elementDir)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        elementType_ (elementType_default_value (), this),
        elementId_ (elementId, this),
        elementS_ (elementS, this),
        elementDir_ (elementDir, this)
      {
      }

      t_junction_predecessorSuccessor::
      t_junction_predecessorSuccessor (const t_junction_predecessorSuccessor& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        elementType_ (x.elementType_, f, this),
        elementId_ (x.elementId_, f, this),
        elementS_ (x.elementS_, f, this),
        elementDir_ (x.elementDir_, f, this)
      {
      }

      t_junction_predecessorSuccessor::
      t_junction_predecessorSuccessor (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        elementType_ (this),
        elementId_ (this),
        elementS_ (this),
        elementDir_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void t_junction_predecessorSuccessor::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "elementType" && n.namespace_ ().empty ())
          {
            this->elementType_.set (elementType_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "elementId" && n.namespace_ ().empty ())
          {
            this->elementId_.set (elementId_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "elementS" && n.namespace_ ().empty ())
          {
            this->elementS_.set (elementS_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "elementDir" && n.namespace_ ().empty ())
          {
            this->elementDir_.set (elementDir_traits::create (i, f, this));
            continue;
          }
        }

        if (!elementType_.present ())
        {
          this->elementType_.set (elementType_default_value ());
        }

        if (!elementId_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "elementId",
            "");
        }

        if (!elementS_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "elementS",
            "");
        }

        if (!elementDir_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "elementDir",
            "");
        }
      }

      t_junction_predecessorSuccessor* t_junction_predecessorSuccessor::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_junction_predecessorSuccessor (*this, f, c);
      }

      t_junction_predecessorSuccessor& t_junction_predecessorSuccessor::
      operator= (const t_junction_predecessorSuccessor& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->elementType_ = x.elementType_;
          this->elementId_ = x.elementId_;
          this->elementS_ = x.elementS_;
          this->elementDir_ = x.elementDir_;
        }

        return *this;
      }

      t_junction_predecessorSuccessor::
      ~t_junction_predecessorSuccessor ()
      {
      }

      // t_junction_priority
      //

      t_junction_priority::
      t_junction_priority ()
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        high_ (this),
        low_ (this)
      {
      }

      t_junction_priority::
      t_junction_priority (const t_junction_priority& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        high_ (x.high_, f, this),
        low_ (x.low_, f, this)
      {
      }

      t_junction_priority::
      t_junction_priority (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        high_ (this),
        low_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void t_junction_priority::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "high" && n.namespace_ ().empty ())
          {
            this->high_.set (high_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "low" && n.namespace_ ().empty ())
          {
            this->low_.set (low_traits::create (i, f, this));
            continue;
          }
        }
      }

      t_junction_priority* t_junction_priority::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_junction_priority (*this, f, c);
      }

      t_junction_priority& t_junction_priority::
      operator= (const t_junction_priority& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->high_ = x.high_;
          this->low_ = x.low_;
        }

        return *this;
      }

      t_junction_priority::
      ~t_junction_priority ()
      {
      }

      // t_junction_surface
      //

      t_junction_surface::
      t_junction_surface ()
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        CRG_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this)
      {
      }

      t_junction_surface::
      t_junction_surface (const t_junction_surface& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        CRG_ (x.CRG_, f, this),
        include_ (x.include_, f, this),
        userData_ (x.userData_, f, this),
        dataQuality_ (x.dataQuality_, f, this)
      {
      }

      t_junction_surface::
      t_junction_surface (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        CRG_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void t_junction_surface::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // CRG
          //
          if (n.name () == "CRG" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< CRG_type > r (
              CRG_traits::create (i, f, this));

            this->CRG_.push_back (::std::move (r));
            continue;
          }

          // include
          //
          if (n.name () == "include" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< include_type > r (
              include_traits::create (i, f, this));

            this->include_.push_back (::std::move (r));
            continue;
          }

          // userData
          //
          if (n.name () == "userData" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< userData_type > r (
              userData_traits::create (i, f, this));

            this->userData_.push_back (::std::move (r));
            continue;
          }

          // dataQuality
          //
          if (n.name () == "dataQuality" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< dataQuality_type > r (
              dataQuality_traits::create (i, f, this));

            this->dataQuality_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      t_junction_surface* t_junction_surface::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_junction_surface (*this, f, c);
      }

      t_junction_surface& t_junction_surface::
      operator= (const t_junction_surface& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->CRG_ = x.CRG_;
          this->include_ = x.include_;
          this->userData_ = x.userData_;
          this->dataQuality_ = x.dataQuality_;
        }

        return *this;
      }

      t_junction_surface::
      ~t_junction_surface ()
      {
      }

      // t_junction_surface_CRG
      //

      const t_junction_surface_CRG::mode_type t_junction_surface_CRG::mode_default_value_ (
        "global");

      t_junction_surface_CRG::
      t_junction_surface_CRG (const file_type& file)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        file_ (file, this),
        mode_ (mode_default_value (), this),
        purpose_ (this),
        zOffset_ (this),
        zScale_ (this)
      {
      }

      t_junction_surface_CRG::
      t_junction_surface_CRG (const t_junction_surface_CRG& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        file_ (x.file_, f, this),
        mode_ (x.mode_, f, this),
        purpose_ (x.purpose_, f, this),
        zOffset_ (x.zOffset_, f, this),
        zScale_ (x.zScale_, f, this)
      {
      }

      t_junction_surface_CRG::
      t_junction_surface_CRG (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        file_ (this),
        mode_ (this),
        purpose_ (this),
        zOffset_ (this),
        zScale_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void t_junction_surface_CRG::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "file" && n.namespace_ ().empty ())
          {
            this->file_.set (file_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "mode" && n.namespace_ ().empty ())
          {
            this->mode_.set (mode_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "purpose" && n.namespace_ ().empty ())
          {
            this->purpose_.set (purpose_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "zOffset" && n.namespace_ ().empty ())
          {
            this->zOffset_.set (zOffset_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "zScale" && n.namespace_ ().empty ())
          {
            this->zScale_.set (zScale_traits::create (i, f, this));
            continue;
          }
        }

        if (!file_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "file",
            "");
        }

        if (!mode_.present ())
        {
          this->mode_.set (mode_default_value ());
        }
      }

      t_junction_surface_CRG* t_junction_surface_CRG::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_junction_surface_CRG (*this, f, c);
      }

      t_junction_surface_CRG& t_junction_surface_CRG::
      operator= (const t_junction_surface_CRG& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->file_ = x.file_;
          this->mode_ = x.mode_;
          this->purpose_ = x.purpose_;
          this->zOffset_ = x.zOffset_;
          this->zScale_ = x.zScale_;
        }

        return *this;
      }

      t_junction_surface_CRG::
      ~t_junction_surface_CRG ()
      {
      }

      // t_junctionGroup
      //

      t_junctionGroup::
      t_junctionGroup (const id_type& id,
                       const type_type& type)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        junctionReference_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        name_ (this),
        id_ (id, this),
        type_ (type, this)
      {
      }

      t_junctionGroup::
      t_junctionGroup (const t_junctionGroup& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        junctionReference_ (x.junctionReference_, f, this),
        include_ (x.include_, f, this),
        userData_ (x.userData_, f, this),
        dataQuality_ (x.dataQuality_, f, this),
        name_ (x.name_, f, this),
        id_ (x.id_, f, this),
        type_ (x.type_, f, this)
      {
      }

      t_junctionGroup::
      t_junctionGroup (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        junctionReference_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        name_ (this),
        id_ (this),
        type_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void t_junctionGroup::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // junctionReference
          //
          if (n.name () == "junctionReference" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< junctionReference_type > r (
              junctionReference_traits::create (i, f, this));

            this->junctionReference_.push_back (::std::move (r));
            continue;
          }

          // include
          //
          if (n.name () == "include" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< include_type > r (
              include_traits::create (i, f, this));

            this->include_.push_back (::std::move (r));
            continue;
          }

          // userData
          //
          if (n.name () == "userData" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< userData_type > r (
              userData_traits::create (i, f, this));

            this->userData_.push_back (::std::move (r));
            continue;
          }

          // dataQuality
          //
          if (n.name () == "dataQuality" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< dataQuality_type > r (
              dataQuality_traits::create (i, f, this));

            this->dataQuality_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            this->name_.set (name_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (id_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "type" && n.namespace_ ().empty ())
          {
            this->type_.set (type_traits::create (i, f, this));
            continue;
          }
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "id",
            "");
        }

        if (!type_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "type",
            "");
        }
      }

      t_junctionGroup* t_junctionGroup::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_junctionGroup (*this, f, c);
      }

      t_junctionGroup& t_junctionGroup::
      operator= (const t_junctionGroup& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->junctionReference_ = x.junctionReference_;
          this->include_ = x.include_;
          this->userData_ = x.userData_;
          this->dataQuality_ = x.dataQuality_;
          this->name_ = x.name_;
          this->id_ = x.id_;
          this->type_ = x.type_;
        }

        return *this;
      }

      t_junctionGroup::
      ~t_junctionGroup ()
      {
      }

      // t_junctionGroup_junctionReference
      //

      t_junctionGroup_junctionReference::
      t_junctionGroup_junctionReference (const junction_type& junction)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        junction_ (junction, this)
      {
      }

      t_junctionGroup_junctionReference::
      t_junctionGroup_junctionReference (const t_junctionGroup_junctionReference& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        junction_ (x.junction_, f, this)
      {
      }

      t_junctionGroup_junctionReference::
      t_junctionGroup_junctionReference (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        junction_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void t_junctionGroup_junctionReference::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "junction" && n.namespace_ ().empty ())
          {
            this->junction_.set (junction_traits::create (i, f, this));
            continue;
          }
        }

        if (!junction_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "junction",
            "");
        }
      }

      t_junctionGroup_junctionReference* t_junctionGroup_junctionReference::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_junctionGroup_junctionReference (*this, f, c);
      }

      t_junctionGroup_junctionReference& t_junctionGroup_junctionReference::
      operator= (const t_junctionGroup_junctionReference& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->junction_ = x.junction_;
        }

        return *this;
      }

      t_junctionGroup_junctionReference::
      ~t_junctionGroup_junctionReference ()
      {
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace simulation
{
  namespace standard
  {
    namespace opendrive_schema
    {
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

