// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef DELIVERABLE_XSD_SCHEMA_OPENDRIVE_16_OBJECT_HXX
#define DELIVERABLE_XSD_SCHEMA_OPENDRIVE_16_OBJECT_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace simulation
{
  namespace standard
  {
    namespace opendrive_schema
    {
      class e_borderType;
      class e_bridgeType;
      class e_objectType;
      class e_orientation;
      class e_outlineFillType;
      class e_road_objects_object_parkingSpace_access;
      class e_sideType;
      class e_tunnelType;
      class t_road_objects;
      class t_road_objects_bridge;
      class t_road_objects_object;
      class t_road_objects_object_borders;
      class t_road_objects_object_borders_border;
      class t_road_objects_object_markings;
      class t_road_objects_object_markings_marking;
      class t_road_objects_object_markings_marking_cornerReference;
      class t_road_objects_object_material;
      class t_road_objects_object_outlines;
      class t_road_objects_object_outlines_outline;
      class t_road_objects_object_outlines_outline_cornerLocal;
      class t_road_objects_object_outlines_outline_cornerRoad;
      class t_road_objects_object_parkingSpace;
      class t_road_objects_object_repeat;
      class t_road_objects_objectReference;
      class t_road_objects_tunnel;
    }
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "opendrive_16_core.hxx"

#include "opendrive_16_lane.hxx"

namespace simulation
{
  namespace standard
  {
    namespace opendrive_schema
    {
      class e_borderType: public ::xml_schema::string
      {
        public:
        enum value
        {
          concrete,
          curb
        };

        e_borderType (value v);

        e_borderType (const char* v);

        e_borderType (const ::std::string& v);

        e_borderType (const ::xml_schema::string& v);

        e_borderType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        e_borderType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        e_borderType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        e_borderType (const e_borderType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        virtual e_borderType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        e_borderType&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_e_borderType_convert ();
        }

        protected:
        value
        _xsd_e_borderType_convert () const;

        public:
        static const char* const _xsd_e_borderType_literals_[2];
        static const value _xsd_e_borderType_indexes_[2];
      };

      class e_bridgeType: public ::xml_schema::string
      {
        public:
        enum value
        {
          concrete,
          steel,
          brick,
          wood
        };

        e_bridgeType (value v);

        e_bridgeType (const char* v);

        e_bridgeType (const ::std::string& v);

        e_bridgeType (const ::xml_schema::string& v);

        e_bridgeType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        e_bridgeType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        e_bridgeType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        e_bridgeType (const e_bridgeType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        virtual e_bridgeType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        e_bridgeType&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_e_bridgeType_convert ();
        }

        protected:
        value
        _xsd_e_bridgeType_convert () const;

        public:
        static const char* const _xsd_e_bridgeType_literals_[4];
        static const value _xsd_e_bridgeType_indexes_[4];
      };

      class e_objectType: public ::xml_schema::string
      {
        public:
        enum value
        {
          none,
          obstacle,
          car,
          pole,
          tree,
          vegetation,
          barrier,
          building,
          parkingSpace,
          patch,
          railing,
          trafficIsland,
          crosswalk,
          streetLamp,
          gantry,
          soundBarrier,
          van,
          bus,
          trailer,
          bike,
          motorbike,
          tram,
          train,
          pedestrian,
          wind,
          roadMark
        };

        e_objectType (value v);

        e_objectType (const char* v);

        e_objectType (const ::std::string& v);

        e_objectType (const ::xml_schema::string& v);

        e_objectType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        e_objectType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        e_objectType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        e_objectType (const e_objectType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        virtual e_objectType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        e_objectType&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_e_objectType_convert ();
        }

        protected:
        value
        _xsd_e_objectType_convert () const;

        public:
        static const char* const _xsd_e_objectType_literals_[26];
        static const value _xsd_e_objectType_indexes_[26];
      };

      class e_orientation: public ::xml_schema::string
      {
        public:
        enum value
        {
          cxx_,
          cxx_1,
          none
        };

        e_orientation (value v);

        e_orientation (const char* v);

        e_orientation (const ::std::string& v);

        e_orientation (const ::xml_schema::string& v);

        e_orientation (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        e_orientation (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        e_orientation (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        e_orientation (const e_orientation& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

        virtual e_orientation*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        e_orientation&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_e_orientation_convert ();
        }

        protected:
        value
        _xsd_e_orientation_convert () const;

        public:
        static const char* const _xsd_e_orientation_literals_[3];
        static const value _xsd_e_orientation_indexes_[3];
      };

      class e_outlineFillType: public ::xml_schema::string
      {
        public:
        enum value
        {
          grass,
          concrete,
          cobble,
          asphalt,
          pavement,
          gravel,
          soil
        };

        e_outlineFillType (value v);

        e_outlineFillType (const char* v);

        e_outlineFillType (const ::std::string& v);

        e_outlineFillType (const ::xml_schema::string& v);

        e_outlineFillType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

        e_outlineFillType (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

        e_outlineFillType (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

        e_outlineFillType (const e_outlineFillType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

        virtual e_outlineFillType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        e_outlineFillType&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_e_outlineFillType_convert ();
        }

        protected:
        value
        _xsd_e_outlineFillType_convert () const;

        public:
        static const char* const _xsd_e_outlineFillType_literals_[7];
        static const value _xsd_e_outlineFillType_indexes_[7];
      };

      class e_road_objects_object_parkingSpace_access: public ::xml_schema::string
      {
        public:
        enum value
        {
          all,
          car,
          women,
          handicapped,
          bus,
          truck,
          electric,
          residents
        };

        e_road_objects_object_parkingSpace_access (value v);

        e_road_objects_object_parkingSpace_access (const char* v);

        e_road_objects_object_parkingSpace_access (const ::std::string& v);

        e_road_objects_object_parkingSpace_access (const ::xml_schema::string& v);

        e_road_objects_object_parkingSpace_access (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

        e_road_objects_object_parkingSpace_access (const ::xercesc::DOMAttr& a,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

        e_road_objects_object_parkingSpace_access (const ::std::string& s,
                                                   const ::xercesc::DOMElement* e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

        e_road_objects_object_parkingSpace_access (const e_road_objects_object_parkingSpace_access& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

        virtual e_road_objects_object_parkingSpace_access*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        e_road_objects_object_parkingSpace_access&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_e_road_objects_object_parkingSpace_access_convert ();
        }

        protected:
        value
        _xsd_e_road_objects_object_parkingSpace_access_convert () const;

        public:
        static const char* const _xsd_e_road_objects_object_parkingSpace_access_literals_[8];
        static const value _xsd_e_road_objects_object_parkingSpace_access_indexes_[8];
      };

      class e_sideType: public ::xml_schema::string
      {
        public:
        enum value
        {
          left,
          right,
          front,
          rear
        };

        e_sideType (value v);

        e_sideType (const char* v);

        e_sideType (const ::std::string& v);

        e_sideType (const ::xml_schema::string& v);

        e_sideType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        e_sideType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        e_sideType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        e_sideType (const e_sideType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        virtual e_sideType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        e_sideType&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_e_sideType_convert ();
        }

        protected:
        value
        _xsd_e_sideType_convert () const;

        public:
        static const char* const _xsd_e_sideType_literals_[4];
        static const value _xsd_e_sideType_indexes_[4];
      };

      class e_tunnelType: public ::xml_schema::string
      {
        public:
        enum value
        {
          standard,
          underpass
        };

        e_tunnelType (value v);

        e_tunnelType (const char* v);

        e_tunnelType (const ::std::string& v);

        e_tunnelType (const ::xml_schema::string& v);

        e_tunnelType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        e_tunnelType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        e_tunnelType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        e_tunnelType (const e_tunnelType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        virtual e_tunnelType*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        e_tunnelType&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_e_tunnelType_convert ();
        }

        protected:
        value
        _xsd_e_tunnelType_convert () const;

        public:
        static const char* const _xsd_e_tunnelType_literals_[2];
        static const value _xsd_e_tunnelType_indexes_[2];
      };

      class t_road_objects: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // object
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object object_type;
        typedef ::xsd::cxx::tree::sequence< object_type > object_sequence;
        typedef object_sequence::iterator object_iterator;
        typedef object_sequence::const_iterator object_const_iterator;
        typedef ::xsd::cxx::tree::traits< object_type, char > object_traits;

        const object_sequence&
        object () const;

        object_sequence&
        object ();

        void
        object (const object_sequence& s);

        // objectReference
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_objectReference objectReference_type;
        typedef ::xsd::cxx::tree::sequence< objectReference_type > objectReference_sequence;
        typedef objectReference_sequence::iterator objectReference_iterator;
        typedef objectReference_sequence::const_iterator objectReference_const_iterator;
        typedef ::xsd::cxx::tree::traits< objectReference_type, char > objectReference_traits;

        const objectReference_sequence&
        objectReference () const;

        objectReference_sequence&
        objectReference ();

        void
        objectReference (const objectReference_sequence& s);

        // tunnel
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_tunnel tunnel_type;
        typedef ::xsd::cxx::tree::sequence< tunnel_type > tunnel_sequence;
        typedef tunnel_sequence::iterator tunnel_iterator;
        typedef tunnel_sequence::const_iterator tunnel_const_iterator;
        typedef ::xsd::cxx::tree::traits< tunnel_type, char > tunnel_traits;

        const tunnel_sequence&
        tunnel () const;

        tunnel_sequence&
        tunnel ();

        void
        tunnel (const tunnel_sequence& s);

        // bridge
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_bridge bridge_type;
        typedef ::xsd::cxx::tree::sequence< bridge_type > bridge_sequence;
        typedef bridge_sequence::iterator bridge_iterator;
        typedef bridge_sequence::const_iterator bridge_const_iterator;
        typedef ::xsd::cxx::tree::traits< bridge_type, char > bridge_traits;

        const bridge_sequence&
        bridge () const;

        bridge_sequence&
        bridge ();

        void
        bridge (const bridge_sequence& s);

        // include
        //
        typedef ::simulation::standard::opendrive_schema::t_include include_type;
        typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
        typedef include_sequence::iterator include_iterator;
        typedef include_sequence::const_iterator include_const_iterator;
        typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

        const include_sequence&
        include () const;

        include_sequence&
        include ();

        void
        include (const include_sequence& s);

        // userData
        //
        typedef ::simulation::standard::opendrive_schema::t_userData userData_type;
        typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
        typedef userData_sequence::iterator userData_iterator;
        typedef userData_sequence::const_iterator userData_const_iterator;
        typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

        const userData_sequence&
        userData () const;

        userData_sequence&
        userData ();

        void
        userData (const userData_sequence& s);

        // dataQuality
        //
        typedef ::simulation::standard::opendrive_schema::t_dataQuality dataQuality_type;
        typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
        typedef dataQuality_sequence::iterator dataQuality_iterator;
        typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
        typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

        const dataQuality_sequence&
        dataQuality () const;

        dataQuality_sequence&
        dataQuality ();

        void
        dataQuality (const dataQuality_sequence& s);

        // Constructors.
        //
        t_road_objects ();

        t_road_objects (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        t_road_objects (const t_road_objects& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        virtual t_road_objects*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects&
        operator= (const t_road_objects& x);

        virtual 
        ~t_road_objects ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        object_sequence object_;
        objectReference_sequence objectReference_;
        tunnel_sequence tunnel_;
        bridge_sequence bridge_;
        include_sequence include_;
        userData_sequence userData_;
        dataQuality_sequence dataQuality_;
      };

      class t_road_objects_bridge: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // validity
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_laneValidity validity_type;
        typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
        typedef validity_sequence::iterator validity_iterator;
        typedef validity_sequence::const_iterator validity_const_iterator;
        typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

        const validity_sequence&
        validity () const;

        validity_sequence&
        validity ();

        void
        validity (const validity_sequence& s);

        // include
        //
        typedef ::simulation::standard::opendrive_schema::t_include include_type;
        typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
        typedef include_sequence::iterator include_iterator;
        typedef include_sequence::const_iterator include_const_iterator;
        typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

        const include_sequence&
        include () const;

        include_sequence&
        include ();

        void
        include (const include_sequence& s);

        // userData
        //
        typedef ::simulation::standard::opendrive_schema::t_userData userData_type;
        typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
        typedef userData_sequence::iterator userData_iterator;
        typedef userData_sequence::const_iterator userData_const_iterator;
        typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

        const userData_sequence&
        userData () const;

        userData_sequence&
        userData ();

        void
        userData (const userData_sequence& s);

        // dataQuality
        //
        typedef ::simulation::standard::opendrive_schema::t_dataQuality dataQuality_type;
        typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
        typedef dataQuality_sequence::iterator dataQuality_iterator;
        typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
        typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

        const dataQuality_sequence&
        dataQuality () const;

        dataQuality_sequence&
        dataQuality ();

        void
        dataQuality (const dataQuality_sequence& s);

        // s
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero s_type;
        typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

        const s_type&
        s () const;

        s_type&
        s ();

        void
        s (const s_type& x);

        void
        s (::std::unique_ptr< s_type > p);

        // length
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero length_type;
        typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

        const length_type&
        length () const;

        length_type&
        length ();

        void
        length (const length_type& x);

        void
        length (::std::unique_ptr< length_type > p);

        // name
        //
        typedef ::xml_schema::string name_type;
        typedef ::xsd::cxx::tree::optional< name_type > name_optional;
        typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

        const name_optional&
        name () const;

        name_optional&
        name ();

        void
        name (const name_type& x);

        void
        name (const name_optional& x);

        void
        name (::std::unique_ptr< name_type > p);

        // id
        //
        typedef ::xml_schema::string id_type;
        typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

        const id_type&
        id () const;

        id_type&
        id ();

        void
        id (const id_type& x);

        void
        id (::std::unique_ptr< id_type > p);

        // type
        //
        typedef ::simulation::standard::opendrive_schema::e_bridgeType type_type;
        typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

        const type_type&
        type () const;

        type_type&
        type ();

        void
        type (const type_type& x);

        void
        type (::std::unique_ptr< type_type > p);

        // Constructors.
        //
        t_road_objects_bridge (const s_type&,
                               const length_type&,
                               const id_type&,
                               const type_type&);

        t_road_objects_bridge (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

        t_road_objects_bridge (const t_road_objects_bridge& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

        virtual t_road_objects_bridge*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_bridge&
        operator= (const t_road_objects_bridge& x);

        virtual 
        ~t_road_objects_bridge ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        validity_sequence validity_;
        include_sequence include_;
        userData_sequence userData_;
        dataQuality_sequence dataQuality_;
        ::xsd::cxx::tree::one< s_type > s_;
        ::xsd::cxx::tree::one< length_type > length_;
        name_optional name_;
        ::xsd::cxx::tree::one< id_type > id_;
        ::xsd::cxx::tree::one< type_type > type_;
      };

      class t_road_objects_object: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // repeat
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_repeat repeat_type;
        typedef ::xsd::cxx::tree::sequence< repeat_type > repeat_sequence;
        typedef repeat_sequence::iterator repeat_iterator;
        typedef repeat_sequence::const_iterator repeat_const_iterator;
        typedef ::xsd::cxx::tree::traits< repeat_type, char > repeat_traits;

        const repeat_sequence&
        repeat () const;

        repeat_sequence&
        repeat ();

        void
        repeat (const repeat_sequence& s);

        // outline
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_outlines_outline outline_type;
        typedef ::xsd::cxx::tree::optional< outline_type > outline_optional;
        typedef ::xsd::cxx::tree::traits< outline_type, char > outline_traits;

        const outline_optional&
        outline () const;

        outline_optional&
        outline ();

        void
        outline (const outline_type& x);

        void
        outline (const outline_optional& x);

        void
        outline (::std::unique_ptr< outline_type > p);

        // outlines
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_outlines outlines_type;
        typedef ::xsd::cxx::tree::optional< outlines_type > outlines_optional;
        typedef ::xsd::cxx::tree::traits< outlines_type, char > outlines_traits;

        const outlines_optional&
        outlines () const;

        outlines_optional&
        outlines ();

        void
        outlines (const outlines_type& x);

        void
        outlines (const outlines_optional& x);

        void
        outlines (::std::unique_ptr< outlines_type > p);

        // material
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_material material_type;
        typedef ::xsd::cxx::tree::sequence< material_type > material_sequence;
        typedef material_sequence::iterator material_iterator;
        typedef material_sequence::const_iterator material_const_iterator;
        typedef ::xsd::cxx::tree::traits< material_type, char > material_traits;

        const material_sequence&
        material () const;

        material_sequence&
        material ();

        void
        material (const material_sequence& s);

        // validity
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_laneValidity validity_type;
        typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
        typedef validity_sequence::iterator validity_iterator;
        typedef validity_sequence::const_iterator validity_const_iterator;
        typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

        const validity_sequence&
        validity () const;

        validity_sequence&
        validity ();

        void
        validity (const validity_sequence& s);

        // parkingSpace
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_parkingSpace parkingSpace_type;
        typedef ::xsd::cxx::tree::optional< parkingSpace_type > parkingSpace_optional;
        typedef ::xsd::cxx::tree::traits< parkingSpace_type, char > parkingSpace_traits;

        const parkingSpace_optional&
        parkingSpace () const;

        parkingSpace_optional&
        parkingSpace ();

        void
        parkingSpace (const parkingSpace_type& x);

        void
        parkingSpace (const parkingSpace_optional& x);

        void
        parkingSpace (::std::unique_ptr< parkingSpace_type > p);

        // markings
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_markings markings_type;
        typedef ::xsd::cxx::tree::optional< markings_type > markings_optional;
        typedef ::xsd::cxx::tree::traits< markings_type, char > markings_traits;

        const markings_optional&
        markings () const;

        markings_optional&
        markings ();

        void
        markings (const markings_type& x);

        void
        markings (const markings_optional& x);

        void
        markings (::std::unique_ptr< markings_type > p);

        // borders
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_borders borders_type;
        typedef ::xsd::cxx::tree::optional< borders_type > borders_optional;
        typedef ::xsd::cxx::tree::traits< borders_type, char > borders_traits;

        const borders_optional&
        borders () const;

        borders_optional&
        borders ();

        void
        borders (const borders_type& x);

        void
        borders (const borders_optional& x);

        void
        borders (::std::unique_ptr< borders_type > p);

        // include
        //
        typedef ::simulation::standard::opendrive_schema::t_include include_type;
        typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
        typedef include_sequence::iterator include_iterator;
        typedef include_sequence::const_iterator include_const_iterator;
        typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

        const include_sequence&
        include () const;

        include_sequence&
        include ();

        void
        include (const include_sequence& s);

        // userData
        //
        typedef ::simulation::standard::opendrive_schema::t_userData userData_type;
        typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
        typedef userData_sequence::iterator userData_iterator;
        typedef userData_sequence::const_iterator userData_const_iterator;
        typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

        const userData_sequence&
        userData () const;

        userData_sequence&
        userData ();

        void
        userData (const userData_sequence& s);

        // dataQuality
        //
        typedef ::simulation::standard::opendrive_schema::t_dataQuality dataQuality_type;
        typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
        typedef dataQuality_sequence::iterator dataQuality_iterator;
        typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
        typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

        const dataQuality_sequence&
        dataQuality () const;

        dataQuality_sequence&
        dataQuality ();

        void
        dataQuality (const dataQuality_sequence& s);

        // t
        //
        typedef ::xml_schema::double_ t_type;
        typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

        const t_type&
        t () const;

        t_type&
        t ();

        void
        t (const t_type& x);

        // zOffset
        //
        typedef ::xml_schema::double_ zOffset_type;
        typedef ::xsd::cxx::tree::traits< zOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffset_traits;

        const zOffset_type&
        zOffset () const;

        zOffset_type&
        zOffset ();

        void
        zOffset (const zOffset_type& x);

        // type
        //
        typedef ::simulation::standard::opendrive_schema::e_objectType type_type;
        typedef ::xsd::cxx::tree::optional< type_type > type_optional;
        typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

        const type_optional&
        type () const;

        type_optional&
        type ();

        void
        type (const type_type& x);

        void
        type (const type_optional& x);

        void
        type (::std::unique_ptr< type_type > p);

        // validLength
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero validLength_type;
        typedef ::xsd::cxx::tree::optional< validLength_type > validLength_optional;
        typedef ::xsd::cxx::tree::traits< validLength_type, char > validLength_traits;

        const validLength_optional&
        validLength () const;

        validLength_optional&
        validLength ();

        void
        validLength (const validLength_type& x);

        void
        validLength (const validLength_optional& x);

        void
        validLength (::std::unique_ptr< validLength_type > p);

        // orientation
        //
        typedef ::simulation::standard::opendrive_schema::e_orientation orientation_type;
        typedef ::xsd::cxx::tree::optional< orientation_type > orientation_optional;
        typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

        const orientation_optional&
        orientation () const;

        orientation_optional&
        orientation ();

        void
        orientation (const orientation_type& x);

        void
        orientation (const orientation_optional& x);

        void
        orientation (::std::unique_ptr< orientation_type > p);

        // subtype
        //
        typedef ::xml_schema::string subtype_type;
        typedef ::xsd::cxx::tree::optional< subtype_type > subtype_optional;
        typedef ::xsd::cxx::tree::traits< subtype_type, char > subtype_traits;

        const subtype_optional&
        subtype () const;

        subtype_optional&
        subtype ();

        void
        subtype (const subtype_type& x);

        void
        subtype (const subtype_optional& x);

        void
        subtype (::std::unique_ptr< subtype_type > p);

        // dynamic
        //
        typedef ::simulation::standard::opendrive_schema::t_yesNo dynamic_type;
        typedef ::xsd::cxx::tree::optional< dynamic_type > dynamic_optional;
        typedef ::xsd::cxx::tree::traits< dynamic_type, char > dynamic_traits;

        const dynamic_optional&
        dynamic () const;

        dynamic_optional&
        dynamic ();

        void
        dynamic (const dynamic_type& x);

        void
        dynamic (const dynamic_optional& x);

        void
        dynamic (::std::unique_ptr< dynamic_type > p);

        // hdg
        //
        typedef ::xml_schema::double_ hdg_type;
        typedef ::xsd::cxx::tree::optional< hdg_type > hdg_optional;
        typedef ::xsd::cxx::tree::traits< hdg_type, char, ::xsd::cxx::tree::schema_type::double_ > hdg_traits;

        const hdg_optional&
        hdg () const;

        hdg_optional&
        hdg ();

        void
        hdg (const hdg_type& x);

        void
        hdg (const hdg_optional& x);

        // name
        //
        typedef ::xml_schema::string name_type;
        typedef ::xsd::cxx::tree::optional< name_type > name_optional;
        typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

        const name_optional&
        name () const;

        name_optional&
        name ();

        void
        name (const name_type& x);

        void
        name (const name_optional& x);

        void
        name (::std::unique_ptr< name_type > p);

        // pitch
        //
        typedef ::xml_schema::double_ pitch_type;
        typedef ::xsd::cxx::tree::optional< pitch_type > pitch_optional;
        typedef ::xsd::cxx::tree::traits< pitch_type, char, ::xsd::cxx::tree::schema_type::double_ > pitch_traits;

        const pitch_optional&
        pitch () const;

        pitch_optional&
        pitch ();

        void
        pitch (const pitch_type& x);

        void
        pitch (const pitch_optional& x);

        // id
        //
        typedef ::xml_schema::string id_type;
        typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

        const id_type&
        id () const;

        id_type&
        id ();

        void
        id (const id_type& x);

        void
        id (::std::unique_ptr< id_type > p);

        // roll
        //
        typedef ::xml_schema::double_ roll_type;
        typedef ::xsd::cxx::tree::optional< roll_type > roll_optional;
        typedef ::xsd::cxx::tree::traits< roll_type, char, ::xsd::cxx::tree::schema_type::double_ > roll_traits;

        const roll_optional&
        roll () const;

        roll_optional&
        roll ();

        void
        roll (const roll_type& x);

        void
        roll (const roll_optional& x);

        // height
        //
        typedef ::xml_schema::double_ height_type;
        typedef ::xsd::cxx::tree::optional< height_type > height_optional;
        typedef ::xsd::cxx::tree::traits< height_type, char, ::xsd::cxx::tree::schema_type::double_ > height_traits;

        const height_optional&
        height () const;

        height_optional&
        height ();

        void
        height (const height_type& x);

        void
        height (const height_optional& x);

        // s
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero s_type;
        typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

        const s_type&
        s () const;

        s_type&
        s ();

        void
        s (const s_type& x);

        void
        s (::std::unique_ptr< s_type > p);

        // length
        //
        typedef ::xml_schema::double_ length_type;
        typedef ::xsd::cxx::tree::optional< length_type > length_optional;
        typedef ::xsd::cxx::tree::traits< length_type, char, ::xsd::cxx::tree::schema_type::double_ > length_traits;

        const length_optional&
        length () const;

        length_optional&
        length ();

        void
        length (const length_type& x);

        void
        length (const length_optional& x);

        // width
        //
        typedef ::xml_schema::double_ width_type;
        typedef ::xsd::cxx::tree::optional< width_type > width_optional;
        typedef ::xsd::cxx::tree::traits< width_type, char, ::xsd::cxx::tree::schema_type::double_ > width_traits;

        const width_optional&
        width () const;

        width_optional&
        width ();

        void
        width (const width_type& x);

        void
        width (const width_optional& x);

        // radius
        //
        typedef ::xml_schema::double_ radius_type;
        typedef ::xsd::cxx::tree::optional< radius_type > radius_optional;
        typedef ::xsd::cxx::tree::traits< radius_type, char, ::xsd::cxx::tree::schema_type::double_ > radius_traits;

        const radius_optional&
        radius () const;

        radius_optional&
        radius ();

        void
        radius (const radius_type& x);

        void
        radius (const radius_optional& x);

        // Constructors.
        //
        t_road_objects_object (const t_type&,
                               const zOffset_type&,
                               const id_type&,
                               const s_type&);

        t_road_objects_object (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

        t_road_objects_object (const t_road_objects_object& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

        virtual t_road_objects_object*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_object&
        operator= (const t_road_objects_object& x);

        virtual 
        ~t_road_objects_object ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        repeat_sequence repeat_;
        outline_optional outline_;
        outlines_optional outlines_;
        material_sequence material_;
        validity_sequence validity_;
        parkingSpace_optional parkingSpace_;
        markings_optional markings_;
        borders_optional borders_;
        include_sequence include_;
        userData_sequence userData_;
        dataQuality_sequence dataQuality_;
        ::xsd::cxx::tree::one< t_type > t_;
        ::xsd::cxx::tree::one< zOffset_type > zOffset_;
        type_optional type_;
        validLength_optional validLength_;
        orientation_optional orientation_;
        subtype_optional subtype_;
        dynamic_optional dynamic_;
        hdg_optional hdg_;
        name_optional name_;
        pitch_optional pitch_;
        ::xsd::cxx::tree::one< id_type > id_;
        roll_optional roll_;
        height_optional height_;
        ::xsd::cxx::tree::one< s_type > s_;
        length_optional length_;
        width_optional width_;
        radius_optional radius_;
      };

      class t_road_objects_object_borders: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // border
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_borders_border border_type;
        typedef ::xsd::cxx::tree::sequence< border_type > border_sequence;
        typedef border_sequence::iterator border_iterator;
        typedef border_sequence::const_iterator border_const_iterator;
        typedef ::xsd::cxx::tree::traits< border_type, char > border_traits;

        const border_sequence&
        border () const;

        border_sequence&
        border ();

        void
        border (const border_sequence& s);

        // include
        //
        typedef ::simulation::standard::opendrive_schema::t_include include_type;
        typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
        typedef include_sequence::iterator include_iterator;
        typedef include_sequence::const_iterator include_const_iterator;
        typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

        const include_sequence&
        include () const;

        include_sequence&
        include ();

        void
        include (const include_sequence& s);

        // userData
        //
        typedef ::simulation::standard::opendrive_schema::t_userData userData_type;
        typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
        typedef userData_sequence::iterator userData_iterator;
        typedef userData_sequence::const_iterator userData_const_iterator;
        typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

        const userData_sequence&
        userData () const;

        userData_sequence&
        userData ();

        void
        userData (const userData_sequence& s);

        // dataQuality
        //
        typedef ::simulation::standard::opendrive_schema::t_dataQuality dataQuality_type;
        typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
        typedef dataQuality_sequence::iterator dataQuality_iterator;
        typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
        typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

        const dataQuality_sequence&
        dataQuality () const;

        dataQuality_sequence&
        dataQuality ();

        void
        dataQuality (const dataQuality_sequence& s);

        // Constructors.
        //
        t_road_objects_object_borders ();

        t_road_objects_object_borders (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

        t_road_objects_object_borders (const t_road_objects_object_borders& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

        virtual t_road_objects_object_borders*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_object_borders&
        operator= (const t_road_objects_object_borders& x);

        virtual 
        ~t_road_objects_object_borders ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        border_sequence border_;
        include_sequence include_;
        userData_sequence userData_;
        dataQuality_sequence dataQuality_;
      };

      class t_road_objects_object_borders_border: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // cornerReference
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_markings_marking_cornerReference cornerReference_type;
        typedef ::xsd::cxx::tree::sequence< cornerReference_type > cornerReference_sequence;
        typedef cornerReference_sequence::iterator cornerReference_iterator;
        typedef cornerReference_sequence::const_iterator cornerReference_const_iterator;
        typedef ::xsd::cxx::tree::traits< cornerReference_type, char > cornerReference_traits;

        const cornerReference_sequence&
        cornerReference () const;

        cornerReference_sequence&
        cornerReference ();

        void
        cornerReference (const cornerReference_sequence& s);

        // include
        //
        typedef ::simulation::standard::opendrive_schema::t_include include_type;
        typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
        typedef include_sequence::iterator include_iterator;
        typedef include_sequence::const_iterator include_const_iterator;
        typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

        const include_sequence&
        include () const;

        include_sequence&
        include ();

        void
        include (const include_sequence& s);

        // userData
        //
        typedef ::simulation::standard::opendrive_schema::t_userData userData_type;
        typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
        typedef userData_sequence::iterator userData_iterator;
        typedef userData_sequence::const_iterator userData_const_iterator;
        typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

        const userData_sequence&
        userData () const;

        userData_sequence&
        userData ();

        void
        userData (const userData_sequence& s);

        // dataQuality
        //
        typedef ::simulation::standard::opendrive_schema::t_dataQuality dataQuality_type;
        typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
        typedef dataQuality_sequence::iterator dataQuality_iterator;
        typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
        typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

        const dataQuality_sequence&
        dataQuality () const;

        dataQuality_sequence&
        dataQuality ();

        void
        dataQuality (const dataQuality_sequence& s);

        // width
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero width_type;
        typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

        const width_type&
        width () const;

        width_type&
        width ();

        void
        width (const width_type& x);

        void
        width (::std::unique_ptr< width_type > p);

        // type
        //
        typedef ::simulation::standard::opendrive_schema::e_borderType type_type;
        typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

        const type_type&
        type () const;

        type_type&
        type ();

        void
        type (const type_type& x);

        void
        type (::std::unique_ptr< type_type > p);

        // outlineId
        //
        typedef ::xml_schema::non_negative_integer outlineId_type;
        typedef ::xsd::cxx::tree::traits< outlineId_type, char > outlineId_traits;

        const outlineId_type&
        outlineId () const;

        outlineId_type&
        outlineId ();

        void
        outlineId (const outlineId_type& x);

        // useCompleteOutline
        //
        typedef ::simulation::standard::opendrive_schema::t_bool useCompleteOutline_type;
        typedef ::xsd::cxx::tree::optional< useCompleteOutline_type > useCompleteOutline_optional;
        typedef ::xsd::cxx::tree::traits< useCompleteOutline_type, char > useCompleteOutline_traits;

        const useCompleteOutline_optional&
        useCompleteOutline () const;

        useCompleteOutline_optional&
        useCompleteOutline ();

        void
        useCompleteOutline (const useCompleteOutline_type& x);

        void
        useCompleteOutline (const useCompleteOutline_optional& x);

        void
        useCompleteOutline (::std::unique_ptr< useCompleteOutline_type > p);

        // Constructors.
        //
        t_road_objects_object_borders_border (const width_type&,
                                              const type_type&,
                                              const outlineId_type&);

        t_road_objects_object_borders_border (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

        t_road_objects_object_borders_border (const t_road_objects_object_borders_border& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

        virtual t_road_objects_object_borders_border*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_object_borders_border&
        operator= (const t_road_objects_object_borders_border& x);

        virtual 
        ~t_road_objects_object_borders_border ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        cornerReference_sequence cornerReference_;
        include_sequence include_;
        userData_sequence userData_;
        dataQuality_sequence dataQuality_;
        ::xsd::cxx::tree::one< width_type > width_;
        ::xsd::cxx::tree::one< type_type > type_;
        ::xsd::cxx::tree::one< outlineId_type > outlineId_;
        useCompleteOutline_optional useCompleteOutline_;
      };

      class t_road_objects_object_markings: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // marking
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_markings_marking marking_type;
        typedef ::xsd::cxx::tree::sequence< marking_type > marking_sequence;
        typedef marking_sequence::iterator marking_iterator;
        typedef marking_sequence::const_iterator marking_const_iterator;
        typedef ::xsd::cxx::tree::traits< marking_type, char > marking_traits;

        const marking_sequence&
        marking () const;

        marking_sequence&
        marking ();

        void
        marking (const marking_sequence& s);

        // include
        //
        typedef ::simulation::standard::opendrive_schema::t_include include_type;
        typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
        typedef include_sequence::iterator include_iterator;
        typedef include_sequence::const_iterator include_const_iterator;
        typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

        const include_sequence&
        include () const;

        include_sequence&
        include ();

        void
        include (const include_sequence& s);

        // userData
        //
        typedef ::simulation::standard::opendrive_schema::t_userData userData_type;
        typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
        typedef userData_sequence::iterator userData_iterator;
        typedef userData_sequence::const_iterator userData_const_iterator;
        typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

        const userData_sequence&
        userData () const;

        userData_sequence&
        userData ();

        void
        userData (const userData_sequence& s);

        // dataQuality
        //
        typedef ::simulation::standard::opendrive_schema::t_dataQuality dataQuality_type;
        typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
        typedef dataQuality_sequence::iterator dataQuality_iterator;
        typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
        typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

        const dataQuality_sequence&
        dataQuality () const;

        dataQuality_sequence&
        dataQuality ();

        void
        dataQuality (const dataQuality_sequence& s);

        // Constructors.
        //
        t_road_objects_object_markings ();

        t_road_objects_object_markings (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

        t_road_objects_object_markings (const t_road_objects_object_markings& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

        virtual t_road_objects_object_markings*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_object_markings&
        operator= (const t_road_objects_object_markings& x);

        virtual 
        ~t_road_objects_object_markings ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        marking_sequence marking_;
        include_sequence include_;
        userData_sequence userData_;
        dataQuality_sequence dataQuality_;
      };

      class t_road_objects_object_markings_marking: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // cornerReference
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_markings_marking_cornerReference cornerReference_type;
        typedef ::xsd::cxx::tree::sequence< cornerReference_type > cornerReference_sequence;
        typedef cornerReference_sequence::iterator cornerReference_iterator;
        typedef cornerReference_sequence::const_iterator cornerReference_const_iterator;
        typedef ::xsd::cxx::tree::traits< cornerReference_type, char > cornerReference_traits;

        const cornerReference_sequence&
        cornerReference () const;

        cornerReference_sequence&
        cornerReference ();

        void
        cornerReference (const cornerReference_sequence& s);

        // include
        //
        typedef ::simulation::standard::opendrive_schema::t_include include_type;
        typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
        typedef include_sequence::iterator include_iterator;
        typedef include_sequence::const_iterator include_const_iterator;
        typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

        const include_sequence&
        include () const;

        include_sequence&
        include ();

        void
        include (const include_sequence& s);

        // userData
        //
        typedef ::simulation::standard::opendrive_schema::t_userData userData_type;
        typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
        typedef userData_sequence::iterator userData_iterator;
        typedef userData_sequence::const_iterator userData_const_iterator;
        typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

        const userData_sequence&
        userData () const;

        userData_sequence&
        userData ();

        void
        userData (const userData_sequence& s);

        // dataQuality
        //
        typedef ::simulation::standard::opendrive_schema::t_dataQuality dataQuality_type;
        typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
        typedef dataQuality_sequence::iterator dataQuality_iterator;
        typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
        typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

        const dataQuality_sequence&
        dataQuality () const;

        dataQuality_sequence&
        dataQuality ();

        void
        dataQuality (const dataQuality_sequence& s);

        // side
        //
        typedef ::simulation::standard::opendrive_schema::e_sideType side_type;
        typedef ::xsd::cxx::tree::optional< side_type > side_optional;
        typedef ::xsd::cxx::tree::traits< side_type, char > side_traits;

        const side_optional&
        side () const;

        side_optional&
        side ();

        void
        side (const side_type& x);

        void
        side (const side_optional& x);

        void
        side (::std::unique_ptr< side_type > p);

        // weight
        //
        typedef ::simulation::standard::opendrive_schema::e_roadMarkWeight weight_type;
        typedef ::xsd::cxx::tree::optional< weight_type > weight_optional;
        typedef ::xsd::cxx::tree::traits< weight_type, char > weight_traits;

        const weight_optional&
        weight () const;

        weight_optional&
        weight ();

        void
        weight (const weight_type& x);

        void
        weight (const weight_optional& x);

        void
        weight (::std::unique_ptr< weight_type > p);

        // width
        //
        typedef ::xml_schema::string width_type;
        typedef ::xsd::cxx::tree::optional< width_type > width_optional;
        typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

        const width_optional&
        width () const;

        width_optional&
        width ();

        void
        width (const width_type& x);

        void
        width (const width_optional& x);

        void
        width (::std::unique_ptr< width_type > p);

        // color
        //
        typedef ::simulation::standard::opendrive_schema::e_roadMarkColor color_type;
        typedef ::xsd::cxx::tree::traits< color_type, char > color_traits;

        const color_type&
        color () const;

        color_type&
        color ();

        void
        color (const color_type& x);

        void
        color (::std::unique_ptr< color_type > p);

        // zOffset
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero zOffset_type;
        typedef ::xsd::cxx::tree::optional< zOffset_type > zOffset_optional;
        typedef ::xsd::cxx::tree::traits< zOffset_type, char > zOffset_traits;

        const zOffset_optional&
        zOffset () const;

        zOffset_optional&
        zOffset ();

        void
        zOffset (const zOffset_type& x);

        void
        zOffset (const zOffset_optional& x);

        void
        zOffset (::std::unique_ptr< zOffset_type > p);

        // spaceLength
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero spaceLength_type;
        typedef ::xsd::cxx::tree::traits< spaceLength_type, char > spaceLength_traits;

        const spaceLength_type&
        spaceLength () const;

        spaceLength_type&
        spaceLength ();

        void
        spaceLength (const spaceLength_type& x);

        void
        spaceLength (::std::unique_ptr< spaceLength_type > p);

        // lineLength
        //
        typedef ::xml_schema::string lineLength_type;
        typedef ::xsd::cxx::tree::traits< lineLength_type, char > lineLength_traits;

        const lineLength_type&
        lineLength () const;

        lineLength_type&
        lineLength ();

        void
        lineLength (const lineLength_type& x);

        void
        lineLength (::std::unique_ptr< lineLength_type > p);

        // startOffset
        //
        typedef ::xml_schema::double_ startOffset_type;
        typedef ::xsd::cxx::tree::traits< startOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > startOffset_traits;

        const startOffset_type&
        startOffset () const;

        startOffset_type&
        startOffset ();

        void
        startOffset (const startOffset_type& x);

        // stopOffset
        //
        typedef ::xml_schema::double_ stopOffset_type;
        typedef ::xsd::cxx::tree::traits< stopOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > stopOffset_traits;

        const stopOffset_type&
        stopOffset () const;

        stopOffset_type&
        stopOffset ();

        void
        stopOffset (const stopOffset_type& x);

        // Constructors.
        //
        t_road_objects_object_markings_marking (const color_type&,
                                                const spaceLength_type&,
                                                const lineLength_type&,
                                                const startOffset_type&,
                                                const stopOffset_type&);

        t_road_objects_object_markings_marking (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

        t_road_objects_object_markings_marking (const t_road_objects_object_markings_marking& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

        virtual t_road_objects_object_markings_marking*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_object_markings_marking&
        operator= (const t_road_objects_object_markings_marking& x);

        virtual 
        ~t_road_objects_object_markings_marking ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        cornerReference_sequence cornerReference_;
        include_sequence include_;
        userData_sequence userData_;
        dataQuality_sequence dataQuality_;
        side_optional side_;
        weight_optional weight_;
        width_optional width_;
        ::xsd::cxx::tree::one< color_type > color_;
        zOffset_optional zOffset_;
        ::xsd::cxx::tree::one< spaceLength_type > spaceLength_;
        ::xsd::cxx::tree::one< lineLength_type > lineLength_;
        ::xsd::cxx::tree::one< startOffset_type > startOffset_;
        ::xsd::cxx::tree::one< stopOffset_type > stopOffset_;
      };

      class t_road_objects_object_markings_marking_cornerReference: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // id
        //
        typedef ::xml_schema::non_negative_integer id_type;
        typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

        const id_type&
        id () const;

        id_type&
        id ();

        void
        id (const id_type& x);

        // Constructors.
        //
        t_road_objects_object_markings_marking_cornerReference (const id_type&);

        t_road_objects_object_markings_marking_cornerReference (const ::xercesc::DOMElement& e,
                                                                ::xml_schema::flags f = 0,
                                                                ::xml_schema::container* c = 0);

        t_road_objects_object_markings_marking_cornerReference (const t_road_objects_object_markings_marking_cornerReference& x,
                                                                ::xml_schema::flags f = 0,
                                                                ::xml_schema::container* c = 0);

        virtual t_road_objects_object_markings_marking_cornerReference*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_object_markings_marking_cornerReference&
        operator= (const t_road_objects_object_markings_marking_cornerReference& x);

        virtual 
        ~t_road_objects_object_markings_marking_cornerReference ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< id_type > id_;
      };

      class t_road_objects_object_material: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // surface
        //
        typedef ::xml_schema::string surface_type;
        typedef ::xsd::cxx::tree::optional< surface_type > surface_optional;
        typedef ::xsd::cxx::tree::traits< surface_type, char > surface_traits;

        const surface_optional&
        surface () const;

        surface_optional&
        surface ();

        void
        surface (const surface_type& x);

        void
        surface (const surface_optional& x);

        void
        surface (::std::unique_ptr< surface_type > p);

        // friction
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero friction_type;
        typedef ::xsd::cxx::tree::optional< friction_type > friction_optional;
        typedef ::xsd::cxx::tree::traits< friction_type, char > friction_traits;

        const friction_optional&
        friction () const;

        friction_optional&
        friction ();

        void
        friction (const friction_type& x);

        void
        friction (const friction_optional& x);

        void
        friction (::std::unique_ptr< friction_type > p);

        // roughness
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero roughness_type;
        typedef ::xsd::cxx::tree::optional< roughness_type > roughness_optional;
        typedef ::xsd::cxx::tree::traits< roughness_type, char > roughness_traits;

        const roughness_optional&
        roughness () const;

        roughness_optional&
        roughness ();

        void
        roughness (const roughness_type& x);

        void
        roughness (const roughness_optional& x);

        void
        roughness (::std::unique_ptr< roughness_type > p);

        // Constructors.
        //
        t_road_objects_object_material ();

        t_road_objects_object_material (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

        t_road_objects_object_material (const t_road_objects_object_material& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

        virtual t_road_objects_object_material*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_object_material&
        operator= (const t_road_objects_object_material& x);

        virtual 
        ~t_road_objects_object_material ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        surface_optional surface_;
        friction_optional friction_;
        roughness_optional roughness_;
      };

      class t_road_objects_object_outlines: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // outline
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_outlines_outline outline_type;
        typedef ::xsd::cxx::tree::sequence< outline_type > outline_sequence;
        typedef outline_sequence::iterator outline_iterator;
        typedef outline_sequence::const_iterator outline_const_iterator;
        typedef ::xsd::cxx::tree::traits< outline_type, char > outline_traits;

        const outline_sequence&
        outline () const;

        outline_sequence&
        outline ();

        void
        outline (const outline_sequence& s);

        // include
        //
        typedef ::simulation::standard::opendrive_schema::t_include include_type;
        typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
        typedef include_sequence::iterator include_iterator;
        typedef include_sequence::const_iterator include_const_iterator;
        typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

        const include_sequence&
        include () const;

        include_sequence&
        include ();

        void
        include (const include_sequence& s);

        // userData
        //
        typedef ::simulation::standard::opendrive_schema::t_userData userData_type;
        typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
        typedef userData_sequence::iterator userData_iterator;
        typedef userData_sequence::const_iterator userData_const_iterator;
        typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

        const userData_sequence&
        userData () const;

        userData_sequence&
        userData ();

        void
        userData (const userData_sequence& s);

        // dataQuality
        //
        typedef ::simulation::standard::opendrive_schema::t_dataQuality dataQuality_type;
        typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
        typedef dataQuality_sequence::iterator dataQuality_iterator;
        typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
        typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

        const dataQuality_sequence&
        dataQuality () const;

        dataQuality_sequence&
        dataQuality ();

        void
        dataQuality (const dataQuality_sequence& s);

        // Constructors.
        //
        t_road_objects_object_outlines ();

        t_road_objects_object_outlines (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

        t_road_objects_object_outlines (const t_road_objects_object_outlines& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

        virtual t_road_objects_object_outlines*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_object_outlines&
        operator= (const t_road_objects_object_outlines& x);

        virtual 
        ~t_road_objects_object_outlines ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        outline_sequence outline_;
        include_sequence include_;
        userData_sequence userData_;
        dataQuality_sequence dataQuality_;
      };

      class t_road_objects_object_outlines_outline: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // cornerRoad
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_outlines_outline_cornerRoad cornerRoad_type;
        typedef ::xsd::cxx::tree::sequence< cornerRoad_type > cornerRoad_sequence;
        typedef cornerRoad_sequence::iterator cornerRoad_iterator;
        typedef cornerRoad_sequence::const_iterator cornerRoad_const_iterator;
        typedef ::xsd::cxx::tree::traits< cornerRoad_type, char > cornerRoad_traits;

        const cornerRoad_sequence&
        cornerRoad () const;

        cornerRoad_sequence&
        cornerRoad ();

        void
        cornerRoad (const cornerRoad_sequence& s);

        // cornerLocal
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_outlines_outline_cornerLocal cornerLocal_type;
        typedef ::xsd::cxx::tree::sequence< cornerLocal_type > cornerLocal_sequence;
        typedef cornerLocal_sequence::iterator cornerLocal_iterator;
        typedef cornerLocal_sequence::const_iterator cornerLocal_const_iterator;
        typedef ::xsd::cxx::tree::traits< cornerLocal_type, char > cornerLocal_traits;

        const cornerLocal_sequence&
        cornerLocal () const;

        cornerLocal_sequence&
        cornerLocal ();

        void
        cornerLocal (const cornerLocal_sequence& s);

        // include
        //
        typedef ::simulation::standard::opendrive_schema::t_include include_type;
        typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
        typedef include_sequence::iterator include_iterator;
        typedef include_sequence::const_iterator include_const_iterator;
        typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

        const include_sequence&
        include () const;

        include_sequence&
        include ();

        void
        include (const include_sequence& s);

        // userData
        //
        typedef ::simulation::standard::opendrive_schema::t_userData userData_type;
        typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
        typedef userData_sequence::iterator userData_iterator;
        typedef userData_sequence::const_iterator userData_const_iterator;
        typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

        const userData_sequence&
        userData () const;

        userData_sequence&
        userData ();

        void
        userData (const userData_sequence& s);

        // dataQuality
        //
        typedef ::simulation::standard::opendrive_schema::t_dataQuality dataQuality_type;
        typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
        typedef dataQuality_sequence::iterator dataQuality_iterator;
        typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
        typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

        const dataQuality_sequence&
        dataQuality () const;

        dataQuality_sequence&
        dataQuality ();

        void
        dataQuality (const dataQuality_sequence& s);

        // id
        //
        typedef ::xml_schema::non_negative_integer id_type;
        typedef ::xsd::cxx::tree::optional< id_type > id_optional;
        typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

        const id_optional&
        id () const;

        id_optional&
        id ();

        void
        id (const id_type& x);

        void
        id (const id_optional& x);

        // fillType
        //
        typedef ::simulation::standard::opendrive_schema::e_outlineFillType fillType_type;
        typedef ::xsd::cxx::tree::optional< fillType_type > fillType_optional;
        typedef ::xsd::cxx::tree::traits< fillType_type, char > fillType_traits;

        const fillType_optional&
        fillType () const;

        fillType_optional&
        fillType ();

        void
        fillType (const fillType_type& x);

        void
        fillType (const fillType_optional& x);

        void
        fillType (::std::unique_ptr< fillType_type > p);

        // outer
        //
        typedef ::simulation::standard::opendrive_schema::t_bool outer_type;
        typedef ::xsd::cxx::tree::optional< outer_type > outer_optional;
        typedef ::xsd::cxx::tree::traits< outer_type, char > outer_traits;

        const outer_optional&
        outer () const;

        outer_optional&
        outer ();

        void
        outer (const outer_type& x);

        void
        outer (const outer_optional& x);

        void
        outer (::std::unique_ptr< outer_type > p);

        // closed
        //
        typedef ::simulation::standard::opendrive_schema::t_bool closed_type;
        typedef ::xsd::cxx::tree::optional< closed_type > closed_optional;
        typedef ::xsd::cxx::tree::traits< closed_type, char > closed_traits;

        const closed_optional&
        closed () const;

        closed_optional&
        closed ();

        void
        closed (const closed_type& x);

        void
        closed (const closed_optional& x);

        void
        closed (::std::unique_ptr< closed_type > p);

        // laneType
        //
        typedef ::simulation::standard::opendrive_schema::e_laneType laneType_type;
        typedef ::xsd::cxx::tree::optional< laneType_type > laneType_optional;
        typedef ::xsd::cxx::tree::traits< laneType_type, char > laneType_traits;

        const laneType_optional&
        laneType () const;

        laneType_optional&
        laneType ();

        void
        laneType (const laneType_type& x);

        void
        laneType (const laneType_optional& x);

        void
        laneType (::std::unique_ptr< laneType_type > p);

        // Constructors.
        //
        t_road_objects_object_outlines_outline ();

        t_road_objects_object_outlines_outline (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

        t_road_objects_object_outlines_outline (const t_road_objects_object_outlines_outline& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

        virtual t_road_objects_object_outlines_outline*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_object_outlines_outline&
        operator= (const t_road_objects_object_outlines_outline& x);

        virtual 
        ~t_road_objects_object_outlines_outline ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        cornerRoad_sequence cornerRoad_;
        cornerLocal_sequence cornerLocal_;
        include_sequence include_;
        userData_sequence userData_;
        dataQuality_sequence dataQuality_;
        id_optional id_;
        fillType_optional fillType_;
        outer_optional outer_;
        closed_optional closed_;
        laneType_optional laneType_;
      };

      class t_road_objects_object_outlines_outline_cornerLocal: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // u
        //
        typedef ::xml_schema::double_ u_type;
        typedef ::xsd::cxx::tree::traits< u_type, char, ::xsd::cxx::tree::schema_type::double_ > u_traits;

        const u_type&
        u () const;

        u_type&
        u ();

        void
        u (const u_type& x);

        // v
        //
        typedef ::xml_schema::double_ v_type;
        typedef ::xsd::cxx::tree::traits< v_type, char, ::xsd::cxx::tree::schema_type::double_ > v_traits;

        const v_type&
        v () const;

        v_type&
        v ();

        void
        v (const v_type& x);

        // z
        //
        typedef ::xml_schema::double_ z_type;
        typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

        const z_type&
        z () const;

        z_type&
        z ();

        void
        z (const z_type& x);

        // height
        //
        typedef ::xml_schema::double_ height_type;
        typedef ::xsd::cxx::tree::traits< height_type, char, ::xsd::cxx::tree::schema_type::double_ > height_traits;

        const height_type&
        height () const;

        height_type&
        height ();

        void
        height (const height_type& x);

        // id
        //
        typedef ::xml_schema::non_negative_integer id_type;
        typedef ::xsd::cxx::tree::optional< id_type > id_optional;
        typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

        const id_optional&
        id () const;

        id_optional&
        id ();

        void
        id (const id_type& x);

        void
        id (const id_optional& x);

        // Constructors.
        //
        t_road_objects_object_outlines_outline_cornerLocal (const u_type&,
                                                            const v_type&,
                                                            const z_type&,
                                                            const height_type&);

        t_road_objects_object_outlines_outline_cornerLocal (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

        t_road_objects_object_outlines_outline_cornerLocal (const t_road_objects_object_outlines_outline_cornerLocal& x,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

        virtual t_road_objects_object_outlines_outline_cornerLocal*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_object_outlines_outline_cornerLocal&
        operator= (const t_road_objects_object_outlines_outline_cornerLocal& x);

        virtual 
        ~t_road_objects_object_outlines_outline_cornerLocal ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< u_type > u_;
        ::xsd::cxx::tree::one< v_type > v_;
        ::xsd::cxx::tree::one< z_type > z_;
        ::xsd::cxx::tree::one< height_type > height_;
        id_optional id_;
      };

      class t_road_objects_object_outlines_outline_cornerRoad: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // s
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero s_type;
        typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

        const s_type&
        s () const;

        s_type&
        s ();

        void
        s (const s_type& x);

        void
        s (::std::unique_ptr< s_type > p);

        // t
        //
        typedef ::xml_schema::double_ t_type;
        typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

        const t_type&
        t () const;

        t_type&
        t ();

        void
        t (const t_type& x);

        // dz
        //
        typedef ::xml_schema::double_ dz_type;
        typedef ::xsd::cxx::tree::traits< dz_type, char, ::xsd::cxx::tree::schema_type::double_ > dz_traits;

        const dz_type&
        dz () const;

        dz_type&
        dz ();

        void
        dz (const dz_type& x);

        // height
        //
        typedef ::xml_schema::double_ height_type;
        typedef ::xsd::cxx::tree::traits< height_type, char, ::xsd::cxx::tree::schema_type::double_ > height_traits;

        const height_type&
        height () const;

        height_type&
        height ();

        void
        height (const height_type& x);

        // id
        //
        typedef ::xml_schema::non_negative_integer id_type;
        typedef ::xsd::cxx::tree::optional< id_type > id_optional;
        typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

        const id_optional&
        id () const;

        id_optional&
        id ();

        void
        id (const id_type& x);

        void
        id (const id_optional& x);

        // Constructors.
        //
        t_road_objects_object_outlines_outline_cornerRoad (const s_type&,
                                                           const t_type&,
                                                           const dz_type&,
                                                           const height_type&);

        t_road_objects_object_outlines_outline_cornerRoad (const ::xercesc::DOMElement& e,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

        t_road_objects_object_outlines_outline_cornerRoad (const t_road_objects_object_outlines_outline_cornerRoad& x,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

        virtual t_road_objects_object_outlines_outline_cornerRoad*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_object_outlines_outline_cornerRoad&
        operator= (const t_road_objects_object_outlines_outline_cornerRoad& x);

        virtual 
        ~t_road_objects_object_outlines_outline_cornerRoad ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< s_type > s_;
        ::xsd::cxx::tree::one< t_type > t_;
        ::xsd::cxx::tree::one< dz_type > dz_;
        ::xsd::cxx::tree::one< height_type > height_;
        id_optional id_;
      };

      class t_road_objects_object_parkingSpace: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // access
        //
        typedef ::simulation::standard::opendrive_schema::e_road_objects_object_parkingSpace_access access_type;
        typedef ::xsd::cxx::tree::traits< access_type, char > access_traits;

        const access_type&
        parkingSpace_access () const;

        access_type&
        parkingSpace_access ();

        void
        parkingSpace_access (const access_type& x);

        void
        parkingSpace_access (::std::unique_ptr< access_type > p);

        // restrictions
        //
        typedef ::xml_schema::string restrictions_type;
        typedef ::xsd::cxx::tree::optional< restrictions_type > restrictions_optional;
        typedef ::xsd::cxx::tree::traits< restrictions_type, char > restrictions_traits;

        const restrictions_optional&
        restrictions () const;

        restrictions_optional&
        restrictions ();

        void
        restrictions (const restrictions_type& x);

        void
        restrictions (const restrictions_optional& x);

        void
        restrictions (::std::unique_ptr< restrictions_type > p);

        // Constructors.
        //
        t_road_objects_object_parkingSpace (const access_type&);

        t_road_objects_object_parkingSpace (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

        t_road_objects_object_parkingSpace (const t_road_objects_object_parkingSpace& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

        virtual t_road_objects_object_parkingSpace*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_object_parkingSpace&
        operator= (const t_road_objects_object_parkingSpace& x);

        virtual 
        ~t_road_objects_object_parkingSpace ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< access_type > parkingSpace_access_;
        restrictions_optional restrictions_;
      };

      class t_road_objects_object_repeat: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // s
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero s_type;
        typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

        const s_type&
        s () const;

        s_type&
        s ();

        void
        s (const s_type& x);

        void
        s (::std::unique_ptr< s_type > p);

        // length
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero length_type;
        typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

        const length_type&
        length () const;

        length_type&
        length ();

        void
        length (const length_type& x);

        void
        length (::std::unique_ptr< length_type > p);

        // distance
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero distance_type;
        typedef ::xsd::cxx::tree::traits< distance_type, char > distance_traits;

        const distance_type&
        distance () const;

        distance_type&
        distance ();

        void
        distance (const distance_type& x);

        void
        distance (::std::unique_ptr< distance_type > p);

        // tStart
        //
        typedef ::xml_schema::double_ tStart_type;
        typedef ::xsd::cxx::tree::traits< tStart_type, char, ::xsd::cxx::tree::schema_type::double_ > tStart_traits;

        const tStart_type&
        tStart () const;

        tStart_type&
        tStart ();

        void
        tStart (const tStart_type& x);

        // tEnd
        //
        typedef ::xml_schema::double_ tEnd_type;
        typedef ::xsd::cxx::tree::traits< tEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > tEnd_traits;

        const tEnd_type&
        tEnd () const;

        tEnd_type&
        tEnd ();

        void
        tEnd (const tEnd_type& x);

        // heightStart
        //
        typedef ::xml_schema::double_ heightStart_type;
        typedef ::xsd::cxx::tree::traits< heightStart_type, char, ::xsd::cxx::tree::schema_type::double_ > heightStart_traits;

        const heightStart_type&
        heightStart () const;

        heightStart_type&
        heightStart ();

        void
        heightStart (const heightStart_type& x);

        // heightEnd
        //
        typedef ::xml_schema::double_ heightEnd_type;
        typedef ::xsd::cxx::tree::traits< heightEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > heightEnd_traits;

        const heightEnd_type&
        heightEnd () const;

        heightEnd_type&
        heightEnd ();

        void
        heightEnd (const heightEnd_type& x);

        // zOffsetStart
        //
        typedef ::xml_schema::double_ zOffsetStart_type;
        typedef ::xsd::cxx::tree::traits< zOffsetStart_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffsetStart_traits;

        const zOffsetStart_type&
        zOffsetStart () const;

        zOffsetStart_type&
        zOffsetStart ();

        void
        zOffsetStart (const zOffsetStart_type& x);

        // zOffsetEnd
        //
        typedef ::xml_schema::double_ zOffsetEnd_type;
        typedef ::xsd::cxx::tree::traits< zOffsetEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffsetEnd_traits;

        const zOffsetEnd_type&
        zOffsetEnd () const;

        zOffsetEnd_type&
        zOffsetEnd ();

        void
        zOffsetEnd (const zOffsetEnd_type& x);

        // widthStart
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero widthStart_type;
        typedef ::xsd::cxx::tree::optional< widthStart_type > widthStart_optional;
        typedef ::xsd::cxx::tree::traits< widthStart_type, char > widthStart_traits;

        const widthStart_optional&
        widthStart () const;

        widthStart_optional&
        widthStart ();

        void
        widthStart (const widthStart_type& x);

        void
        widthStart (const widthStart_optional& x);

        void
        widthStart (::std::unique_ptr< widthStart_type > p);

        // widthEnd
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero widthEnd_type;
        typedef ::xsd::cxx::tree::optional< widthEnd_type > widthEnd_optional;
        typedef ::xsd::cxx::tree::traits< widthEnd_type, char > widthEnd_traits;

        const widthEnd_optional&
        widthEnd () const;

        widthEnd_optional&
        widthEnd ();

        void
        widthEnd (const widthEnd_type& x);

        void
        widthEnd (const widthEnd_optional& x);

        void
        widthEnd (::std::unique_ptr< widthEnd_type > p);

        // lengthStart
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero lengthStart_type;
        typedef ::xsd::cxx::tree::optional< lengthStart_type > lengthStart_optional;
        typedef ::xsd::cxx::tree::traits< lengthStart_type, char > lengthStart_traits;

        const lengthStart_optional&
        lengthStart () const;

        lengthStart_optional&
        lengthStart ();

        void
        lengthStart (const lengthStart_type& x);

        void
        lengthStart (const lengthStart_optional& x);

        void
        lengthStart (::std::unique_ptr< lengthStart_type > p);

        // lengthEnd
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero lengthEnd_type;
        typedef ::xsd::cxx::tree::optional< lengthEnd_type > lengthEnd_optional;
        typedef ::xsd::cxx::tree::traits< lengthEnd_type, char > lengthEnd_traits;

        const lengthEnd_optional&
        lengthEnd () const;

        lengthEnd_optional&
        lengthEnd ();

        void
        lengthEnd (const lengthEnd_type& x);

        void
        lengthEnd (const lengthEnd_optional& x);

        void
        lengthEnd (::std::unique_ptr< lengthEnd_type > p);

        // radiusStart
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero radiusStart_type;
        typedef ::xsd::cxx::tree::optional< radiusStart_type > radiusStart_optional;
        typedef ::xsd::cxx::tree::traits< radiusStart_type, char > radiusStart_traits;

        const radiusStart_optional&
        radiusStart () const;

        radiusStart_optional&
        radiusStart ();

        void
        radiusStart (const radiusStart_type& x);

        void
        radiusStart (const radiusStart_optional& x);

        void
        radiusStart (::std::unique_ptr< radiusStart_type > p);

        // radiusEnd
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero radiusEnd_type;
        typedef ::xsd::cxx::tree::optional< radiusEnd_type > radiusEnd_optional;
        typedef ::xsd::cxx::tree::traits< radiusEnd_type, char > radiusEnd_traits;

        const radiusEnd_optional&
        radiusEnd () const;

        radiusEnd_optional&
        radiusEnd ();

        void
        radiusEnd (const radiusEnd_type& x);

        void
        radiusEnd (const radiusEnd_optional& x);

        void
        radiusEnd (::std::unique_ptr< radiusEnd_type > p);

        // Constructors.
        //
        t_road_objects_object_repeat (const s_type&,
                                      const length_type&,
                                      const distance_type&,
                                      const tStart_type&,
                                      const tEnd_type&,
                                      const heightStart_type&,
                                      const heightEnd_type&,
                                      const zOffsetStart_type&,
                                      const zOffsetEnd_type&);

        t_road_objects_object_repeat (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

        t_road_objects_object_repeat (const t_road_objects_object_repeat& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

        virtual t_road_objects_object_repeat*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_object_repeat&
        operator= (const t_road_objects_object_repeat& x);

        virtual 
        ~t_road_objects_object_repeat ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< s_type > s_;
        ::xsd::cxx::tree::one< length_type > length_;
        ::xsd::cxx::tree::one< distance_type > distance_;
        ::xsd::cxx::tree::one< tStart_type > tStart_;
        ::xsd::cxx::tree::one< tEnd_type > tEnd_;
        ::xsd::cxx::tree::one< heightStart_type > heightStart_;
        ::xsd::cxx::tree::one< heightEnd_type > heightEnd_;
        ::xsd::cxx::tree::one< zOffsetStart_type > zOffsetStart_;
        ::xsd::cxx::tree::one< zOffsetEnd_type > zOffsetEnd_;
        widthStart_optional widthStart_;
        widthEnd_optional widthEnd_;
        lengthStart_optional lengthStart_;
        lengthEnd_optional lengthEnd_;
        radiusStart_optional radiusStart_;
        radiusEnd_optional radiusEnd_;
      };

      class t_road_objects_objectReference: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // validity
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_laneValidity validity_type;
        typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
        typedef validity_sequence::iterator validity_iterator;
        typedef validity_sequence::const_iterator validity_const_iterator;
        typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

        const validity_sequence&
        validity () const;

        validity_sequence&
        validity ();

        void
        validity (const validity_sequence& s);

        // include
        //
        typedef ::simulation::standard::opendrive_schema::t_include include_type;
        typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
        typedef include_sequence::iterator include_iterator;
        typedef include_sequence::const_iterator include_const_iterator;
        typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

        const include_sequence&
        include () const;

        include_sequence&
        include ();

        void
        include (const include_sequence& s);

        // userData
        //
        typedef ::simulation::standard::opendrive_schema::t_userData userData_type;
        typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
        typedef userData_sequence::iterator userData_iterator;
        typedef userData_sequence::const_iterator userData_const_iterator;
        typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

        const userData_sequence&
        userData () const;

        userData_sequence&
        userData ();

        void
        userData (const userData_sequence& s);

        // dataQuality
        //
        typedef ::simulation::standard::opendrive_schema::t_dataQuality dataQuality_type;
        typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
        typedef dataQuality_sequence::iterator dataQuality_iterator;
        typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
        typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

        const dataQuality_sequence&
        dataQuality () const;

        dataQuality_sequence&
        dataQuality ();

        void
        dataQuality (const dataQuality_sequence& s);

        // s
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero s_type;
        typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

        const s_type&
        s () const;

        s_type&
        s ();

        void
        s (const s_type& x);

        void
        s (::std::unique_ptr< s_type > p);

        // t
        //
        typedef ::xml_schema::double_ t_type;
        typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

        const t_type&
        t () const;

        t_type&
        t ();

        void
        t (const t_type& x);

        // id
        //
        typedef ::xml_schema::string id_type;
        typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

        const id_type&
        id () const;

        id_type&
        id ();

        void
        id (const id_type& x);

        void
        id (::std::unique_ptr< id_type > p);

        // zOffset
        //
        typedef ::xml_schema::double_ zOffset_type;
        typedef ::xsd::cxx::tree::optional< zOffset_type > zOffset_optional;
        typedef ::xsd::cxx::tree::traits< zOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffset_traits;

        const zOffset_optional&
        zOffset () const;

        zOffset_optional&
        zOffset ();

        void
        zOffset (const zOffset_type& x);

        void
        zOffset (const zOffset_optional& x);

        // validLength
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero validLength_type;
        typedef ::xsd::cxx::tree::optional< validLength_type > validLength_optional;
        typedef ::xsd::cxx::tree::traits< validLength_type, char > validLength_traits;

        const validLength_optional&
        validLength () const;

        validLength_optional&
        validLength ();

        void
        validLength (const validLength_type& x);

        void
        validLength (const validLength_optional& x);

        void
        validLength (::std::unique_ptr< validLength_type > p);

        // orientation
        //
        typedef ::simulation::standard::opendrive_schema::e_orientation orientation_type;
        typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

        const orientation_type&
        orientation () const;

        orientation_type&
        orientation ();

        void
        orientation (const orientation_type& x);

        void
        orientation (::std::unique_ptr< orientation_type > p);

        // Constructors.
        //
        t_road_objects_objectReference (const s_type&,
                                        const t_type&,
                                        const id_type&,
                                        const orientation_type&);

        t_road_objects_objectReference (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

        t_road_objects_objectReference (const t_road_objects_objectReference& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

        virtual t_road_objects_objectReference*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_objectReference&
        operator= (const t_road_objects_objectReference& x);

        virtual 
        ~t_road_objects_objectReference ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        validity_sequence validity_;
        include_sequence include_;
        userData_sequence userData_;
        dataQuality_sequence dataQuality_;
        ::xsd::cxx::tree::one< s_type > s_;
        ::xsd::cxx::tree::one< t_type > t_;
        ::xsd::cxx::tree::one< id_type > id_;
        zOffset_optional zOffset_;
        validLength_optional validLength_;
        ::xsd::cxx::tree::one< orientation_type > orientation_;
      };

      class t_road_objects_tunnel: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // validity
        //
        typedef ::simulation::standard::opendrive_schema::t_road_objects_object_laneValidity validity_type;
        typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
        typedef validity_sequence::iterator validity_iterator;
        typedef validity_sequence::const_iterator validity_const_iterator;
        typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

        const validity_sequence&
        validity () const;

        validity_sequence&
        validity ();

        void
        validity (const validity_sequence& s);

        // include
        //
        typedef ::simulation::standard::opendrive_schema::t_include include_type;
        typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
        typedef include_sequence::iterator include_iterator;
        typedef include_sequence::const_iterator include_const_iterator;
        typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

        const include_sequence&
        include () const;

        include_sequence&
        include ();

        void
        include (const include_sequence& s);

        // userData
        //
        typedef ::simulation::standard::opendrive_schema::t_userData userData_type;
        typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
        typedef userData_sequence::iterator userData_iterator;
        typedef userData_sequence::const_iterator userData_const_iterator;
        typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

        const userData_sequence&
        userData () const;

        userData_sequence&
        userData ();

        void
        userData (const userData_sequence& s);

        // dataQuality
        //
        typedef ::simulation::standard::opendrive_schema::t_dataQuality dataQuality_type;
        typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
        typedef dataQuality_sequence::iterator dataQuality_iterator;
        typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
        typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

        const dataQuality_sequence&
        dataQuality () const;

        dataQuality_sequence&
        dataQuality ();

        void
        dataQuality (const dataQuality_sequence& s);

        // s
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero s_type;
        typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

        const s_type&
        s () const;

        s_type&
        s ();

        void
        s (const s_type& x);

        void
        s (::std::unique_ptr< s_type > p);

        // length
        //
        typedef ::simulation::standard::opendrive_schema::t_grEqZero length_type;
        typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

        const length_type&
        length () const;

        length_type&
        length ();

        void
        length (const length_type& x);

        void
        length (::std::unique_ptr< length_type > p);

        // name
        //
        typedef ::xml_schema::string name_type;
        typedef ::xsd::cxx::tree::optional< name_type > name_optional;
        typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

        const name_optional&
        name () const;

        name_optional&
        name ();

        void
        name (const name_type& x);

        void
        name (const name_optional& x);

        void
        name (::std::unique_ptr< name_type > p);

        // id
        //
        typedef ::xml_schema::string id_type;
        typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

        const id_type&
        id () const;

        id_type&
        id ();

        void
        id (const id_type& x);

        void
        id (::std::unique_ptr< id_type > p);

        // type
        //
        typedef ::simulation::standard::opendrive_schema::e_tunnelType type_type;
        typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

        const type_type&
        type () const;

        type_type&
        type ();

        void
        type (const type_type& x);

        void
        type (::std::unique_ptr< type_type > p);

        // lighting
        //
        typedef ::simulation::standard::opendrive_schema::t_zeroOne lighting_type;
        typedef ::xsd::cxx::tree::optional< lighting_type > lighting_optional;
        typedef ::xsd::cxx::tree::traits< lighting_type, char > lighting_traits;

        const lighting_optional&
        lighting () const;

        lighting_optional&
        lighting ();

        void
        lighting (const lighting_type& x);

        void
        lighting (const lighting_optional& x);

        void
        lighting (::std::unique_ptr< lighting_type > p);

        // daylight
        //
        typedef ::simulation::standard::opendrive_schema::t_zeroOne daylight_type;
        typedef ::xsd::cxx::tree::optional< daylight_type > daylight_optional;
        typedef ::xsd::cxx::tree::traits< daylight_type, char > daylight_traits;

        const daylight_optional&
        daylight () const;

        daylight_optional&
        daylight ();

        void
        daylight (const daylight_type& x);

        void
        daylight (const daylight_optional& x);

        void
        daylight (::std::unique_ptr< daylight_type > p);

        // Constructors.
        //
        t_road_objects_tunnel (const s_type&,
                               const length_type&,
                               const id_type&,
                               const type_type&);

        t_road_objects_tunnel (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

        t_road_objects_tunnel (const t_road_objects_tunnel& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

        virtual t_road_objects_tunnel*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_road_objects_tunnel&
        operator= (const t_road_objects_tunnel& x);

        virtual 
        ~t_road_objects_tunnel ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        validity_sequence validity_;
        include_sequence include_;
        userData_sequence userData_;
        dataQuality_sequence dataQuality_;
        ::xsd::cxx::tree::one< s_type > s_;
        ::xsd::cxx::tree::one< length_type > length_;
        name_optional name_;
        ::xsd::cxx::tree::one< id_type > id_;
        ::xsd::cxx::tree::one< type_type > type_;
        lighting_optional lighting_;
        daylight_optional daylight_;
      };
    }
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace simulation
{
  namespace standard
  {
    namespace opendrive_schema
    {
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // DELIVERABLE_XSD_SCHEMA_OPENDRIVE_16_OBJECT_HXX
