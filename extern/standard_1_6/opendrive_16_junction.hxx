// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef DELIVERABLE_XSD_SCHEMA_OPENDRIVE_16_JUNCTION_HXX
#define DELIVERABLE_XSD_SCHEMA_OPENDRIVE_16_JUNCTION_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace simulation
{
  namespace standard
  {
    namespace opendrive_schema
    {
      class e_contactPoint;
      class e_elementDir;
      class e_junction_type;
      class e_junctionGroup_type;
      class e_road_surface_CRG_mode;
      class e_road_surface_CRG_purpose;
      class t_junction;
      class t_junction_connection;
      class t_junction_connection_laneLink;
      class t_junction_controller;
      class t_junction_predecessorSuccessor;
      class t_junction_priority;
      class t_junction_surface;
      class t_junction_surface_CRG;
      class t_junctionGroup;
      class t_junctionGroup_junctionReference;
    }
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "opendrive_16_core.hxx"

namespace simulation
{
  namespace standard
  {
    namespace opendrive_schema
    {
      class e_contactPoint: public ::xml_schema::string
      {
        public:
        enum value
        {
          start,
          end
        };

        e_contactPoint (value v);

        e_contactPoint (const char* v);

        e_contactPoint (const ::std::string& v);

        e_contactPoint (const ::xml_schema::string& v);

        e_contactPoint (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        e_contactPoint (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        e_contactPoint (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        e_contactPoint (const e_contactPoint& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

        virtual e_contactPoint*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        e_contactPoint&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_e_contactPoint_convert ();
        }

        protected:
        value
        _xsd_e_contactPoint_convert () const;

        public:
        static const char* const _xsd_e_contactPoint_literals_[2];
        static const value _xsd_e_contactPoint_indexes_[2];
      };

      class e_elementDir: public ::xml_schema::string
      {
        public:
        enum value
        {
          cxx_,
          cxx_1
        };

        e_elementDir (value v);

        e_elementDir (const char* v);

        e_elementDir (const ::std::string& v);

        e_elementDir (const ::xml_schema::string& v);

        e_elementDir (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        e_elementDir (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        e_elementDir (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        e_elementDir (const e_elementDir& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

        virtual e_elementDir*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        e_elementDir&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_e_elementDir_convert ();
        }

        protected:
        value
        _xsd_e_elementDir_convert () const;

        public:
        static const char* const _xsd_e_elementDir_literals_[2];
        static const value _xsd_e_elementDir_indexes_[2];
      };

      class e_junction_type: public ::xml_schema::string
      {
        public:
        enum value
        {
          default_,
          virtual_
        };

        e_junction_type (value v);

        e_junction_type (const char* v);

        e_junction_type (const ::std::string& v);

        e_junction_type (const ::xml_schema::string& v);

        e_junction_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        e_junction_type (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        e_junction_type (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        e_junction_type (const e_junction_type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        virtual e_junction_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        e_junction_type&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_e_junction_type_convert ();
        }

        protected:
        value
        _xsd_e_junction_type_convert () const;

        public:
        static const char* const _xsd_e_junction_type_literals_[2];
        static const value _xsd_e_junction_type_indexes_[2];
      };

      class e_junctionGroup_type: public ::xml_schema::string
      {
        public:
        enum value
        {
          roundabout,
          unknown
        };

        e_junctionGroup_type (value v);

        e_junctionGroup_type (const char* v);

        e_junctionGroup_type (const ::std::string& v);

        e_junctionGroup_type (const ::xml_schema::string& v);

        e_junctionGroup_type (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

        e_junctionGroup_type (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

        e_junctionGroup_type (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

        e_junctionGroup_type (const e_junctionGroup_type& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

        virtual e_junctionGroup_type*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        e_junctionGroup_type&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_e_junctionGroup_type_convert ();
        }

        protected:
        value
        _xsd_e_junctionGroup_type_convert () const;

        public:
        static const char* const _xsd_e_junctionGroup_type_literals_[2];
        static const value _xsd_e_junctionGroup_type_indexes_[2];
      };

      class e_road_surface_CRG_mode: public ::xml_schema::string
      {
        public:
        enum value
        {
          attached,
          attached0,
          genuine,
          global
        };

        e_road_surface_CRG_mode (value v);

        e_road_surface_CRG_mode (const char* v);

        e_road_surface_CRG_mode (const ::std::string& v);

        e_road_surface_CRG_mode (const ::xml_schema::string& v);

        e_road_surface_CRG_mode (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

        e_road_surface_CRG_mode (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

        e_road_surface_CRG_mode (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

        e_road_surface_CRG_mode (const e_road_surface_CRG_mode& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

        virtual e_road_surface_CRG_mode*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        e_road_surface_CRG_mode&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_e_road_surface_CRG_mode_convert ();
        }

        protected:
        value
        _xsd_e_road_surface_CRG_mode_convert () const;

        public:
        static const char* const _xsd_e_road_surface_CRG_mode_literals_[4];
        static const value _xsd_e_road_surface_CRG_mode_indexes_[4];
      };

      class e_road_surface_CRG_purpose: public ::xml_schema::string
      {
        public:
        enum value
        {
          elevation,
          friction
        };

        e_road_surface_CRG_purpose (value v);

        e_road_surface_CRG_purpose (const char* v);

        e_road_surface_CRG_purpose (const ::std::string& v);

        e_road_surface_CRG_purpose (const ::xml_schema::string& v);

        e_road_surface_CRG_purpose (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

        e_road_surface_CRG_purpose (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

        e_road_surface_CRG_purpose (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

        e_road_surface_CRG_purpose (const e_road_surface_CRG_purpose& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

        virtual e_road_surface_CRG_purpose*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        e_road_surface_CRG_purpose&
        operator= (value v);

        virtual
        operator value () const
        {
          return _xsd_e_road_surface_CRG_purpose_convert ();
        }

        protected:
        value
        _xsd_e_road_surface_CRG_purpose_convert () const;

        public:
        static const char* const _xsd_e_road_surface_CRG_purpose_literals_[2];
        static const value _xsd_e_road_surface_CRG_purpose_indexes_[2];
      };

      class t_junction: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // connection
        //
        typedef ::simulation::standard::opendrive_schema::t_junction_connection connection_type;
        typedef ::xsd::cxx::tree::sequence< connection_type > connection_sequence;
        typedef connection_sequence::iterator connection_iterator;
        typedef connection_sequence::const_iterator connection_const_iterator;
        typedef ::xsd::cxx::tree::traits< connection_type, char > connection_traits;

        const connection_sequence&
        connection () const;

        connection_sequence&
        connection ();

        void
        connection (const connection_sequence& s);

        // priority
        //
        typedef ::simulation::standard::opendrive_schema::t_junction_priority priority_type;
        typedef ::xsd::cxx::tree::sequence< priority_type > priority_sequence;
        typedef priority_sequence::iterator priority_iterator;
        typedef priority_sequence::const_iterator priority_const_iterator;
        typedef ::xsd::cxx::tree::traits< priority_type, char > priority_traits;

        const priority_sequence&
        priority () const;

        priority_sequence&
        priority ();

        void
        priority (const priority_sequence& s);

        // controller
        //
        typedef ::simulation::standard::opendrive_schema::t_junction_controller controller_type;
        typedef ::xsd::cxx::tree::sequence< controller_type > controller_sequence;
        typedef controller_sequence::iterator controller_iterator;
        typedef controller_sequence::const_iterator controller_const_iterator;
        typedef ::xsd::cxx::tree::traits< controller_type, char > controller_traits;

        const controller_sequence&
        controller () const;

        controller_sequence&
        controller ();

        void
        controller (const controller_sequence& s);

        // surface
        //
        typedef ::simulation::standard::opendrive_schema::t_junction_surface surface_type;
        typedef ::xsd::cxx::tree::optional< surface_type > surface_optional;
        typedef ::xsd::cxx::tree::traits< surface_type, char > surface_traits;

        const surface_optional&
        surface () const;

        surface_optional&
        surface ();

        void
        surface (const surface_type& x);

        void
        surface (const surface_optional& x);

        void
        surface (::std::unique_ptr< surface_type > p);

        // include
        //
        typedef ::simulation::standard::opendrive_schema::t_include include_type;
        typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
        typedef include_sequence::iterator include_iterator;
        typedef include_sequence::const_iterator include_const_iterator;
        typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

        const include_sequence&
        include () const;

        include_sequence&
        include ();

        void
        include (const include_sequence& s);

        // userData
        //
        typedef ::simulation::standard::opendrive_schema::t_userData userData_type;
        typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
        typedef userData_sequence::iterator userData_iterator;
        typedef userData_sequence::const_iterator userData_const_iterator;
        typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

        const userData_sequence&
        userData () const;

        userData_sequence&
        userData ();

        void
        userData (const userData_sequence& s);

        // dataQuality
        //
        typedef ::simulation::standard::opendrive_schema::t_dataQuality dataQuality_type;
        typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
        typedef dataQuality_sequence::iterator dataQuality_iterator;
        typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
        typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

        const dataQuality_sequence&
        dataQuality () const;

        dataQuality_sequence&
        dataQuality ();

        void
        dataQuality (const dataQuality_sequence& s);

        // name
        //
        typedef ::xml_schema::string name_type;
        typedef ::xsd::cxx::tree::optional< name_type > name_optional;
        typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

        const name_optional&
        name () const;

        name_optional&
        name ();

        void
        name (const name_type& x);

        void
        name (const name_optional& x);

        void
        name (::std::unique_ptr< name_type > p);

        // id
        //
        typedef ::xml_schema::string id_type;
        typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

        const id_type&
        id () const;

        id_type&
        id ();

        void
        id (const id_type& x);

        void
        id (::std::unique_ptr< id_type > p);

        // type
        //
        typedef ::simulation::standard::opendrive_schema::e_junction_type type_type;
        typedef ::xsd::cxx::tree::optional< type_type > type_optional;
        typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

        const type_optional&
        type () const;

        type_optional&
        type ();

        void
        type (const type_type& x);

        void
        type (const type_optional& x);

        void
        type (::std::unique_ptr< type_type > p);

        // Constructors.
        //
        t_junction (const id_type&);

        t_junction (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        t_junction (const t_junction& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

        virtual t_junction*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_junction&
        operator= (const t_junction& x);

        virtual 
        ~t_junction ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        connection_sequence connection_;
        priority_sequence priority_;
        controller_sequence controller_;
        surface_optional surface_;
        include_sequence include_;
        userData_sequence userData_;
        dataQuality_sequence dataQuality_;
        name_optional name_;
        ::xsd::cxx::tree::one< id_type > id_;
        type_optional type_;
      };

      class t_junction_connection: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // predecessor
        //
        typedef ::simulation::standard::opendrive_schema::t_junction_predecessorSuccessor predecessor_type;
        typedef ::xsd::cxx::tree::optional< predecessor_type > predecessor_optional;
        typedef ::xsd::cxx::tree::traits< predecessor_type, char > predecessor_traits;

        const predecessor_optional&
        predecessor () const;

        predecessor_optional&
        predecessor ();

        void
        predecessor (const predecessor_type& x);

        void
        predecessor (const predecessor_optional& x);

        void
        predecessor (::std::unique_ptr< predecessor_type > p);

        // successor
        //
        typedef ::simulation::standard::opendrive_schema::t_junction_predecessorSuccessor successor_type;
        typedef ::xsd::cxx::tree::optional< successor_type > successor_optional;
        typedef ::xsd::cxx::tree::traits< successor_type, char > successor_traits;

        const successor_optional&
        successor () const;

        successor_optional&
        successor ();

        void
        successor (const successor_type& x);

        void
        successor (const successor_optional& x);

        void
        successor (::std::unique_ptr< successor_type > p);

        // laneLink
        //
        typedef ::simulation::standard::opendrive_schema::t_junction_connection_laneLink laneLink_type;
        typedef ::xsd::cxx::tree::sequence< laneLink_type > laneLink_sequence;
        typedef laneLink_sequence::iterator laneLink_iterator;
        typedef laneLink_sequence::const_iterator laneLink_const_iterator;
        typedef ::xsd::cxx::tree::traits< laneLink_type, char > laneLink_traits;

        const laneLink_sequence&
        laneLink () const;

        laneLink_sequence&
        laneLink ();

        void
        laneLink (const laneLink_sequence& s);

        // id
        //
        typedef ::xml_schema::string id_type;
        typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

        const id_type&
        id () const;

        id_type&
        id ();

        void
        id (const id_type& x);

        void
        id (::std::unique_ptr< id_type > p);

        // type
        //
        typedef ::simulation::standard::opendrive_schema::e_junction_type type_type;
        typedef ::xsd::cxx::tree::optional< type_type > type_optional;
        typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

        const type_optional&
        type () const;

        type_optional&
        type ();

        void
        type (const type_type& x);

        void
        type (const type_optional& x);

        void
        type (::std::unique_ptr< type_type > p);

        // incomingRoad
        //
        typedef ::xml_schema::string incomingRoad_type;
        typedef ::xsd::cxx::tree::optional< incomingRoad_type > incomingRoad_optional;
        typedef ::xsd::cxx::tree::traits< incomingRoad_type, char > incomingRoad_traits;

        const incomingRoad_optional&
        incomingRoad () const;

        incomingRoad_optional&
        incomingRoad ();

        void
        incomingRoad (const incomingRoad_type& x);

        void
        incomingRoad (const incomingRoad_optional& x);

        void
        incomingRoad (::std::unique_ptr< incomingRoad_type > p);

        // connectingRoad
        //
        typedef ::xml_schema::string connectingRoad_type;
        typedef ::xsd::cxx::tree::optional< connectingRoad_type > connectingRoad_optional;
        typedef ::xsd::cxx::tree::traits< connectingRoad_type, char > connectingRoad_traits;

        const connectingRoad_optional&
        connectingRoad () const;

        connectingRoad_optional&
        connectingRoad ();

        void
        connectingRoad (const connectingRoad_type& x);

        void
        connectingRoad (const connectingRoad_optional& x);

        void
        connectingRoad (::std::unique_ptr< connectingRoad_type > p);

        // contactPoint
        //
        typedef ::xml_schema::string contactPoint_type;
        typedef ::xsd::cxx::tree::optional< contactPoint_type > contactPoint_optional;
        typedef ::xsd::cxx::tree::traits< contactPoint_type, char > contactPoint_traits;

        const contactPoint_optional&
        contactPoint () const;

        contactPoint_optional&
        contactPoint ();

        void
        contactPoint (const contactPoint_type& x);

        void
        contactPoint (const contactPoint_optional& x);

        void
        contactPoint (::std::unique_ptr< contactPoint_type > p);

        // Constructors.
        //
        t_junction_connection (const id_type&);

        t_junction_connection (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

        t_junction_connection (const t_junction_connection& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

        virtual t_junction_connection*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_junction_connection&
        operator= (const t_junction_connection& x);

        virtual 
        ~t_junction_connection ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        predecessor_optional predecessor_;
        successor_optional successor_;
        laneLink_sequence laneLink_;
        ::xsd::cxx::tree::one< id_type > id_;
        type_optional type_;
        incomingRoad_optional incomingRoad_;
        connectingRoad_optional connectingRoad_;
        contactPoint_optional contactPoint_;
      };

      class t_junction_connection_laneLink: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // from
        //
        typedef ::xml_schema::integer from_type;
        typedef ::xsd::cxx::tree::traits< from_type, char > from_traits;

        const from_type&
        from () const;

        from_type&
        from ();

        void
        from (const from_type& x);

        // to
        //
        typedef ::xml_schema::integer to_type;
        typedef ::xsd::cxx::tree::traits< to_type, char > to_traits;

        const to_type&
        to () const;

        to_type&
        to ();

        void
        to (const to_type& x);

        // Constructors.
        //
        t_junction_connection_laneLink (const from_type&,
                                        const to_type&);

        t_junction_connection_laneLink (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

        t_junction_connection_laneLink (const t_junction_connection_laneLink& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

        virtual t_junction_connection_laneLink*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_junction_connection_laneLink&
        operator= (const t_junction_connection_laneLink& x);

        virtual 
        ~t_junction_connection_laneLink ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< from_type > from_;
        ::xsd::cxx::tree::one< to_type > to_;
      };

      class t_junction_controller: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // id
        //
        typedef ::xml_schema::string id_type;
        typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

        const id_type&
        id () const;

        id_type&
        id ();

        void
        id (const id_type& x);

        void
        id (::std::unique_ptr< id_type > p);

        // type
        //
        typedef ::xml_schema::string type_type;
        typedef ::xsd::cxx::tree::optional< type_type > type_optional;
        typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

        const type_optional&
        type () const;

        type_optional&
        type ();

        void
        type (const type_type& x);

        void
        type (const type_optional& x);

        void
        type (::std::unique_ptr< type_type > p);

        // sequence
        //
        typedef ::xml_schema::non_negative_integer sequence_type;
        typedef ::xsd::cxx::tree::optional< sequence_type > sequence_optional;
        typedef ::xsd::cxx::tree::traits< sequence_type, char > sequence_traits;

        const sequence_optional&
        sequence () const;

        sequence_optional&
        sequence ();

        void
        sequence (const sequence_type& x);

        void
        sequence (const sequence_optional& x);

        // Constructors.
        //
        t_junction_controller (const id_type&);

        t_junction_controller (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

        t_junction_controller (const t_junction_controller& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

        virtual t_junction_controller*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_junction_controller&
        operator= (const t_junction_controller& x);

        virtual 
        ~t_junction_controller ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< id_type > id_;
        type_optional type_;
        sequence_optional sequence_;
      };

      class t_junction_predecessorSuccessor: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // elementType
        //
        typedef ::xml_schema::string elementType_type;
        typedef ::xsd::cxx::tree::traits< elementType_type, char > elementType_traits;

        const elementType_type&
        elementType () const;

        static const elementType_type&
        elementType_default_value ();

        // elementId
        //
        typedef ::xml_schema::string elementId_type;
        typedef ::xsd::cxx::tree::traits< elementId_type, char > elementId_traits;

        const elementId_type&
        elementId () const;

        elementId_type&
        elementId ();

        void
        elementId (const elementId_type& x);

        void
        elementId (::std::unique_ptr< elementId_type > p);

        // elementS
        //
        typedef ::simulation::standard::opendrive_schema::t_grZero elementS_type;
        typedef ::xsd::cxx::tree::traits< elementS_type, char > elementS_traits;

        const elementS_type&
        elementS () const;

        elementS_type&
        elementS ();

        void
        elementS (const elementS_type& x);

        void
        elementS (::std::unique_ptr< elementS_type > p);

        // elementDir
        //
        typedef ::simulation::standard::opendrive_schema::e_elementDir elementDir_type;
        typedef ::xsd::cxx::tree::traits< elementDir_type, char > elementDir_traits;

        const elementDir_type&
        elementDir () const;

        elementDir_type&
        elementDir ();

        void
        elementDir (const elementDir_type& x);

        void
        elementDir (::std::unique_ptr< elementDir_type > p);

        // Constructors.
        //
        t_junction_predecessorSuccessor (const elementId_type&,
                                         const elementS_type&,
                                         const elementDir_type&);

        t_junction_predecessorSuccessor (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

        t_junction_predecessorSuccessor (const t_junction_predecessorSuccessor& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

        virtual t_junction_predecessorSuccessor*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_junction_predecessorSuccessor&
        operator= (const t_junction_predecessorSuccessor& x);

        virtual 
        ~t_junction_predecessorSuccessor ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< elementType_type > elementType_;
        static const elementType_type elementType_default_value_;
        ::xsd::cxx::tree::one< elementId_type > elementId_;
        ::xsd::cxx::tree::one< elementS_type > elementS_;
        ::xsd::cxx::tree::one< elementDir_type > elementDir_;
      };

      class t_junction_priority: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // high
        //
        typedef ::xml_schema::string high_type;
        typedef ::xsd::cxx::tree::optional< high_type > high_optional;
        typedef ::xsd::cxx::tree::traits< high_type, char > high_traits;

        const high_optional&
        high () const;

        high_optional&
        high ();

        void
        high (const high_type& x);

        void
        high (const high_optional& x);

        void
        high (::std::unique_ptr< high_type > p);

        // low
        //
        typedef ::xml_schema::string low_type;
        typedef ::xsd::cxx::tree::optional< low_type > low_optional;
        typedef ::xsd::cxx::tree::traits< low_type, char > low_traits;

        const low_optional&
        low () const;

        low_optional&
        low ();

        void
        low (const low_type& x);

        void
        low (const low_optional& x);

        void
        low (::std::unique_ptr< low_type > p);

        // Constructors.
        //
        t_junction_priority ();

        t_junction_priority (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        t_junction_priority (const t_junction_priority& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

        virtual t_junction_priority*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_junction_priority&
        operator= (const t_junction_priority& x);

        virtual 
        ~t_junction_priority ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        high_optional high_;
        low_optional low_;
      };

      class t_junction_surface: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // CRG
        //
        typedef ::simulation::standard::opendrive_schema::t_junction_surface_CRG CRG_type;
        typedef ::xsd::cxx::tree::sequence< CRG_type > CRG_sequence;
        typedef CRG_sequence::iterator CRG_iterator;
        typedef CRG_sequence::const_iterator CRG_const_iterator;
        typedef ::xsd::cxx::tree::traits< CRG_type, char > CRG_traits;

        const CRG_sequence&
        CRG () const;

        CRG_sequence&
        CRG ();

        void
        CRG (const CRG_sequence& s);

        // include
        //
        typedef ::simulation::standard::opendrive_schema::t_include include_type;
        typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
        typedef include_sequence::iterator include_iterator;
        typedef include_sequence::const_iterator include_const_iterator;
        typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

        const include_sequence&
        include () const;

        include_sequence&
        include ();

        void
        include (const include_sequence& s);

        // userData
        //
        typedef ::simulation::standard::opendrive_schema::t_userData userData_type;
        typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
        typedef userData_sequence::iterator userData_iterator;
        typedef userData_sequence::const_iterator userData_const_iterator;
        typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

        const userData_sequence&
        userData () const;

        userData_sequence&
        userData ();

        void
        userData (const userData_sequence& s);

        // dataQuality
        //
        typedef ::simulation::standard::opendrive_schema::t_dataQuality dataQuality_type;
        typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
        typedef dataQuality_sequence::iterator dataQuality_iterator;
        typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
        typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

        const dataQuality_sequence&
        dataQuality () const;

        dataQuality_sequence&
        dataQuality ();

        void
        dataQuality (const dataQuality_sequence& s);

        // Constructors.
        //
        t_junction_surface ();

        t_junction_surface (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

        t_junction_surface (const t_junction_surface& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

        virtual t_junction_surface*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_junction_surface&
        operator= (const t_junction_surface& x);

        virtual 
        ~t_junction_surface ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        CRG_sequence CRG_;
        include_sequence include_;
        userData_sequence userData_;
        dataQuality_sequence dataQuality_;
      };

      class t_junction_surface_CRG: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // file
        //
        typedef ::xml_schema::string file_type;
        typedef ::xsd::cxx::tree::traits< file_type, char > file_traits;

        const file_type&
        file () const;

        file_type&
        file ();

        void
        file (const file_type& x);

        void
        file (::std::unique_ptr< file_type > p);

        // mode
        //
        typedef ::simulation::standard::opendrive_schema::e_road_surface_CRG_mode mode_type;
        typedef ::xsd::cxx::tree::traits< mode_type, char > mode_traits;

        const mode_type&
        mode () const;

        static const mode_type&
        mode_default_value ();

        // purpose
        //
        typedef ::simulation::standard::opendrive_schema::e_road_surface_CRG_purpose purpose_type;
        typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
        typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

        const purpose_optional&
        purpose () const;

        purpose_optional&
        purpose ();

        void
        purpose (const purpose_type& x);

        void
        purpose (const purpose_optional& x);

        void
        purpose (::std::unique_ptr< purpose_type > p);

        // zOffset
        //
        typedef ::xml_schema::double_ zOffset_type;
        typedef ::xsd::cxx::tree::optional< zOffset_type > zOffset_optional;
        typedef ::xsd::cxx::tree::traits< zOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffset_traits;

        const zOffset_optional&
        zOffset () const;

        zOffset_optional&
        zOffset ();

        void
        zOffset (const zOffset_type& x);

        void
        zOffset (const zOffset_optional& x);

        // zScale
        //
        typedef ::xml_schema::double_ zScale_type;
        typedef ::xsd::cxx::tree::optional< zScale_type > zScale_optional;
        typedef ::xsd::cxx::tree::traits< zScale_type, char, ::xsd::cxx::tree::schema_type::double_ > zScale_traits;

        const zScale_optional&
        zScale () const;

        zScale_optional&
        zScale ();

        void
        zScale (const zScale_type& x);

        void
        zScale (const zScale_optional& x);

        // Constructors.
        //
        t_junction_surface_CRG (const file_type&);

        t_junction_surface_CRG (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

        t_junction_surface_CRG (const t_junction_surface_CRG& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

        virtual t_junction_surface_CRG*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_junction_surface_CRG&
        operator= (const t_junction_surface_CRG& x);

        virtual 
        ~t_junction_surface_CRG ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< file_type > file_;
        ::xsd::cxx::tree::one< mode_type > mode_;
        static const mode_type mode_default_value_;
        purpose_optional purpose_;
        zOffset_optional zOffset_;
        zScale_optional zScale_;
      };

      class t_junctionGroup: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // junctionReference
        //
        typedef ::simulation::standard::opendrive_schema::t_junctionGroup_junctionReference junctionReference_type;
        typedef ::xsd::cxx::tree::sequence< junctionReference_type > junctionReference_sequence;
        typedef junctionReference_sequence::iterator junctionReference_iterator;
        typedef junctionReference_sequence::const_iterator junctionReference_const_iterator;
        typedef ::xsd::cxx::tree::traits< junctionReference_type, char > junctionReference_traits;

        const junctionReference_sequence&
        junctionReference () const;

        junctionReference_sequence&
        junctionReference ();

        void
        junctionReference (const junctionReference_sequence& s);

        // include
        //
        typedef ::simulation::standard::opendrive_schema::t_include include_type;
        typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
        typedef include_sequence::iterator include_iterator;
        typedef include_sequence::const_iterator include_const_iterator;
        typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

        const include_sequence&
        include () const;

        include_sequence&
        include ();

        void
        include (const include_sequence& s);

        // userData
        //
        typedef ::simulation::standard::opendrive_schema::t_userData userData_type;
        typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
        typedef userData_sequence::iterator userData_iterator;
        typedef userData_sequence::const_iterator userData_const_iterator;
        typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

        const userData_sequence&
        userData () const;

        userData_sequence&
        userData ();

        void
        userData (const userData_sequence& s);

        // dataQuality
        //
        typedef ::simulation::standard::opendrive_schema::t_dataQuality dataQuality_type;
        typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
        typedef dataQuality_sequence::iterator dataQuality_iterator;
        typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
        typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

        const dataQuality_sequence&
        dataQuality () const;

        dataQuality_sequence&
        dataQuality ();

        void
        dataQuality (const dataQuality_sequence& s);

        // name
        //
        typedef ::xml_schema::string name_type;
        typedef ::xsd::cxx::tree::optional< name_type > name_optional;
        typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

        const name_optional&
        name () const;

        name_optional&
        name ();

        void
        name (const name_type& x);

        void
        name (const name_optional& x);

        void
        name (::std::unique_ptr< name_type > p);

        // id
        //
        typedef ::xml_schema::string id_type;
        typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

        const id_type&
        id () const;

        id_type&
        id ();

        void
        id (const id_type& x);

        void
        id (::std::unique_ptr< id_type > p);

        // type
        //
        typedef ::simulation::standard::opendrive_schema::e_junctionGroup_type type_type;
        typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

        const type_type&
        type () const;

        type_type&
        type ();

        void
        type (const type_type& x);

        void
        type (::std::unique_ptr< type_type > p);

        // Constructors.
        //
        t_junctionGroup (const id_type&,
                         const type_type&);

        t_junctionGroup (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        t_junctionGroup (const t_junctionGroup& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

        virtual t_junctionGroup*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_junctionGroup&
        operator= (const t_junctionGroup& x);

        virtual 
        ~t_junctionGroup ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        junctionReference_sequence junctionReference_;
        include_sequence include_;
        userData_sequence userData_;
        dataQuality_sequence dataQuality_;
        name_optional name_;
        ::xsd::cxx::tree::one< id_type > id_;
        ::xsd::cxx::tree::one< type_type > type_;
      };

      class t_junctionGroup_junctionReference: public ::simulation::standard::opendrive_schema::_OpenDriveElement
      {
        public:
        // junction
        //
        typedef ::xml_schema::string junction_type;
        typedef ::xsd::cxx::tree::traits< junction_type, char > junction_traits;

        const junction_type&
        junction () const;

        junction_type&
        junction ();

        void
        junction (const junction_type& x);

        void
        junction (::std::unique_ptr< junction_type > p);

        // Constructors.
        //
        t_junctionGroup_junctionReference (const junction_type&);

        t_junctionGroup_junctionReference (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

        t_junctionGroup_junctionReference (const t_junctionGroup_junctionReference& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

        virtual t_junctionGroup_junctionReference*
        _clone (::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0) const;

        t_junctionGroup_junctionReference&
        operator= (const t_junctionGroup_junctionReference& x);

        virtual 
        ~t_junctionGroup_junctionReference ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::flags);

        protected:
        ::xsd::cxx::tree::one< junction_type > junction_;
      };
    }
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace simulation
{
  namespace standard
  {
    namespace opendrive_schema
    {
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // DELIVERABLE_XSD_SCHEMA_OPENDRIVE_16_JUNCTION_HXX
