// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "opendrive_16_signal.hxx"

namespace simulation
{
  namespace standard
  {
    namespace opendrive_schema
    {
      // e_road_signals_signal_reference_elementType
      // 

      e_road_signals_signal_reference_elementType::
      e_road_signals_signal_reference_elementType (value v)
      : ::xml_schema::string (_xsd_e_road_signals_signal_reference_elementType_literals_[v])
      {
      }

      e_road_signals_signal_reference_elementType::
      e_road_signals_signal_reference_elementType (const char* v)
      : ::xml_schema::string (v)
      {
      }

      e_road_signals_signal_reference_elementType::
      e_road_signals_signal_reference_elementType (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_road_signals_signal_reference_elementType::
      e_road_signals_signal_reference_elementType (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_road_signals_signal_reference_elementType::
      e_road_signals_signal_reference_elementType (const e_road_signals_signal_reference_elementType& v,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      e_road_signals_signal_reference_elementType& e_road_signals_signal_reference_elementType::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_e_road_signals_signal_reference_elementType_literals_[v]);

        return *this;
      }


      // t_controller
      // 

      const t_controller::control_sequence& t_controller::
      control () const
      {
        return this->control_;
      }

      t_controller::control_sequence& t_controller::
      control ()
      {
        return this->control_;
      }

      void t_controller::
      control (const control_sequence& s)
      {
        this->control_ = s;
      }

      const t_controller::include_sequence& t_controller::
      include () const
      {
        return this->include_;
      }

      t_controller::include_sequence& t_controller::
      include ()
      {
        return this->include_;
      }

      void t_controller::
      include (const include_sequence& s)
      {
        this->include_ = s;
      }

      const t_controller::userData_sequence& t_controller::
      userData () const
      {
        return this->userData_;
      }

      t_controller::userData_sequence& t_controller::
      userData ()
      {
        return this->userData_;
      }

      void t_controller::
      userData (const userData_sequence& s)
      {
        this->userData_ = s;
      }

      const t_controller::dataQuality_sequence& t_controller::
      dataQuality () const
      {
        return this->dataQuality_;
      }

      t_controller::dataQuality_sequence& t_controller::
      dataQuality ()
      {
        return this->dataQuality_;
      }

      void t_controller::
      dataQuality (const dataQuality_sequence& s)
      {
        this->dataQuality_ = s;
      }

      const t_controller::id_type& t_controller::
      id () const
      {
        return this->id_.get ();
      }

      t_controller::id_type& t_controller::
      id ()
      {
        return this->id_.get ();
      }

      void t_controller::
      id (const id_type& x)
      {
        this->id_.set (x);
      }

      void t_controller::
      id (::std::unique_ptr< id_type > x)
      {
        this->id_.set (std::move (x));
      }

      const t_controller::name_optional& t_controller::
      name () const
      {
        return this->name_;
      }

      t_controller::name_optional& t_controller::
      name ()
      {
        return this->name_;
      }

      void t_controller::
      name (const name_type& x)
      {
        this->name_.set (x);
      }

      void t_controller::
      name (const name_optional& x)
      {
        this->name_ = x;
      }

      void t_controller::
      name (::std::unique_ptr< name_type > x)
      {
        this->name_.set (std::move (x));
      }

      const t_controller::sequence_optional& t_controller::
      sequence () const
      {
        return this->sequence_;
      }

      t_controller::sequence_optional& t_controller::
      sequence ()
      {
        return this->sequence_;
      }

      void t_controller::
      sequence (const sequence_type& x)
      {
        this->sequence_.set (x);
      }

      void t_controller::
      sequence (const sequence_optional& x)
      {
        this->sequence_ = x;
      }


      // t_controller_control
      // 

      const t_controller_control::signalId_type& t_controller_control::
      signalId () const
      {
        return this->signalId_.get ();
      }

      t_controller_control::signalId_type& t_controller_control::
      signalId ()
      {
        return this->signalId_.get ();
      }

      void t_controller_control::
      signalId (const signalId_type& x)
      {
        this->signalId_.set (x);
      }

      void t_controller_control::
      signalId (::std::unique_ptr< signalId_type > x)
      {
        this->signalId_.set (std::move (x));
      }

      const t_controller_control::type_optional& t_controller_control::
      type () const
      {
        return this->type_;
      }

      t_controller_control::type_optional& t_controller_control::
      type ()
      {
        return this->type_;
      }

      void t_controller_control::
      type (const type_type& x)
      {
        this->type_.set (x);
      }

      void t_controller_control::
      type (const type_optional& x)
      {
        this->type_ = x;
      }

      void t_controller_control::
      type (::std::unique_ptr< type_type > x)
      {
        this->type_.set (std::move (x));
      }


      // t_road_signals
      // 

      const t_road_signals::signal_sequence& t_road_signals::
      signals_signal () const
      {
        return this->signals_signal_;
      }

      t_road_signals::signal_sequence& t_road_signals::
      signals_signal ()
      {
        return this->signals_signal_;
      }

      void t_road_signals::
      signals_signal (const signal_sequence& s)
      {
        this->signals_signal_ = s;
      }

      const t_road_signals::signalReference_sequence& t_road_signals::
      signalReference () const
      {
        return this->signalReference_;
      }

      t_road_signals::signalReference_sequence& t_road_signals::
      signalReference ()
      {
        return this->signalReference_;
      }

      void t_road_signals::
      signalReference (const signalReference_sequence& s)
      {
        this->signalReference_ = s;
      }

      const t_road_signals::include_sequence& t_road_signals::
      include () const
      {
        return this->include_;
      }

      t_road_signals::include_sequence& t_road_signals::
      include ()
      {
        return this->include_;
      }

      void t_road_signals::
      include (const include_sequence& s)
      {
        this->include_ = s;
      }

      const t_road_signals::userData_sequence& t_road_signals::
      userData () const
      {
        return this->userData_;
      }

      t_road_signals::userData_sequence& t_road_signals::
      userData ()
      {
        return this->userData_;
      }

      void t_road_signals::
      userData (const userData_sequence& s)
      {
        this->userData_ = s;
      }

      const t_road_signals::dataQuality_sequence& t_road_signals::
      dataQuality () const
      {
        return this->dataQuality_;
      }

      t_road_signals::dataQuality_sequence& t_road_signals::
      dataQuality ()
      {
        return this->dataQuality_;
      }

      void t_road_signals::
      dataQuality (const dataQuality_sequence& s)
      {
        this->dataQuality_ = s;
      }


      // t_road_signals_signal
      // 

      const t_road_signals_signal::validity_sequence& t_road_signals_signal::
      validity () const
      {
        return this->validity_;
      }

      t_road_signals_signal::validity_sequence& t_road_signals_signal::
      validity ()
      {
        return this->validity_;
      }

      void t_road_signals_signal::
      validity (const validity_sequence& s)
      {
        this->validity_ = s;
      }

      const t_road_signals_signal::dependency_sequence& t_road_signals_signal::
      dependency () const
      {
        return this->dependency_;
      }

      t_road_signals_signal::dependency_sequence& t_road_signals_signal::
      dependency ()
      {
        return this->dependency_;
      }

      void t_road_signals_signal::
      dependency (const dependency_sequence& s)
      {
        this->dependency_ = s;
      }

      const t_road_signals_signal::reference_sequence& t_road_signals_signal::
      reference () const
      {
        return this->reference_;
      }

      t_road_signals_signal::reference_sequence& t_road_signals_signal::
      reference ()
      {
        return this->reference_;
      }

      void t_road_signals_signal::
      reference (const reference_sequence& s)
      {
        this->reference_ = s;
      }

      const t_road_signals_signal::positionRoad_optional& t_road_signals_signal::
      positionRoad () const
      {
        return this->positionRoad_;
      }

      t_road_signals_signal::positionRoad_optional& t_road_signals_signal::
      positionRoad ()
      {
        return this->positionRoad_;
      }

      void t_road_signals_signal::
      positionRoad (const positionRoad_type& x)
      {
        this->positionRoad_.set (x);
      }

      void t_road_signals_signal::
      positionRoad (const positionRoad_optional& x)
      {
        this->positionRoad_ = x;
      }

      void t_road_signals_signal::
      positionRoad (::std::unique_ptr< positionRoad_type > x)
      {
        this->positionRoad_.set (std::move (x));
      }

      const t_road_signals_signal::positionInertial_optional& t_road_signals_signal::
      positionInertial () const
      {
        return this->positionInertial_;
      }

      t_road_signals_signal::positionInertial_optional& t_road_signals_signal::
      positionInertial ()
      {
        return this->positionInertial_;
      }

      void t_road_signals_signal::
      positionInertial (const positionInertial_type& x)
      {
        this->positionInertial_.set (x);
      }

      void t_road_signals_signal::
      positionInertial (const positionInertial_optional& x)
      {
        this->positionInertial_ = x;
      }

      void t_road_signals_signal::
      positionInertial (::std::unique_ptr< positionInertial_type > x)
      {
        this->positionInertial_.set (std::move (x));
      }

      const t_road_signals_signal::include_sequence& t_road_signals_signal::
      include () const
      {
        return this->include_;
      }

      t_road_signals_signal::include_sequence& t_road_signals_signal::
      include ()
      {
        return this->include_;
      }

      void t_road_signals_signal::
      include (const include_sequence& s)
      {
        this->include_ = s;
      }

      const t_road_signals_signal::userData_sequence& t_road_signals_signal::
      userData () const
      {
        return this->userData_;
      }

      t_road_signals_signal::userData_sequence& t_road_signals_signal::
      userData ()
      {
        return this->userData_;
      }

      void t_road_signals_signal::
      userData (const userData_sequence& s)
      {
        this->userData_ = s;
      }

      const t_road_signals_signal::dataQuality_sequence& t_road_signals_signal::
      dataQuality () const
      {
        return this->dataQuality_;
      }

      t_road_signals_signal::dataQuality_sequence& t_road_signals_signal::
      dataQuality ()
      {
        return this->dataQuality_;
      }

      void t_road_signals_signal::
      dataQuality (const dataQuality_sequence& s)
      {
        this->dataQuality_ = s;
      }

      const t_road_signals_signal::s_type& t_road_signals_signal::
      s () const
      {
        return this->s_.get ();
      }

      t_road_signals_signal::s_type& t_road_signals_signal::
      s ()
      {
        return this->s_.get ();
      }

      void t_road_signals_signal::
      s (const s_type& x)
      {
        this->s_.set (x);
      }

      void t_road_signals_signal::
      s (::std::unique_ptr< s_type > x)
      {
        this->s_.set (std::move (x));
      }

      const t_road_signals_signal::t_type& t_road_signals_signal::
      t () const
      {
        return this->t_.get ();
      }

      t_road_signals_signal::t_type& t_road_signals_signal::
      t ()
      {
        return this->t_.get ();
      }

      void t_road_signals_signal::
      t (const t_type& x)
      {
        this->t_.set (x);
      }

      const t_road_signals_signal::id_type& t_road_signals_signal::
      id () const
      {
        return this->id_.get ();
      }

      t_road_signals_signal::id_type& t_road_signals_signal::
      id ()
      {
        return this->id_.get ();
      }

      void t_road_signals_signal::
      id (const id_type& x)
      {
        this->id_.set (x);
      }

      void t_road_signals_signal::
      id (::std::unique_ptr< id_type > x)
      {
        this->id_.set (std::move (x));
      }

      const t_road_signals_signal::name_optional& t_road_signals_signal::
      name () const
      {
        return this->name_;
      }

      t_road_signals_signal::name_optional& t_road_signals_signal::
      name ()
      {
        return this->name_;
      }

      void t_road_signals_signal::
      name (const name_type& x)
      {
        this->name_.set (x);
      }

      void t_road_signals_signal::
      name (const name_optional& x)
      {
        this->name_ = x;
      }

      void t_road_signals_signal::
      name (::std::unique_ptr< name_type > x)
      {
        this->name_.set (std::move (x));
      }

      const t_road_signals_signal::dynamic_type& t_road_signals_signal::
      dynamic () const
      {
        return this->dynamic_.get ();
      }

      t_road_signals_signal::dynamic_type& t_road_signals_signal::
      dynamic ()
      {
        return this->dynamic_.get ();
      }

      void t_road_signals_signal::
      dynamic (const dynamic_type& x)
      {
        this->dynamic_.set (x);
      }

      void t_road_signals_signal::
      dynamic (::std::unique_ptr< dynamic_type > x)
      {
        this->dynamic_.set (std::move (x));
      }

      const t_road_signals_signal::orientation_type& t_road_signals_signal::
      orientation () const
      {
        return this->orientation_.get ();
      }

      t_road_signals_signal::orientation_type& t_road_signals_signal::
      orientation ()
      {
        return this->orientation_.get ();
      }

      void t_road_signals_signal::
      orientation (const orientation_type& x)
      {
        this->orientation_.set (x);
      }

      void t_road_signals_signal::
      orientation (::std::unique_ptr< orientation_type > x)
      {
        this->orientation_.set (std::move (x));
      }

      const t_road_signals_signal::zOffset_type& t_road_signals_signal::
      zOffset () const
      {
        return this->zOffset_.get ();
      }

      t_road_signals_signal::zOffset_type& t_road_signals_signal::
      zOffset ()
      {
        return this->zOffset_.get ();
      }

      void t_road_signals_signal::
      zOffset (const zOffset_type& x)
      {
        this->zOffset_.set (x);
      }

      const t_road_signals_signal::country_optional& t_road_signals_signal::
      country () const
      {
        return this->country_;
      }

      t_road_signals_signal::country_optional& t_road_signals_signal::
      country ()
      {
        return this->country_;
      }

      void t_road_signals_signal::
      country (const country_type& x)
      {
        this->country_.set (x);
      }

      void t_road_signals_signal::
      country (const country_optional& x)
      {
        this->country_ = x;
      }

      void t_road_signals_signal::
      country (::std::unique_ptr< country_type > x)
      {
        this->country_.set (std::move (x));
      }

      const t_road_signals_signal::countryRevision_optional& t_road_signals_signal::
      countryRevision () const
      {
        return this->countryRevision_;
      }

      t_road_signals_signal::countryRevision_optional& t_road_signals_signal::
      countryRevision ()
      {
        return this->countryRevision_;
      }

      void t_road_signals_signal::
      countryRevision (const countryRevision_type& x)
      {
        this->countryRevision_.set (x);
      }

      void t_road_signals_signal::
      countryRevision (const countryRevision_optional& x)
      {
        this->countryRevision_ = x;
      }

      void t_road_signals_signal::
      countryRevision (::std::unique_ptr< countryRevision_type > x)
      {
        this->countryRevision_.set (std::move (x));
      }

      const t_road_signals_signal::type_type& t_road_signals_signal::
      type () const
      {
        return this->type_.get ();
      }

      t_road_signals_signal::type_type& t_road_signals_signal::
      type ()
      {
        return this->type_.get ();
      }

      void t_road_signals_signal::
      type (const type_type& x)
      {
        this->type_.set (x);
      }

      void t_road_signals_signal::
      type (::std::unique_ptr< type_type > x)
      {
        this->type_.set (std::move (x));
      }

      const t_road_signals_signal::subtype_type& t_road_signals_signal::
      subtype () const
      {
        return this->subtype_.get ();
      }

      t_road_signals_signal::subtype_type& t_road_signals_signal::
      subtype ()
      {
        return this->subtype_.get ();
      }

      void t_road_signals_signal::
      subtype (const subtype_type& x)
      {
        this->subtype_.set (x);
      }

      void t_road_signals_signal::
      subtype (::std::unique_ptr< subtype_type > x)
      {
        this->subtype_.set (std::move (x));
      }

      const t_road_signals_signal::value_optional& t_road_signals_signal::
      value () const
      {
        return this->value_;
      }

      t_road_signals_signal::value_optional& t_road_signals_signal::
      value ()
      {
        return this->value_;
      }

      void t_road_signals_signal::
      value (const value_type& x)
      {
        this->value_.set (x);
      }

      void t_road_signals_signal::
      value (const value_optional& x)
      {
        this->value_ = x;
      }

      const t_road_signals_signal::unit_optional& t_road_signals_signal::
      unit () const
      {
        return this->unit_;
      }

      t_road_signals_signal::unit_optional& t_road_signals_signal::
      unit ()
      {
        return this->unit_;
      }

      void t_road_signals_signal::
      unit (const unit_type& x)
      {
        this->unit_.set (x);
      }

      void t_road_signals_signal::
      unit (const unit_optional& x)
      {
        this->unit_ = x;
      }

      void t_road_signals_signal::
      unit (::std::unique_ptr< unit_type > x)
      {
        this->unit_.set (std::move (x));
      }

      const t_road_signals_signal::height_optional& t_road_signals_signal::
      height () const
      {
        return this->height_;
      }

      t_road_signals_signal::height_optional& t_road_signals_signal::
      height ()
      {
        return this->height_;
      }

      void t_road_signals_signal::
      height (const height_type& x)
      {
        this->height_.set (x);
      }

      void t_road_signals_signal::
      height (const height_optional& x)
      {
        this->height_ = x;
      }

      void t_road_signals_signal::
      height (::std::unique_ptr< height_type > x)
      {
        this->height_.set (std::move (x));
      }

      const t_road_signals_signal::width_optional& t_road_signals_signal::
      width () const
      {
        return this->width_;
      }

      t_road_signals_signal::width_optional& t_road_signals_signal::
      width ()
      {
        return this->width_;
      }

      void t_road_signals_signal::
      width (const width_type& x)
      {
        this->width_.set (x);
      }

      void t_road_signals_signal::
      width (const width_optional& x)
      {
        this->width_ = x;
      }

      void t_road_signals_signal::
      width (::std::unique_ptr< width_type > x)
      {
        this->width_.set (std::move (x));
      }

      const t_road_signals_signal::text_optional& t_road_signals_signal::
      text () const
      {
        return this->text_;
      }

      t_road_signals_signal::text_optional& t_road_signals_signal::
      text ()
      {
        return this->text_;
      }

      void t_road_signals_signal::
      text (const text_type& x)
      {
        this->text_.set (x);
      }

      void t_road_signals_signal::
      text (const text_optional& x)
      {
        this->text_ = x;
      }

      void t_road_signals_signal::
      text (::std::unique_ptr< text_type > x)
      {
        this->text_.set (std::move (x));
      }

      const t_road_signals_signal::hOffset_optional& t_road_signals_signal::
      hOffset () const
      {
        return this->hOffset_;
      }

      t_road_signals_signal::hOffset_optional& t_road_signals_signal::
      hOffset ()
      {
        return this->hOffset_;
      }

      void t_road_signals_signal::
      hOffset (const hOffset_type& x)
      {
        this->hOffset_.set (x);
      }

      void t_road_signals_signal::
      hOffset (const hOffset_optional& x)
      {
        this->hOffset_ = x;
      }

      const t_road_signals_signal::pitch_optional& t_road_signals_signal::
      pitch () const
      {
        return this->pitch_;
      }

      t_road_signals_signal::pitch_optional& t_road_signals_signal::
      pitch ()
      {
        return this->pitch_;
      }

      void t_road_signals_signal::
      pitch (const pitch_type& x)
      {
        this->pitch_.set (x);
      }

      void t_road_signals_signal::
      pitch (const pitch_optional& x)
      {
        this->pitch_ = x;
      }

      const t_road_signals_signal::roll_optional& t_road_signals_signal::
      roll () const
      {
        return this->roll_;
      }

      t_road_signals_signal::roll_optional& t_road_signals_signal::
      roll ()
      {
        return this->roll_;
      }

      void t_road_signals_signal::
      roll (const roll_type& x)
      {
        this->roll_.set (x);
      }

      void t_road_signals_signal::
      roll (const roll_optional& x)
      {
        this->roll_ = x;
      }


      // t_road_signals_signal_dependency
      // 

      const t_road_signals_signal_dependency::id_type& t_road_signals_signal_dependency::
      id () const
      {
        return this->id_.get ();
      }

      t_road_signals_signal_dependency::id_type& t_road_signals_signal_dependency::
      id ()
      {
        return this->id_.get ();
      }

      void t_road_signals_signal_dependency::
      id (const id_type& x)
      {
        this->id_.set (x);
      }

      void t_road_signals_signal_dependency::
      id (::std::unique_ptr< id_type > x)
      {
        this->id_.set (std::move (x));
      }

      const t_road_signals_signal_dependency::type_optional& t_road_signals_signal_dependency::
      type () const
      {
        return this->type_;
      }

      t_road_signals_signal_dependency::type_optional& t_road_signals_signal_dependency::
      type ()
      {
        return this->type_;
      }

      void t_road_signals_signal_dependency::
      type (const type_type& x)
      {
        this->type_.set (x);
      }

      void t_road_signals_signal_dependency::
      type (const type_optional& x)
      {
        this->type_ = x;
      }

      void t_road_signals_signal_dependency::
      type (::std::unique_ptr< type_type > x)
      {
        this->type_.set (std::move (x));
      }


      // t_road_signals_signal_positionInertial
      // 

      const t_road_signals_signal_positionInertial::x_type& t_road_signals_signal_positionInertial::
      x () const
      {
        return this->x_.get ();
      }

      t_road_signals_signal_positionInertial::x_type& t_road_signals_signal_positionInertial::
      x ()
      {
        return this->x_.get ();
      }

      void t_road_signals_signal_positionInertial::
      x (const x_type& x)
      {
        this->x_.set (x);
      }

      const t_road_signals_signal_positionInertial::y_type& t_road_signals_signal_positionInertial::
      y () const
      {
        return this->y_.get ();
      }

      t_road_signals_signal_positionInertial::y_type& t_road_signals_signal_positionInertial::
      y ()
      {
        return this->y_.get ();
      }

      void t_road_signals_signal_positionInertial::
      y (const y_type& x)
      {
        this->y_.set (x);
      }

      const t_road_signals_signal_positionInertial::z_type& t_road_signals_signal_positionInertial::
      z () const
      {
        return this->z_.get ();
      }

      t_road_signals_signal_positionInertial::z_type& t_road_signals_signal_positionInertial::
      z ()
      {
        return this->z_.get ();
      }

      void t_road_signals_signal_positionInertial::
      z (const z_type& x)
      {
        this->z_.set (x);
      }

      const t_road_signals_signal_positionInertial::hdg_type& t_road_signals_signal_positionInertial::
      hdg () const
      {
        return this->hdg_.get ();
      }

      t_road_signals_signal_positionInertial::hdg_type& t_road_signals_signal_positionInertial::
      hdg ()
      {
        return this->hdg_.get ();
      }

      void t_road_signals_signal_positionInertial::
      hdg (const hdg_type& x)
      {
        this->hdg_.set (x);
      }

      const t_road_signals_signal_positionInertial::pitch_optional& t_road_signals_signal_positionInertial::
      pitch () const
      {
        return this->pitch_;
      }

      t_road_signals_signal_positionInertial::pitch_optional& t_road_signals_signal_positionInertial::
      pitch ()
      {
        return this->pitch_;
      }

      void t_road_signals_signal_positionInertial::
      pitch (const pitch_type& x)
      {
        this->pitch_.set (x);
      }

      void t_road_signals_signal_positionInertial::
      pitch (const pitch_optional& x)
      {
        this->pitch_ = x;
      }

      const t_road_signals_signal_positionInertial::roll_optional& t_road_signals_signal_positionInertial::
      roll () const
      {
        return this->roll_;
      }

      t_road_signals_signal_positionInertial::roll_optional& t_road_signals_signal_positionInertial::
      roll ()
      {
        return this->roll_;
      }

      void t_road_signals_signal_positionInertial::
      roll (const roll_type& x)
      {
        this->roll_.set (x);
      }

      void t_road_signals_signal_positionInertial::
      roll (const roll_optional& x)
      {
        this->roll_ = x;
      }


      // t_road_signals_signal_positionRoad
      // 

      const t_road_signals_signal_positionRoad::roadId_type& t_road_signals_signal_positionRoad::
      roadId () const
      {
        return this->roadId_.get ();
      }

      t_road_signals_signal_positionRoad::roadId_type& t_road_signals_signal_positionRoad::
      roadId ()
      {
        return this->roadId_.get ();
      }

      void t_road_signals_signal_positionRoad::
      roadId (const roadId_type& x)
      {
        this->roadId_.set (x);
      }

      void t_road_signals_signal_positionRoad::
      roadId (::std::unique_ptr< roadId_type > x)
      {
        this->roadId_.set (std::move (x));
      }

      const t_road_signals_signal_positionRoad::s_type& t_road_signals_signal_positionRoad::
      s () const
      {
        return this->s_.get ();
      }

      t_road_signals_signal_positionRoad::s_type& t_road_signals_signal_positionRoad::
      s ()
      {
        return this->s_.get ();
      }

      void t_road_signals_signal_positionRoad::
      s (const s_type& x)
      {
        this->s_.set (x);
      }

      void t_road_signals_signal_positionRoad::
      s (::std::unique_ptr< s_type > x)
      {
        this->s_.set (std::move (x));
      }

      const t_road_signals_signal_positionRoad::t_type& t_road_signals_signal_positionRoad::
      t () const
      {
        return this->t_.get ();
      }

      t_road_signals_signal_positionRoad::t_type& t_road_signals_signal_positionRoad::
      t ()
      {
        return this->t_.get ();
      }

      void t_road_signals_signal_positionRoad::
      t (const t_type& x)
      {
        this->t_.set (x);
      }

      const t_road_signals_signal_positionRoad::zOffset_type& t_road_signals_signal_positionRoad::
      zOffset () const
      {
        return this->zOffset_.get ();
      }

      t_road_signals_signal_positionRoad::zOffset_type& t_road_signals_signal_positionRoad::
      zOffset ()
      {
        return this->zOffset_.get ();
      }

      void t_road_signals_signal_positionRoad::
      zOffset (const zOffset_type& x)
      {
        this->zOffset_.set (x);
      }

      const t_road_signals_signal_positionRoad::hOffset_type& t_road_signals_signal_positionRoad::
      hOffset () const
      {
        return this->hOffset_.get ();
      }

      t_road_signals_signal_positionRoad::hOffset_type& t_road_signals_signal_positionRoad::
      hOffset ()
      {
        return this->hOffset_.get ();
      }

      void t_road_signals_signal_positionRoad::
      hOffset (const hOffset_type& x)
      {
        this->hOffset_.set (x);
      }

      const t_road_signals_signal_positionRoad::pitch_optional& t_road_signals_signal_positionRoad::
      pitch () const
      {
        return this->pitch_;
      }

      t_road_signals_signal_positionRoad::pitch_optional& t_road_signals_signal_positionRoad::
      pitch ()
      {
        return this->pitch_;
      }

      void t_road_signals_signal_positionRoad::
      pitch (const pitch_type& x)
      {
        this->pitch_.set (x);
      }

      void t_road_signals_signal_positionRoad::
      pitch (const pitch_optional& x)
      {
        this->pitch_ = x;
      }

      const t_road_signals_signal_positionRoad::roll_optional& t_road_signals_signal_positionRoad::
      roll () const
      {
        return this->roll_;
      }

      t_road_signals_signal_positionRoad::roll_optional& t_road_signals_signal_positionRoad::
      roll ()
      {
        return this->roll_;
      }

      void t_road_signals_signal_positionRoad::
      roll (const roll_type& x)
      {
        this->roll_.set (x);
      }

      void t_road_signals_signal_positionRoad::
      roll (const roll_optional& x)
      {
        this->roll_ = x;
      }


      // t_road_signals_signal_reference
      // 

      const t_road_signals_signal_reference::elementType_type& t_road_signals_signal_reference::
      elementType () const
      {
        return this->elementType_.get ();
      }

      t_road_signals_signal_reference::elementType_type& t_road_signals_signal_reference::
      elementType ()
      {
        return this->elementType_.get ();
      }

      void t_road_signals_signal_reference::
      elementType (const elementType_type& x)
      {
        this->elementType_.set (x);
      }

      void t_road_signals_signal_reference::
      elementType (::std::unique_ptr< elementType_type > x)
      {
        this->elementType_.set (std::move (x));
      }

      const t_road_signals_signal_reference::elementId_type& t_road_signals_signal_reference::
      elementId () const
      {
        return this->elementId_.get ();
      }

      t_road_signals_signal_reference::elementId_type& t_road_signals_signal_reference::
      elementId ()
      {
        return this->elementId_.get ();
      }

      void t_road_signals_signal_reference::
      elementId (const elementId_type& x)
      {
        this->elementId_.set (x);
      }

      void t_road_signals_signal_reference::
      elementId (::std::unique_ptr< elementId_type > x)
      {
        this->elementId_.set (std::move (x));
      }

      const t_road_signals_signal_reference::type_optional& t_road_signals_signal_reference::
      type () const
      {
        return this->type_;
      }

      t_road_signals_signal_reference::type_optional& t_road_signals_signal_reference::
      type ()
      {
        return this->type_;
      }

      void t_road_signals_signal_reference::
      type (const type_type& x)
      {
        this->type_.set (x);
      }

      void t_road_signals_signal_reference::
      type (const type_optional& x)
      {
        this->type_ = x;
      }

      void t_road_signals_signal_reference::
      type (::std::unique_ptr< type_type > x)
      {
        this->type_.set (std::move (x));
      }


      // t_road_signals_signalReference
      // 

      const t_road_signals_signalReference::validity_sequence& t_road_signals_signalReference::
      validity () const
      {
        return this->validity_;
      }

      t_road_signals_signalReference::validity_sequence& t_road_signals_signalReference::
      validity ()
      {
        return this->validity_;
      }

      void t_road_signals_signalReference::
      validity (const validity_sequence& s)
      {
        this->validity_ = s;
      }

      const t_road_signals_signalReference::include_sequence& t_road_signals_signalReference::
      include () const
      {
        return this->include_;
      }

      t_road_signals_signalReference::include_sequence& t_road_signals_signalReference::
      include ()
      {
        return this->include_;
      }

      void t_road_signals_signalReference::
      include (const include_sequence& s)
      {
        this->include_ = s;
      }

      const t_road_signals_signalReference::userData_sequence& t_road_signals_signalReference::
      userData () const
      {
        return this->userData_;
      }

      t_road_signals_signalReference::userData_sequence& t_road_signals_signalReference::
      userData ()
      {
        return this->userData_;
      }

      void t_road_signals_signalReference::
      userData (const userData_sequence& s)
      {
        this->userData_ = s;
      }

      const t_road_signals_signalReference::dataQuality_sequence& t_road_signals_signalReference::
      dataQuality () const
      {
        return this->dataQuality_;
      }

      t_road_signals_signalReference::dataQuality_sequence& t_road_signals_signalReference::
      dataQuality ()
      {
        return this->dataQuality_;
      }

      void t_road_signals_signalReference::
      dataQuality (const dataQuality_sequence& s)
      {
        this->dataQuality_ = s;
      }

      const t_road_signals_signalReference::s_type& t_road_signals_signalReference::
      s () const
      {
        return this->s_.get ();
      }

      t_road_signals_signalReference::s_type& t_road_signals_signalReference::
      s ()
      {
        return this->s_.get ();
      }

      void t_road_signals_signalReference::
      s (const s_type& x)
      {
        this->s_.set (x);
      }

      void t_road_signals_signalReference::
      s (::std::unique_ptr< s_type > x)
      {
        this->s_.set (std::move (x));
      }

      const t_road_signals_signalReference::t_type& t_road_signals_signalReference::
      t () const
      {
        return this->t_.get ();
      }

      t_road_signals_signalReference::t_type& t_road_signals_signalReference::
      t ()
      {
        return this->t_.get ();
      }

      void t_road_signals_signalReference::
      t (const t_type& x)
      {
        this->t_.set (x);
      }

      const t_road_signals_signalReference::id_type& t_road_signals_signalReference::
      id () const
      {
        return this->id_.get ();
      }

      t_road_signals_signalReference::id_type& t_road_signals_signalReference::
      id ()
      {
        return this->id_.get ();
      }

      void t_road_signals_signalReference::
      id (const id_type& x)
      {
        this->id_.set (x);
      }

      void t_road_signals_signalReference::
      id (::std::unique_ptr< id_type > x)
      {
        this->id_.set (std::move (x));
      }

      const t_road_signals_signalReference::orientation_type& t_road_signals_signalReference::
      orientation () const
      {
        return this->orientation_.get ();
      }

      t_road_signals_signalReference::orientation_type& t_road_signals_signalReference::
      orientation ()
      {
        return this->orientation_.get ();
      }

      void t_road_signals_signalReference::
      orientation (const orientation_type& x)
      {
        this->orientation_.set (x);
      }

      void t_road_signals_signalReference::
      orientation (::std::unique_ptr< orientation_type > x)
      {
        this->orientation_.set (std::move (x));
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace simulation
{
  namespace standard
  {
    namespace opendrive_schema
    {
      // e_road_signals_signal_reference_elementType
      //

      e_road_signals_signal_reference_elementType::
      e_road_signals_signal_reference_elementType (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_e_road_signals_signal_reference_elementType_convert ();
      }

      e_road_signals_signal_reference_elementType::
      e_road_signals_signal_reference_elementType (const ::xercesc::DOMAttr& a,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_e_road_signals_signal_reference_elementType_convert ();
      }

      e_road_signals_signal_reference_elementType::
      e_road_signals_signal_reference_elementType (const ::std::string& s,
                                                   const ::xercesc::DOMElement* e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_e_road_signals_signal_reference_elementType_convert ();
      }

      e_road_signals_signal_reference_elementType* e_road_signals_signal_reference_elementType::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class e_road_signals_signal_reference_elementType (*this, f, c);
      }

      e_road_signals_signal_reference_elementType::value e_road_signals_signal_reference_elementType::
      _xsd_e_road_signals_signal_reference_elementType_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_signals_signal_reference_elementType_literals_);
        const value* i (::std::lower_bound (
                          _xsd_e_road_signals_signal_reference_elementType_indexes_,
                          _xsd_e_road_signals_signal_reference_elementType_indexes_ + 2,
                          *this,
                          c));

        if (i == _xsd_e_road_signals_signal_reference_elementType_indexes_ + 2 || _xsd_e_road_signals_signal_reference_elementType_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const e_road_signals_signal_reference_elementType::
      _xsd_e_road_signals_signal_reference_elementType_literals_[2] =
      {
        "object",
        "signal"
      };

      const e_road_signals_signal_reference_elementType::value e_road_signals_signal_reference_elementType::
      _xsd_e_road_signals_signal_reference_elementType_indexes_[2] =
      {
        ::simulation::standard::opendrive_schema::e_road_signals_signal_reference_elementType::object,
        ::simulation::standard::opendrive_schema::e_road_signals_signal_reference_elementType::signals_signal
      };

      // t_controller
      //

      t_controller::
      t_controller (const id_type& id)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        control_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        id_ (id, this),
        name_ (this),
        sequence_ (this)
      {
      }

      t_controller::
      t_controller (const t_controller& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        control_ (x.control_, f, this),
        include_ (x.include_, f, this),
        userData_ (x.userData_, f, this),
        dataQuality_ (x.dataQuality_, f, this),
        id_ (x.id_, f, this),
        name_ (x.name_, f, this),
        sequence_ (x.sequence_, f, this)
      {
      }

      t_controller::
      t_controller (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        control_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        id_ (this),
        name_ (this),
        sequence_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void t_controller::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // control
          //
          if (n.name () == "control" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< control_type > r (
              control_traits::create (i, f, this));

            this->control_.push_back (::std::move (r));
            continue;
          }

          // include
          //
          if (n.name () == "include" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< include_type > r (
              include_traits::create (i, f, this));

            this->include_.push_back (::std::move (r));
            continue;
          }

          // userData
          //
          if (n.name () == "userData" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< userData_type > r (
              userData_traits::create (i, f, this));

            this->userData_.push_back (::std::move (r));
            continue;
          }

          // dataQuality
          //
          if (n.name () == "dataQuality" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< dataQuality_type > r (
              dataQuality_traits::create (i, f, this));

            this->dataQuality_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (id_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            this->name_.set (name_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "sequence" && n.namespace_ ().empty ())
          {
            this->sequence_.set (sequence_traits::create (i, f, this));
            continue;
          }
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "id",
            "");
        }
      }

      t_controller* t_controller::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_controller (*this, f, c);
      }

      t_controller& t_controller::
      operator= (const t_controller& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->control_ = x.control_;
          this->include_ = x.include_;
          this->userData_ = x.userData_;
          this->dataQuality_ = x.dataQuality_;
          this->id_ = x.id_;
          this->name_ = x.name_;
          this->sequence_ = x.sequence_;
        }

        return *this;
      }

      t_controller::
      ~t_controller ()
      {
      }

      // t_controller_control
      //

      t_controller_control::
      t_controller_control (const signalId_type& signalId)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        signalId_ (signalId, this),
        type_ (this)
      {
      }

      t_controller_control::
      t_controller_control (const t_controller_control& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        signalId_ (x.signalId_, f, this),
        type_ (x.type_, f, this)
      {
      }

      t_controller_control::
      t_controller_control (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        signalId_ (this),
        type_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void t_controller_control::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "signalId" && n.namespace_ ().empty ())
          {
            this->signalId_.set (signalId_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "type" && n.namespace_ ().empty ())
          {
            this->type_.set (type_traits::create (i, f, this));
            continue;
          }
        }

        if (!signalId_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "signalId",
            "");
        }
      }

      t_controller_control* t_controller_control::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_controller_control (*this, f, c);
      }

      t_controller_control& t_controller_control::
      operator= (const t_controller_control& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->signalId_ = x.signalId_;
          this->type_ = x.type_;
        }

        return *this;
      }

      t_controller_control::
      ~t_controller_control ()
      {
      }

      // t_road_signals
      //

      t_road_signals::
      t_road_signals ()
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        signals_signal_ (this),
        signalReference_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this)
      {
      }

      t_road_signals::
      t_road_signals (const t_road_signals& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        signals_signal_ (x.signals_signal_, f, this),
        signalReference_ (x.signalReference_, f, this),
        include_ (x.include_, f, this),
        userData_ (x.userData_, f, this),
        dataQuality_ (x.dataQuality_, f, this)
      {
      }

      t_road_signals::
      t_road_signals (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        signals_signal_ (this),
        signalReference_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void t_road_signals::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // signal
          //
          if (n.name () == "signal" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< signal_type > r (
              signal_traits::create (i, f, this));

            this->signals_signal_.push_back (::std::move (r));
            continue;
          }

          // signalReference
          //
          if (n.name () == "signalReference" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< signalReference_type > r (
              signalReference_traits::create (i, f, this));

            this->signalReference_.push_back (::std::move (r));
            continue;
          }

          // include
          //
          if (n.name () == "include" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< include_type > r (
              include_traits::create (i, f, this));

            this->include_.push_back (::std::move (r));
            continue;
          }

          // userData
          //
          if (n.name () == "userData" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< userData_type > r (
              userData_traits::create (i, f, this));

            this->userData_.push_back (::std::move (r));
            continue;
          }

          // dataQuality
          //
          if (n.name () == "dataQuality" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< dataQuality_type > r (
              dataQuality_traits::create (i, f, this));

            this->dataQuality_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      t_road_signals* t_road_signals::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_road_signals (*this, f, c);
      }

      t_road_signals& t_road_signals::
      operator= (const t_road_signals& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->signals_signal_ = x.signals_signal_;
          this->signalReference_ = x.signalReference_;
          this->include_ = x.include_;
          this->userData_ = x.userData_;
          this->dataQuality_ = x.dataQuality_;
        }

        return *this;
      }

      t_road_signals::
      ~t_road_signals ()
      {
      }

      // t_road_signals_signal
      //

      t_road_signals_signal::
      t_road_signals_signal (const s_type& s,
                             const t_type& t,
                             const id_type& id,
                             const dynamic_type& dynamic,
                             const orientation_type& orientation,
                             const zOffset_type& zOffset,
                             const type_type& type,
                             const subtype_type& subtype)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        validity_ (this),
        dependency_ (this),
        reference_ (this),
        positionRoad_ (this),
        positionInertial_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        s_ (s, this),
        t_ (t, this),
        id_ (id, this),
        name_ (this),
        dynamic_ (dynamic, this),
        orientation_ (orientation, this),
        zOffset_ (zOffset, this),
        country_ (this),
        countryRevision_ (this),
        type_ (type, this),
        subtype_ (subtype, this),
        value_ (this),
        unit_ (this),
        height_ (this),
        width_ (this),
        text_ (this),
        hOffset_ (this),
        pitch_ (this),
        roll_ (this)
      {
      }

      t_road_signals_signal::
      t_road_signals_signal (const t_road_signals_signal& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        validity_ (x.validity_, f, this),
        dependency_ (x.dependency_, f, this),
        reference_ (x.reference_, f, this),
        positionRoad_ (x.positionRoad_, f, this),
        positionInertial_ (x.positionInertial_, f, this),
        include_ (x.include_, f, this),
        userData_ (x.userData_, f, this),
        dataQuality_ (x.dataQuality_, f, this),
        s_ (x.s_, f, this),
        t_ (x.t_, f, this),
        id_ (x.id_, f, this),
        name_ (x.name_, f, this),
        dynamic_ (x.dynamic_, f, this),
        orientation_ (x.orientation_, f, this),
        zOffset_ (x.zOffset_, f, this),
        country_ (x.country_, f, this),
        countryRevision_ (x.countryRevision_, f, this),
        type_ (x.type_, f, this),
        subtype_ (x.subtype_, f, this),
        value_ (x.value_, f, this),
        unit_ (x.unit_, f, this),
        height_ (x.height_, f, this),
        width_ (x.width_, f, this),
        text_ (x.text_, f, this),
        hOffset_ (x.hOffset_, f, this),
        pitch_ (x.pitch_, f, this),
        roll_ (x.roll_, f, this)
      {
      }

      t_road_signals_signal::
      t_road_signals_signal (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        validity_ (this),
        dependency_ (this),
        reference_ (this),
        positionRoad_ (this),
        positionInertial_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        s_ (this),
        t_ (this),
        id_ (this),
        name_ (this),
        dynamic_ (this),
        orientation_ (this),
        zOffset_ (this),
        country_ (this),
        countryRevision_ (this),
        type_ (this),
        subtype_ (this),
        value_ (this),
        unit_ (this),
        height_ (this),
        width_ (this),
        text_ (this),
        hOffset_ (this),
        pitch_ (this),
        roll_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void t_road_signals_signal::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // validity
          //
          if (n.name () == "validity" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< validity_type > r (
              validity_traits::create (i, f, this));

            this->validity_.push_back (::std::move (r));
            continue;
          }

          // dependency
          //
          if (n.name () == "dependency" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< dependency_type > r (
              dependency_traits::create (i, f, this));

            this->dependency_.push_back (::std::move (r));
            continue;
          }

          // reference
          //
          if (n.name () == "reference" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< reference_type > r (
              reference_traits::create (i, f, this));

            this->reference_.push_back (::std::move (r));
            continue;
          }

          // positionRoad
          //
          if (n.name () == "positionRoad" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< positionRoad_type > r (
              positionRoad_traits::create (i, f, this));

            if (!this->positionRoad_)
            {
              this->positionRoad_.set (::std::move (r));
              continue;
            }
          }

          // positionInertial
          //
          if (n.name () == "positionInertial" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< positionInertial_type > r (
              positionInertial_traits::create (i, f, this));

            if (!this->positionInertial_)
            {
              this->positionInertial_.set (::std::move (r));
              continue;
            }
          }

          // include
          //
          if (n.name () == "include" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< include_type > r (
              include_traits::create (i, f, this));

            this->include_.push_back (::std::move (r));
            continue;
          }

          // userData
          //
          if (n.name () == "userData" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< userData_type > r (
              userData_traits::create (i, f, this));

            this->userData_.push_back (::std::move (r));
            continue;
          }

          // dataQuality
          //
          if (n.name () == "dataQuality" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< dataQuality_type > r (
              dataQuality_traits::create (i, f, this));

            this->dataQuality_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "s" && n.namespace_ ().empty ())
          {
            this->s_.set (s_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "t" && n.namespace_ ().empty ())
          {
            this->t_.set (t_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (id_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            this->name_.set (name_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "dynamic" && n.namespace_ ().empty ())
          {
            this->dynamic_.set (dynamic_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "orientation" && n.namespace_ ().empty ())
          {
            this->orientation_.set (orientation_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "zOffset" && n.namespace_ ().empty ())
          {
            this->zOffset_.set (zOffset_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "country" && n.namespace_ ().empty ())
          {
            this->country_.set (country_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "countryRevision" && n.namespace_ ().empty ())
          {
            this->countryRevision_.set (countryRevision_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "type" && n.namespace_ ().empty ())
          {
            this->type_.set (type_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "subtype" && n.namespace_ ().empty ())
          {
            this->subtype_.set (subtype_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "value" && n.namespace_ ().empty ())
          {
            this->value_.set (value_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "unit" && n.namespace_ ().empty ())
          {
            this->unit_.set (unit_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "height" && n.namespace_ ().empty ())
          {
            this->height_.set (height_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "width" && n.namespace_ ().empty ())
          {
            this->width_.set (width_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "text" && n.namespace_ ().empty ())
          {
            this->text_.set (text_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "hOffset" && n.namespace_ ().empty ())
          {
            this->hOffset_.set (hOffset_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "pitch" && n.namespace_ ().empty ())
          {
            this->pitch_.set (pitch_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "roll" && n.namespace_ ().empty ())
          {
            this->roll_.set (roll_traits::create (i, f, this));
            continue;
          }
        }

        if (!s_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "s",
            "");
        }

        if (!t_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "t",
            "");
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "id",
            "");
        }

        if (!dynamic_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "dynamic",
            "");
        }

        if (!orientation_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "orientation",
            "");
        }

        if (!zOffset_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "zOffset",
            "");
        }

        if (!type_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "type",
            "");
        }

        if (!subtype_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "subtype",
            "");
        }
      }

      t_road_signals_signal* t_road_signals_signal::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_road_signals_signal (*this, f, c);
      }

      t_road_signals_signal& t_road_signals_signal::
      operator= (const t_road_signals_signal& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->validity_ = x.validity_;
          this->dependency_ = x.dependency_;
          this->reference_ = x.reference_;
          this->positionRoad_ = x.positionRoad_;
          this->positionInertial_ = x.positionInertial_;
          this->include_ = x.include_;
          this->userData_ = x.userData_;
          this->dataQuality_ = x.dataQuality_;
          this->s_ = x.s_;
          this->t_ = x.t_;
          this->id_ = x.id_;
          this->name_ = x.name_;
          this->dynamic_ = x.dynamic_;
          this->orientation_ = x.orientation_;
          this->zOffset_ = x.zOffset_;
          this->country_ = x.country_;
          this->countryRevision_ = x.countryRevision_;
          this->type_ = x.type_;
          this->subtype_ = x.subtype_;
          this->value_ = x.value_;
          this->unit_ = x.unit_;
          this->height_ = x.height_;
          this->width_ = x.width_;
          this->text_ = x.text_;
          this->hOffset_ = x.hOffset_;
          this->pitch_ = x.pitch_;
          this->roll_ = x.roll_;
        }

        return *this;
      }

      t_road_signals_signal::
      ~t_road_signals_signal ()
      {
      }

      // t_road_signals_signal_dependency
      //

      t_road_signals_signal_dependency::
      t_road_signals_signal_dependency (const id_type& id)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        id_ (id, this),
        type_ (this)
      {
      }

      t_road_signals_signal_dependency::
      t_road_signals_signal_dependency (const t_road_signals_signal_dependency& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        id_ (x.id_, f, this),
        type_ (x.type_, f, this)
      {
      }

      t_road_signals_signal_dependency::
      t_road_signals_signal_dependency (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        id_ (this),
        type_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void t_road_signals_signal_dependency::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (id_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "type" && n.namespace_ ().empty ())
          {
            this->type_.set (type_traits::create (i, f, this));
            continue;
          }
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "id",
            "");
        }
      }

      t_road_signals_signal_dependency* t_road_signals_signal_dependency::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_road_signals_signal_dependency (*this, f, c);
      }

      t_road_signals_signal_dependency& t_road_signals_signal_dependency::
      operator= (const t_road_signals_signal_dependency& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->id_ = x.id_;
          this->type_ = x.type_;
        }

        return *this;
      }

      t_road_signals_signal_dependency::
      ~t_road_signals_signal_dependency ()
      {
      }

      // t_road_signals_signal_positionInertial
      //

      t_road_signals_signal_positionInertial::
      t_road_signals_signal_positionInertial (const x_type& x,
                                              const y_type& y,
                                              const z_type& z,
                                              const hdg_type& hdg)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        x_ (x, this),
        y_ (y, this),
        z_ (z, this),
        hdg_ (hdg, this),
        pitch_ (this),
        roll_ (this)
      {
      }

      t_road_signals_signal_positionInertial::
      t_road_signals_signal_positionInertial (const t_road_signals_signal_positionInertial& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        x_ (x.x_, f, this),
        y_ (x.y_, f, this),
        z_ (x.z_, f, this),
        hdg_ (x.hdg_, f, this),
        pitch_ (x.pitch_, f, this),
        roll_ (x.roll_, f, this)
      {
      }

      t_road_signals_signal_positionInertial::
      t_road_signals_signal_positionInertial (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        x_ (this),
        y_ (this),
        z_ (this),
        hdg_ (this),
        pitch_ (this),
        roll_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void t_road_signals_signal_positionInertial::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "x" && n.namespace_ ().empty ())
          {
            this->x_.set (x_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "y" && n.namespace_ ().empty ())
          {
            this->y_.set (y_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "z" && n.namespace_ ().empty ())
          {
            this->z_.set (z_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "hdg" && n.namespace_ ().empty ())
          {
            this->hdg_.set (hdg_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "pitch" && n.namespace_ ().empty ())
          {
            this->pitch_.set (pitch_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "roll" && n.namespace_ ().empty ())
          {
            this->roll_.set (roll_traits::create (i, f, this));
            continue;
          }
        }

        if (!x_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "x",
            "");
        }

        if (!y_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "y",
            "");
        }

        if (!z_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "z",
            "");
        }

        if (!hdg_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "hdg",
            "");
        }
      }

      t_road_signals_signal_positionInertial* t_road_signals_signal_positionInertial::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_road_signals_signal_positionInertial (*this, f, c);
      }

      t_road_signals_signal_positionInertial& t_road_signals_signal_positionInertial::
      operator= (const t_road_signals_signal_positionInertial& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->x_ = x.x_;
          this->y_ = x.y_;
          this->z_ = x.z_;
          this->hdg_ = x.hdg_;
          this->pitch_ = x.pitch_;
          this->roll_ = x.roll_;
        }

        return *this;
      }

      t_road_signals_signal_positionInertial::
      ~t_road_signals_signal_positionInertial ()
      {
      }

      // t_road_signals_signal_positionRoad
      //

      t_road_signals_signal_positionRoad::
      t_road_signals_signal_positionRoad (const roadId_type& roadId,
                                          const s_type& s,
                                          const t_type& t,
                                          const zOffset_type& zOffset,
                                          const hOffset_type& hOffset)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        roadId_ (roadId, this),
        s_ (s, this),
        t_ (t, this),
        zOffset_ (zOffset, this),
        hOffset_ (hOffset, this),
        pitch_ (this),
        roll_ (this)
      {
      }

      t_road_signals_signal_positionRoad::
      t_road_signals_signal_positionRoad (const t_road_signals_signal_positionRoad& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        roadId_ (x.roadId_, f, this),
        s_ (x.s_, f, this),
        t_ (x.t_, f, this),
        zOffset_ (x.zOffset_, f, this),
        hOffset_ (x.hOffset_, f, this),
        pitch_ (x.pitch_, f, this),
        roll_ (x.roll_, f, this)
      {
      }

      t_road_signals_signal_positionRoad::
      t_road_signals_signal_positionRoad (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        roadId_ (this),
        s_ (this),
        t_ (this),
        zOffset_ (this),
        hOffset_ (this),
        pitch_ (this),
        roll_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void t_road_signals_signal_positionRoad::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "roadId" && n.namespace_ ().empty ())
          {
            this->roadId_.set (roadId_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "s" && n.namespace_ ().empty ())
          {
            this->s_.set (s_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "t" && n.namespace_ ().empty ())
          {
            this->t_.set (t_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "zOffset" && n.namespace_ ().empty ())
          {
            this->zOffset_.set (zOffset_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "hOffset" && n.namespace_ ().empty ())
          {
            this->hOffset_.set (hOffset_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "pitch" && n.namespace_ ().empty ())
          {
            this->pitch_.set (pitch_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "roll" && n.namespace_ ().empty ())
          {
            this->roll_.set (roll_traits::create (i, f, this));
            continue;
          }
        }

        if (!roadId_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "roadId",
            "");
        }

        if (!s_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "s",
            "");
        }

        if (!t_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "t",
            "");
        }

        if (!zOffset_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "zOffset",
            "");
        }

        if (!hOffset_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "hOffset",
            "");
        }
      }

      t_road_signals_signal_positionRoad* t_road_signals_signal_positionRoad::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_road_signals_signal_positionRoad (*this, f, c);
      }

      t_road_signals_signal_positionRoad& t_road_signals_signal_positionRoad::
      operator= (const t_road_signals_signal_positionRoad& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->roadId_ = x.roadId_;
          this->s_ = x.s_;
          this->t_ = x.t_;
          this->zOffset_ = x.zOffset_;
          this->hOffset_ = x.hOffset_;
          this->pitch_ = x.pitch_;
          this->roll_ = x.roll_;
        }

        return *this;
      }

      t_road_signals_signal_positionRoad::
      ~t_road_signals_signal_positionRoad ()
      {
      }

      // t_road_signals_signal_reference
      //

      t_road_signals_signal_reference::
      t_road_signals_signal_reference (const elementType_type& elementType,
                                       const elementId_type& elementId)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        elementType_ (elementType, this),
        elementId_ (elementId, this),
        type_ (this)
      {
      }

      t_road_signals_signal_reference::
      t_road_signals_signal_reference (const t_road_signals_signal_reference& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        elementType_ (x.elementType_, f, this),
        elementId_ (x.elementId_, f, this),
        type_ (x.type_, f, this)
      {
      }

      t_road_signals_signal_reference::
      t_road_signals_signal_reference (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        elementType_ (this),
        elementId_ (this),
        type_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void t_road_signals_signal_reference::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "elementType" && n.namespace_ ().empty ())
          {
            this->elementType_.set (elementType_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "elementId" && n.namespace_ ().empty ())
          {
            this->elementId_.set (elementId_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "type" && n.namespace_ ().empty ())
          {
            this->type_.set (type_traits::create (i, f, this));
            continue;
          }
        }

        if (!elementType_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "elementType",
            "");
        }

        if (!elementId_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "elementId",
            "");
        }
      }

      t_road_signals_signal_reference* t_road_signals_signal_reference::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_road_signals_signal_reference (*this, f, c);
      }

      t_road_signals_signal_reference& t_road_signals_signal_reference::
      operator= (const t_road_signals_signal_reference& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->elementType_ = x.elementType_;
          this->elementId_ = x.elementId_;
          this->type_ = x.type_;
        }

        return *this;
      }

      t_road_signals_signal_reference::
      ~t_road_signals_signal_reference ()
      {
      }

      // t_road_signals_signalReference
      //

      t_road_signals_signalReference::
      t_road_signals_signalReference (const s_type& s,
                                      const t_type& t,
                                      const id_type& id,
                                      const orientation_type& orientation)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        validity_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        s_ (s, this),
        t_ (t, this),
        id_ (id, this),
        orientation_ (orientation, this)
      {
      }

      t_road_signals_signalReference::
      t_road_signals_signalReference (const t_road_signals_signalReference& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        validity_ (x.validity_, f, this),
        include_ (x.include_, f, this),
        userData_ (x.userData_, f, this),
        dataQuality_ (x.dataQuality_, f, this),
        s_ (x.s_, f, this),
        t_ (x.t_, f, this),
        id_ (x.id_, f, this),
        orientation_ (x.orientation_, f, this)
      {
      }

      t_road_signals_signalReference::
      t_road_signals_signalReference (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        validity_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        s_ (this),
        t_ (this),
        id_ (this),
        orientation_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void t_road_signals_signalReference::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // validity
          //
          if (n.name () == "validity" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< validity_type > r (
              validity_traits::create (i, f, this));

            this->validity_.push_back (::std::move (r));
            continue;
          }

          // include
          //
          if (n.name () == "include" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< include_type > r (
              include_traits::create (i, f, this));

            this->include_.push_back (::std::move (r));
            continue;
          }

          // userData
          //
          if (n.name () == "userData" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< userData_type > r (
              userData_traits::create (i, f, this));

            this->userData_.push_back (::std::move (r));
            continue;
          }

          // dataQuality
          //
          if (n.name () == "dataQuality" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< dataQuality_type > r (
              dataQuality_traits::create (i, f, this));

            this->dataQuality_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "s" && n.namespace_ ().empty ())
          {
            this->s_.set (s_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "t" && n.namespace_ ().empty ())
          {
            this->t_.set (t_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (id_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "orientation" && n.namespace_ ().empty ())
          {
            this->orientation_.set (orientation_traits::create (i, f, this));
            continue;
          }
        }

        if (!s_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "s",
            "");
        }

        if (!t_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "t",
            "");
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "id",
            "");
        }

        if (!orientation_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "orientation",
            "");
        }
      }

      t_road_signals_signalReference* t_road_signals_signalReference::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_road_signals_signalReference (*this, f, c);
      }

      t_road_signals_signalReference& t_road_signals_signalReference::
      operator= (const t_road_signals_signalReference& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->validity_ = x.validity_;
          this->include_ = x.include_;
          this->userData_ = x.userData_;
          this->dataQuality_ = x.dataQuality_;
          this->s_ = x.s_;
          this->t_ = x.t_;
          this->id_ = x.id_;
          this->orientation_ = x.orientation_;
        }

        return *this;
      }

      t_road_signals_signalReference::
      ~t_road_signals_signalReference ()
      {
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace simulation
{
  namespace standard
  {
    namespace opendrive_schema
    {
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

