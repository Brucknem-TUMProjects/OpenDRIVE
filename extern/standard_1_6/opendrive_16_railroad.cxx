// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "opendrive_16_railroad.hxx"

namespace simulation
{
  namespace standard
  {
    namespace opendrive_schema
    {
      // e_road_railroad_switch_position
      // 

      e_road_railroad_switch_position::
      e_road_railroad_switch_position (value v)
      : ::xml_schema::string (_xsd_e_road_railroad_switch_position_literals_[v])
      {
      }

      e_road_railroad_switch_position::
      e_road_railroad_switch_position (const char* v)
      : ::xml_schema::string (v)
      {
      }

      e_road_railroad_switch_position::
      e_road_railroad_switch_position (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_road_railroad_switch_position::
      e_road_railroad_switch_position (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_road_railroad_switch_position::
      e_road_railroad_switch_position (const e_road_railroad_switch_position& v,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      e_road_railroad_switch_position& e_road_railroad_switch_position::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_e_road_railroad_switch_position_literals_[v]);

        return *this;
      }


      // e_station_platform_segment_side
      // 

      e_station_platform_segment_side::
      e_station_platform_segment_side (value v)
      : ::xml_schema::string (_xsd_e_station_platform_segment_side_literals_[v])
      {
      }

      e_station_platform_segment_side::
      e_station_platform_segment_side (const char* v)
      : ::xml_schema::string (v)
      {
      }

      e_station_platform_segment_side::
      e_station_platform_segment_side (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_station_platform_segment_side::
      e_station_platform_segment_side (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_station_platform_segment_side::
      e_station_platform_segment_side (const e_station_platform_segment_side& v,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      e_station_platform_segment_side& e_station_platform_segment_side::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_e_station_platform_segment_side_literals_[v]);

        return *this;
      }


      // e_station_type
      // 

      e_station_type::
      e_station_type (value v)
      : ::xml_schema::string (_xsd_e_station_type_literals_[v])
      {
      }

      e_station_type::
      e_station_type (const char* v)
      : ::xml_schema::string (v)
      {
      }

      e_station_type::
      e_station_type (const ::std::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_station_type::
      e_station_type (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      e_station_type::
      e_station_type (const e_station_type& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      e_station_type& e_station_type::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_e_station_type_literals_[v]);

        return *this;
      }


      // t_road_railroad
      // 

      const t_road_railroad::switch_sequence& t_road_railroad::
      switch_ () const
      {
        return this->switch__;
      }

      t_road_railroad::switch_sequence& t_road_railroad::
      switch_ ()
      {
        return this->switch__;
      }

      void t_road_railroad::
      switch_ (const switch_sequence& s)
      {
        this->switch__ = s;
      }

      const t_road_railroad::include_sequence& t_road_railroad::
      include () const
      {
        return this->include_;
      }

      t_road_railroad::include_sequence& t_road_railroad::
      include ()
      {
        return this->include_;
      }

      void t_road_railroad::
      include (const include_sequence& s)
      {
        this->include_ = s;
      }

      const t_road_railroad::userData_sequence& t_road_railroad::
      userData () const
      {
        return this->userData_;
      }

      t_road_railroad::userData_sequence& t_road_railroad::
      userData ()
      {
        return this->userData_;
      }

      void t_road_railroad::
      userData (const userData_sequence& s)
      {
        this->userData_ = s;
      }

      const t_road_railroad::dataQuality_sequence& t_road_railroad::
      dataQuality () const
      {
        return this->dataQuality_;
      }

      t_road_railroad::dataQuality_sequence& t_road_railroad::
      dataQuality ()
      {
        return this->dataQuality_;
      }

      void t_road_railroad::
      dataQuality (const dataQuality_sequence& s)
      {
        this->dataQuality_ = s;
      }


      // t_road_railroad_switch
      // 

      const t_road_railroad_switch::mainTrack_type& t_road_railroad_switch::
      mainTrack () const
      {
        return this->mainTrack_.get ();
      }

      t_road_railroad_switch::mainTrack_type& t_road_railroad_switch::
      mainTrack ()
      {
        return this->mainTrack_.get ();
      }

      void t_road_railroad_switch::
      mainTrack (const mainTrack_type& x)
      {
        this->mainTrack_.set (x);
      }

      void t_road_railroad_switch::
      mainTrack (::std::unique_ptr< mainTrack_type > x)
      {
        this->mainTrack_.set (std::move (x));
      }

      const t_road_railroad_switch::sideTrack_type& t_road_railroad_switch::
      sideTrack () const
      {
        return this->sideTrack_.get ();
      }

      t_road_railroad_switch::sideTrack_type& t_road_railroad_switch::
      sideTrack ()
      {
        return this->sideTrack_.get ();
      }

      void t_road_railroad_switch::
      sideTrack (const sideTrack_type& x)
      {
        this->sideTrack_.set (x);
      }

      void t_road_railroad_switch::
      sideTrack (::std::unique_ptr< sideTrack_type > x)
      {
        this->sideTrack_.set (std::move (x));
      }

      const t_road_railroad_switch::partner_optional& t_road_railroad_switch::
      partner () const
      {
        return this->partner_;
      }

      t_road_railroad_switch::partner_optional& t_road_railroad_switch::
      partner ()
      {
        return this->partner_;
      }

      void t_road_railroad_switch::
      partner (const partner_type& x)
      {
        this->partner_.set (x);
      }

      void t_road_railroad_switch::
      partner (const partner_optional& x)
      {
        this->partner_ = x;
      }

      void t_road_railroad_switch::
      partner (::std::unique_ptr< partner_type > x)
      {
        this->partner_.set (std::move (x));
      }

      const t_road_railroad_switch::include_sequence& t_road_railroad_switch::
      include () const
      {
        return this->include_;
      }

      t_road_railroad_switch::include_sequence& t_road_railroad_switch::
      include ()
      {
        return this->include_;
      }

      void t_road_railroad_switch::
      include (const include_sequence& s)
      {
        this->include_ = s;
      }

      const t_road_railroad_switch::userData_sequence& t_road_railroad_switch::
      userData () const
      {
        return this->userData_;
      }

      t_road_railroad_switch::userData_sequence& t_road_railroad_switch::
      userData ()
      {
        return this->userData_;
      }

      void t_road_railroad_switch::
      userData (const userData_sequence& s)
      {
        this->userData_ = s;
      }

      const t_road_railroad_switch::dataQuality_sequence& t_road_railroad_switch::
      dataQuality () const
      {
        return this->dataQuality_;
      }

      t_road_railroad_switch::dataQuality_sequence& t_road_railroad_switch::
      dataQuality ()
      {
        return this->dataQuality_;
      }

      void t_road_railroad_switch::
      dataQuality (const dataQuality_sequence& s)
      {
        this->dataQuality_ = s;
      }

      const t_road_railroad_switch::name_type& t_road_railroad_switch::
      name () const
      {
        return this->name_.get ();
      }

      t_road_railroad_switch::name_type& t_road_railroad_switch::
      name ()
      {
        return this->name_.get ();
      }

      void t_road_railroad_switch::
      name (const name_type& x)
      {
        this->name_.set (x);
      }

      void t_road_railroad_switch::
      name (::std::unique_ptr< name_type > x)
      {
        this->name_.set (std::move (x));
      }

      const t_road_railroad_switch::id_type& t_road_railroad_switch::
      id () const
      {
        return this->id_.get ();
      }

      t_road_railroad_switch::id_type& t_road_railroad_switch::
      id ()
      {
        return this->id_.get ();
      }

      void t_road_railroad_switch::
      id (const id_type& x)
      {
        this->id_.set (x);
      }

      void t_road_railroad_switch::
      id (::std::unique_ptr< id_type > x)
      {
        this->id_.set (std::move (x));
      }

      const t_road_railroad_switch::position_type& t_road_railroad_switch::
      position () const
      {
        return this->position_.get ();
      }

      t_road_railroad_switch::position_type& t_road_railroad_switch::
      position ()
      {
        return this->position_.get ();
      }

      void t_road_railroad_switch::
      position (const position_type& x)
      {
        this->position_.set (x);
      }

      void t_road_railroad_switch::
      position (::std::unique_ptr< position_type > x)
      {
        this->position_.set (std::move (x));
      }


      // t_road_railroad_switch_mainTrack
      // 

      const t_road_railroad_switch_mainTrack::include_sequence& t_road_railroad_switch_mainTrack::
      include () const
      {
        return this->include_;
      }

      t_road_railroad_switch_mainTrack::include_sequence& t_road_railroad_switch_mainTrack::
      include ()
      {
        return this->include_;
      }

      void t_road_railroad_switch_mainTrack::
      include (const include_sequence& s)
      {
        this->include_ = s;
      }

      const t_road_railroad_switch_mainTrack::userData_sequence& t_road_railroad_switch_mainTrack::
      userData () const
      {
        return this->userData_;
      }

      t_road_railroad_switch_mainTrack::userData_sequence& t_road_railroad_switch_mainTrack::
      userData ()
      {
        return this->userData_;
      }

      void t_road_railroad_switch_mainTrack::
      userData (const userData_sequence& s)
      {
        this->userData_ = s;
      }

      const t_road_railroad_switch_mainTrack::dataQuality_sequence& t_road_railroad_switch_mainTrack::
      dataQuality () const
      {
        return this->dataQuality_;
      }

      t_road_railroad_switch_mainTrack::dataQuality_sequence& t_road_railroad_switch_mainTrack::
      dataQuality ()
      {
        return this->dataQuality_;
      }

      void t_road_railroad_switch_mainTrack::
      dataQuality (const dataQuality_sequence& s)
      {
        this->dataQuality_ = s;
      }

      const t_road_railroad_switch_mainTrack::id_type& t_road_railroad_switch_mainTrack::
      id () const
      {
        return this->id_.get ();
      }

      t_road_railroad_switch_mainTrack::id_type& t_road_railroad_switch_mainTrack::
      id ()
      {
        return this->id_.get ();
      }

      void t_road_railroad_switch_mainTrack::
      id (const id_type& x)
      {
        this->id_.set (x);
      }

      void t_road_railroad_switch_mainTrack::
      id (::std::unique_ptr< id_type > x)
      {
        this->id_.set (std::move (x));
      }

      const t_road_railroad_switch_mainTrack::s_type& t_road_railroad_switch_mainTrack::
      s () const
      {
        return this->s_.get ();
      }

      t_road_railroad_switch_mainTrack::s_type& t_road_railroad_switch_mainTrack::
      s ()
      {
        return this->s_.get ();
      }

      void t_road_railroad_switch_mainTrack::
      s (const s_type& x)
      {
        this->s_.set (x);
      }

      void t_road_railroad_switch_mainTrack::
      s (::std::unique_ptr< s_type > x)
      {
        this->s_.set (std::move (x));
      }

      const t_road_railroad_switch_mainTrack::dir_type& t_road_railroad_switch_mainTrack::
      dir () const
      {
        return this->dir_.get ();
      }

      t_road_railroad_switch_mainTrack::dir_type& t_road_railroad_switch_mainTrack::
      dir ()
      {
        return this->dir_.get ();
      }

      void t_road_railroad_switch_mainTrack::
      dir (const dir_type& x)
      {
        this->dir_.set (x);
      }

      void t_road_railroad_switch_mainTrack::
      dir (::std::unique_ptr< dir_type > x)
      {
        this->dir_.set (std::move (x));
      }


      // t_road_railroad_switch_partner
      // 

      const t_road_railroad_switch_partner::include_sequence& t_road_railroad_switch_partner::
      include () const
      {
        return this->include_;
      }

      t_road_railroad_switch_partner::include_sequence& t_road_railroad_switch_partner::
      include ()
      {
        return this->include_;
      }

      void t_road_railroad_switch_partner::
      include (const include_sequence& s)
      {
        this->include_ = s;
      }

      const t_road_railroad_switch_partner::userData_sequence& t_road_railroad_switch_partner::
      userData () const
      {
        return this->userData_;
      }

      t_road_railroad_switch_partner::userData_sequence& t_road_railroad_switch_partner::
      userData ()
      {
        return this->userData_;
      }

      void t_road_railroad_switch_partner::
      userData (const userData_sequence& s)
      {
        this->userData_ = s;
      }

      const t_road_railroad_switch_partner::dataQuality_sequence& t_road_railroad_switch_partner::
      dataQuality () const
      {
        return this->dataQuality_;
      }

      t_road_railroad_switch_partner::dataQuality_sequence& t_road_railroad_switch_partner::
      dataQuality ()
      {
        return this->dataQuality_;
      }

      void t_road_railroad_switch_partner::
      dataQuality (const dataQuality_sequence& s)
      {
        this->dataQuality_ = s;
      }

      const t_road_railroad_switch_partner::name_optional& t_road_railroad_switch_partner::
      name () const
      {
        return this->name_;
      }

      t_road_railroad_switch_partner::name_optional& t_road_railroad_switch_partner::
      name ()
      {
        return this->name_;
      }

      void t_road_railroad_switch_partner::
      name (const name_type& x)
      {
        this->name_.set (x);
      }

      void t_road_railroad_switch_partner::
      name (const name_optional& x)
      {
        this->name_ = x;
      }

      void t_road_railroad_switch_partner::
      name (::std::unique_ptr< name_type > x)
      {
        this->name_.set (std::move (x));
      }

      const t_road_railroad_switch_partner::id_type& t_road_railroad_switch_partner::
      id () const
      {
        return this->id_.get ();
      }

      t_road_railroad_switch_partner::id_type& t_road_railroad_switch_partner::
      id ()
      {
        return this->id_.get ();
      }

      void t_road_railroad_switch_partner::
      id (const id_type& x)
      {
        this->id_.set (x);
      }

      void t_road_railroad_switch_partner::
      id (::std::unique_ptr< id_type > x)
      {
        this->id_.set (std::move (x));
      }


      // t_road_railroad_switch_sideTrack
      // 

      const t_road_railroad_switch_sideTrack::include_sequence& t_road_railroad_switch_sideTrack::
      include () const
      {
        return this->include_;
      }

      t_road_railroad_switch_sideTrack::include_sequence& t_road_railroad_switch_sideTrack::
      include ()
      {
        return this->include_;
      }

      void t_road_railroad_switch_sideTrack::
      include (const include_sequence& s)
      {
        this->include_ = s;
      }

      const t_road_railroad_switch_sideTrack::userData_sequence& t_road_railroad_switch_sideTrack::
      userData () const
      {
        return this->userData_;
      }

      t_road_railroad_switch_sideTrack::userData_sequence& t_road_railroad_switch_sideTrack::
      userData ()
      {
        return this->userData_;
      }

      void t_road_railroad_switch_sideTrack::
      userData (const userData_sequence& s)
      {
        this->userData_ = s;
      }

      const t_road_railroad_switch_sideTrack::dataQuality_sequence& t_road_railroad_switch_sideTrack::
      dataQuality () const
      {
        return this->dataQuality_;
      }

      t_road_railroad_switch_sideTrack::dataQuality_sequence& t_road_railroad_switch_sideTrack::
      dataQuality ()
      {
        return this->dataQuality_;
      }

      void t_road_railroad_switch_sideTrack::
      dataQuality (const dataQuality_sequence& s)
      {
        this->dataQuality_ = s;
      }

      const t_road_railroad_switch_sideTrack::id_type& t_road_railroad_switch_sideTrack::
      id () const
      {
        return this->id_.get ();
      }

      t_road_railroad_switch_sideTrack::id_type& t_road_railroad_switch_sideTrack::
      id ()
      {
        return this->id_.get ();
      }

      void t_road_railroad_switch_sideTrack::
      id (const id_type& x)
      {
        this->id_.set (x);
      }

      void t_road_railroad_switch_sideTrack::
      id (::std::unique_ptr< id_type > x)
      {
        this->id_.set (std::move (x));
      }

      const t_road_railroad_switch_sideTrack::s_type& t_road_railroad_switch_sideTrack::
      s () const
      {
        return this->s_.get ();
      }

      t_road_railroad_switch_sideTrack::s_type& t_road_railroad_switch_sideTrack::
      s ()
      {
        return this->s_.get ();
      }

      void t_road_railroad_switch_sideTrack::
      s (const s_type& x)
      {
        this->s_.set (x);
      }

      void t_road_railroad_switch_sideTrack::
      s (::std::unique_ptr< s_type > x)
      {
        this->s_.set (std::move (x));
      }

      const t_road_railroad_switch_sideTrack::dir_type& t_road_railroad_switch_sideTrack::
      dir () const
      {
        return this->dir_.get ();
      }

      t_road_railroad_switch_sideTrack::dir_type& t_road_railroad_switch_sideTrack::
      dir ()
      {
        return this->dir_.get ();
      }

      void t_road_railroad_switch_sideTrack::
      dir (const dir_type& x)
      {
        this->dir_.set (x);
      }

      void t_road_railroad_switch_sideTrack::
      dir (::std::unique_ptr< dir_type > x)
      {
        this->dir_.set (std::move (x));
      }


      // t_station
      // 

      const t_station::platform_sequence& t_station::
      platform () const
      {
        return this->platform_;
      }

      t_station::platform_sequence& t_station::
      platform ()
      {
        return this->platform_;
      }

      void t_station::
      platform (const platform_sequence& s)
      {
        this->platform_ = s;
      }

      const t_station::include_sequence& t_station::
      include () const
      {
        return this->include_;
      }

      t_station::include_sequence& t_station::
      include ()
      {
        return this->include_;
      }

      void t_station::
      include (const include_sequence& s)
      {
        this->include_ = s;
      }

      const t_station::userData_sequence& t_station::
      userData () const
      {
        return this->userData_;
      }

      t_station::userData_sequence& t_station::
      userData ()
      {
        return this->userData_;
      }

      void t_station::
      userData (const userData_sequence& s)
      {
        this->userData_ = s;
      }

      const t_station::dataQuality_sequence& t_station::
      dataQuality () const
      {
        return this->dataQuality_;
      }

      t_station::dataQuality_sequence& t_station::
      dataQuality ()
      {
        return this->dataQuality_;
      }

      void t_station::
      dataQuality (const dataQuality_sequence& s)
      {
        this->dataQuality_ = s;
      }

      const t_station::name_type& t_station::
      name () const
      {
        return this->name_.get ();
      }

      t_station::name_type& t_station::
      name ()
      {
        return this->name_.get ();
      }

      void t_station::
      name (const name_type& x)
      {
        this->name_.set (x);
      }

      void t_station::
      name (::std::unique_ptr< name_type > x)
      {
        this->name_.set (std::move (x));
      }

      const t_station::id_type& t_station::
      id () const
      {
        return this->id_.get ();
      }

      t_station::id_type& t_station::
      id ()
      {
        return this->id_.get ();
      }

      void t_station::
      id (const id_type& x)
      {
        this->id_.set (x);
      }

      void t_station::
      id (::std::unique_ptr< id_type > x)
      {
        this->id_.set (std::move (x));
      }

      const t_station::type_optional& t_station::
      type () const
      {
        return this->type_;
      }

      t_station::type_optional& t_station::
      type ()
      {
        return this->type_;
      }

      void t_station::
      type (const type_type& x)
      {
        this->type_.set (x);
      }

      void t_station::
      type (const type_optional& x)
      {
        this->type_ = x;
      }

      void t_station::
      type (::std::unique_ptr< type_type > x)
      {
        this->type_.set (std::move (x));
      }


      // t_station_platform
      // 

      const t_station_platform::segment_sequence& t_station_platform::
      segment () const
      {
        return this->segment_;
      }

      t_station_platform::segment_sequence& t_station_platform::
      segment ()
      {
        return this->segment_;
      }

      void t_station_platform::
      segment (const segment_sequence& s)
      {
        this->segment_ = s;
      }

      const t_station_platform::include_sequence& t_station_platform::
      include () const
      {
        return this->include_;
      }

      t_station_platform::include_sequence& t_station_platform::
      include ()
      {
        return this->include_;
      }

      void t_station_platform::
      include (const include_sequence& s)
      {
        this->include_ = s;
      }

      const t_station_platform::userData_sequence& t_station_platform::
      userData () const
      {
        return this->userData_;
      }

      t_station_platform::userData_sequence& t_station_platform::
      userData ()
      {
        return this->userData_;
      }

      void t_station_platform::
      userData (const userData_sequence& s)
      {
        this->userData_ = s;
      }

      const t_station_platform::dataQuality_sequence& t_station_platform::
      dataQuality () const
      {
        return this->dataQuality_;
      }

      t_station_platform::dataQuality_sequence& t_station_platform::
      dataQuality ()
      {
        return this->dataQuality_;
      }

      void t_station_platform::
      dataQuality (const dataQuality_sequence& s)
      {
        this->dataQuality_ = s;
      }

      const t_station_platform::name_optional& t_station_platform::
      name () const
      {
        return this->name_;
      }

      t_station_platform::name_optional& t_station_platform::
      name ()
      {
        return this->name_;
      }

      void t_station_platform::
      name (const name_type& x)
      {
        this->name_.set (x);
      }

      void t_station_platform::
      name (const name_optional& x)
      {
        this->name_ = x;
      }

      void t_station_platform::
      name (::std::unique_ptr< name_type > x)
      {
        this->name_.set (std::move (x));
      }

      const t_station_platform::id_type& t_station_platform::
      id () const
      {
        return this->id_.get ();
      }

      t_station_platform::id_type& t_station_platform::
      id ()
      {
        return this->id_.get ();
      }

      void t_station_platform::
      id (const id_type& x)
      {
        this->id_.set (x);
      }

      void t_station_platform::
      id (::std::unique_ptr< id_type > x)
      {
        this->id_.set (std::move (x));
      }


      // t_station_platform_segment
      // 

      const t_station_platform_segment::roadId_type& t_station_platform_segment::
      roadId () const
      {
        return this->roadId_.get ();
      }

      t_station_platform_segment::roadId_type& t_station_platform_segment::
      roadId ()
      {
        return this->roadId_.get ();
      }

      void t_station_platform_segment::
      roadId (const roadId_type& x)
      {
        this->roadId_.set (x);
      }

      void t_station_platform_segment::
      roadId (::std::unique_ptr< roadId_type > x)
      {
        this->roadId_.set (std::move (x));
      }

      const t_station_platform_segment::sStart_type& t_station_platform_segment::
      sStart () const
      {
        return this->sStart_.get ();
      }

      t_station_platform_segment::sStart_type& t_station_platform_segment::
      sStart ()
      {
        return this->sStart_.get ();
      }

      void t_station_platform_segment::
      sStart (const sStart_type& x)
      {
        this->sStart_.set (x);
      }

      void t_station_platform_segment::
      sStart (::std::unique_ptr< sStart_type > x)
      {
        this->sStart_.set (std::move (x));
      }

      const t_station_platform_segment::sEnd_type& t_station_platform_segment::
      sEnd () const
      {
        return this->sEnd_.get ();
      }

      t_station_platform_segment::sEnd_type& t_station_platform_segment::
      sEnd ()
      {
        return this->sEnd_.get ();
      }

      void t_station_platform_segment::
      sEnd (const sEnd_type& x)
      {
        this->sEnd_.set (x);
      }

      void t_station_platform_segment::
      sEnd (::std::unique_ptr< sEnd_type > x)
      {
        this->sEnd_.set (std::move (x));
      }

      const t_station_platform_segment::side_type& t_station_platform_segment::
      side () const
      {
        return this->side_.get ();
      }

      t_station_platform_segment::side_type& t_station_platform_segment::
      side ()
      {
        return this->side_.get ();
      }

      void t_station_platform_segment::
      side (const side_type& x)
      {
        this->side_.set (x);
      }

      void t_station_platform_segment::
      side (::std::unique_ptr< side_type > x)
      {
        this->side_.set (std::move (x));
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace simulation
{
  namespace standard
  {
    namespace opendrive_schema
    {
      // e_road_railroad_switch_position
      //

      e_road_railroad_switch_position::
      e_road_railroad_switch_position (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_e_road_railroad_switch_position_convert ();
      }

      e_road_railroad_switch_position::
      e_road_railroad_switch_position (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_e_road_railroad_switch_position_convert ();
      }

      e_road_railroad_switch_position::
      e_road_railroad_switch_position (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_e_road_railroad_switch_position_convert ();
      }

      e_road_railroad_switch_position* e_road_railroad_switch_position::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class e_road_railroad_switch_position (*this, f, c);
      }

      e_road_railroad_switch_position::value e_road_railroad_switch_position::
      _xsd_e_road_railroad_switch_position_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_railroad_switch_position_literals_);
        const value* i (::std::lower_bound (
                          _xsd_e_road_railroad_switch_position_indexes_,
                          _xsd_e_road_railroad_switch_position_indexes_ + 3,
                          *this,
                          c));

        if (i == _xsd_e_road_railroad_switch_position_indexes_ + 3 || _xsd_e_road_railroad_switch_position_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const e_road_railroad_switch_position::
      _xsd_e_road_railroad_switch_position_literals_[3] =
      {
        "dynamic",
        "straight",
        "turn"
      };

      const e_road_railroad_switch_position::value e_road_railroad_switch_position::
      _xsd_e_road_railroad_switch_position_indexes_[3] =
      {
        ::simulation::standard::opendrive_schema::e_road_railroad_switch_position::dynamic,
        ::simulation::standard::opendrive_schema::e_road_railroad_switch_position::straight,
        ::simulation::standard::opendrive_schema::e_road_railroad_switch_position::turn
      };

      // e_station_platform_segment_side
      //

      e_station_platform_segment_side::
      e_station_platform_segment_side (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_e_station_platform_segment_side_convert ();
      }

      e_station_platform_segment_side::
      e_station_platform_segment_side (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_e_station_platform_segment_side_convert ();
      }

      e_station_platform_segment_side::
      e_station_platform_segment_side (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_e_station_platform_segment_side_convert ();
      }

      e_station_platform_segment_side* e_station_platform_segment_side::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class e_station_platform_segment_side (*this, f, c);
      }

      e_station_platform_segment_side::value e_station_platform_segment_side::
      _xsd_e_station_platform_segment_side_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_station_platform_segment_side_literals_);
        const value* i (::std::lower_bound (
                          _xsd_e_station_platform_segment_side_indexes_,
                          _xsd_e_station_platform_segment_side_indexes_ + 2,
                          *this,
                          c));

        if (i == _xsd_e_station_platform_segment_side_indexes_ + 2 || _xsd_e_station_platform_segment_side_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const e_station_platform_segment_side::
      _xsd_e_station_platform_segment_side_literals_[2] =
      {
        "left",
        "right"
      };

      const e_station_platform_segment_side::value e_station_platform_segment_side::
      _xsd_e_station_platform_segment_side_indexes_[2] =
      {
        ::simulation::standard::opendrive_schema::e_station_platform_segment_side::left,
        ::simulation::standard::opendrive_schema::e_station_platform_segment_side::right
      };

      // e_station_type
      //

      e_station_type::
      e_station_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_e_station_type_convert ();
      }

      e_station_type::
      e_station_type (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_e_station_type_convert ();
      }

      e_station_type::
      e_station_type (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_e_station_type_convert ();
      }

      e_station_type* e_station_type::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class e_station_type (*this, f, c);
      }

      e_station_type::value e_station_type::
      _xsd_e_station_type_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_station_type_literals_);
        const value* i (::std::lower_bound (
                          _xsd_e_station_type_indexes_,
                          _xsd_e_station_type_indexes_ + 3,
                          *this,
                          c));

        if (i == _xsd_e_station_type_indexes_ + 3 || _xsd_e_station_type_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const e_station_type::
      _xsd_e_station_type_literals_[3] =
      {
        "small",
        "medium",
        "large"
      };

      const e_station_type::value e_station_type::
      _xsd_e_station_type_indexes_[3] =
      {
        ::simulation::standard::opendrive_schema::e_station_type::large,
        ::simulation::standard::opendrive_schema::e_station_type::medium,
        ::simulation::standard::opendrive_schema::e_station_type::small
      };

      // t_road_railroad
      //

      t_road_railroad::
      t_road_railroad ()
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        switch__ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this)
      {
      }

      t_road_railroad::
      t_road_railroad (const t_road_railroad& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        switch__ (x.switch__, f, this),
        include_ (x.include_, f, this),
        userData_ (x.userData_, f, this),
        dataQuality_ (x.dataQuality_, f, this)
      {
      }

      t_road_railroad::
      t_road_railroad (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        switch__ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void t_road_railroad::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // switch
          //
          if (n.name () == "switch" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< switch_type > r (
              switch_traits::create (i, f, this));

            this->switch__.push_back (::std::move (r));
            continue;
          }

          // include
          //
          if (n.name () == "include" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< include_type > r (
              include_traits::create (i, f, this));

            this->include_.push_back (::std::move (r));
            continue;
          }

          // userData
          //
          if (n.name () == "userData" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< userData_type > r (
              userData_traits::create (i, f, this));

            this->userData_.push_back (::std::move (r));
            continue;
          }

          // dataQuality
          //
          if (n.name () == "dataQuality" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< dataQuality_type > r (
              dataQuality_traits::create (i, f, this));

            this->dataQuality_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      t_road_railroad* t_road_railroad::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_road_railroad (*this, f, c);
      }

      t_road_railroad& t_road_railroad::
      operator= (const t_road_railroad& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->switch__ = x.switch__;
          this->include_ = x.include_;
          this->userData_ = x.userData_;
          this->dataQuality_ = x.dataQuality_;
        }

        return *this;
      }

      t_road_railroad::
      ~t_road_railroad ()
      {
      }

      // t_road_railroad_switch
      //

      t_road_railroad_switch::
      t_road_railroad_switch (const mainTrack_type& mainTrack,
                              const sideTrack_type& sideTrack,
                              const name_type& name,
                              const id_type& id,
                              const position_type& position)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        mainTrack_ (mainTrack, this),
        sideTrack_ (sideTrack, this),
        partner_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        name_ (name, this),
        id_ (id, this),
        position_ (position, this)
      {
      }

      t_road_railroad_switch::
      t_road_railroad_switch (::std::unique_ptr< mainTrack_type > mainTrack,
                              ::std::unique_ptr< sideTrack_type > sideTrack,
                              const name_type& name,
                              const id_type& id,
                              const position_type& position)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        mainTrack_ (std::move (mainTrack), this),
        sideTrack_ (std::move (sideTrack), this),
        partner_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        name_ (name, this),
        id_ (id, this),
        position_ (position, this)
      {
      }

      t_road_railroad_switch::
      t_road_railroad_switch (const t_road_railroad_switch& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        mainTrack_ (x.mainTrack_, f, this),
        sideTrack_ (x.sideTrack_, f, this),
        partner_ (x.partner_, f, this),
        include_ (x.include_, f, this),
        userData_ (x.userData_, f, this),
        dataQuality_ (x.dataQuality_, f, this),
        name_ (x.name_, f, this),
        id_ (x.id_, f, this),
        position_ (x.position_, f, this)
      {
      }

      t_road_railroad_switch::
      t_road_railroad_switch (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        mainTrack_ (this),
        sideTrack_ (this),
        partner_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        name_ (this),
        id_ (this),
        position_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void t_road_railroad_switch::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // mainTrack
          //
          if (n.name () == "mainTrack" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< mainTrack_type > r (
              mainTrack_traits::create (i, f, this));

            if (!mainTrack_.present ())
            {
              this->mainTrack_.set (::std::move (r));
              continue;
            }
          }

          // sideTrack
          //
          if (n.name () == "sideTrack" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< sideTrack_type > r (
              sideTrack_traits::create (i, f, this));

            if (!sideTrack_.present ())
            {
              this->sideTrack_.set (::std::move (r));
              continue;
            }
          }

          // partner
          //
          if (n.name () == "partner" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< partner_type > r (
              partner_traits::create (i, f, this));

            if (!this->partner_)
            {
              this->partner_.set (::std::move (r));
              continue;
            }
          }

          // include
          //
          if (n.name () == "include" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< include_type > r (
              include_traits::create (i, f, this));

            this->include_.push_back (::std::move (r));
            continue;
          }

          // userData
          //
          if (n.name () == "userData" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< userData_type > r (
              userData_traits::create (i, f, this));

            this->userData_.push_back (::std::move (r));
            continue;
          }

          // dataQuality
          //
          if (n.name () == "dataQuality" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< dataQuality_type > r (
              dataQuality_traits::create (i, f, this));

            this->dataQuality_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        if (!mainTrack_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "mainTrack",
            "http://code.asam.net/simulation/standard/opendrive_schema");
        }

        if (!sideTrack_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "sideTrack",
            "http://code.asam.net/simulation/standard/opendrive_schema");
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            this->name_.set (name_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (id_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "position" && n.namespace_ ().empty ())
          {
            this->position_.set (position_traits::create (i, f, this));
            continue;
          }
        }

        if (!name_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "name",
            "");
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "id",
            "");
        }

        if (!position_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "position",
            "");
        }
      }

      t_road_railroad_switch* t_road_railroad_switch::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_road_railroad_switch (*this, f, c);
      }

      t_road_railroad_switch& t_road_railroad_switch::
      operator= (const t_road_railroad_switch& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->mainTrack_ = x.mainTrack_;
          this->sideTrack_ = x.sideTrack_;
          this->partner_ = x.partner_;
          this->include_ = x.include_;
          this->userData_ = x.userData_;
          this->dataQuality_ = x.dataQuality_;
          this->name_ = x.name_;
          this->id_ = x.id_;
          this->position_ = x.position_;
        }

        return *this;
      }

      t_road_railroad_switch::
      ~t_road_railroad_switch ()
      {
      }

      // t_road_railroad_switch_mainTrack
      //

      t_road_railroad_switch_mainTrack::
      t_road_railroad_switch_mainTrack (const id_type& id,
                                        const s_type& s,
                                        const dir_type& dir)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        id_ (id, this),
        s_ (s, this),
        dir_ (dir, this)
      {
      }

      t_road_railroad_switch_mainTrack::
      t_road_railroad_switch_mainTrack (const t_road_railroad_switch_mainTrack& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        include_ (x.include_, f, this),
        userData_ (x.userData_, f, this),
        dataQuality_ (x.dataQuality_, f, this),
        id_ (x.id_, f, this),
        s_ (x.s_, f, this),
        dir_ (x.dir_, f, this)
      {
      }

      t_road_railroad_switch_mainTrack::
      t_road_railroad_switch_mainTrack (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        id_ (this),
        s_ (this),
        dir_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void t_road_railroad_switch_mainTrack::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // include
          //
          if (n.name () == "include" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< include_type > r (
              include_traits::create (i, f, this));

            this->include_.push_back (::std::move (r));
            continue;
          }

          // userData
          //
          if (n.name () == "userData" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< userData_type > r (
              userData_traits::create (i, f, this));

            this->userData_.push_back (::std::move (r));
            continue;
          }

          // dataQuality
          //
          if (n.name () == "dataQuality" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< dataQuality_type > r (
              dataQuality_traits::create (i, f, this));

            this->dataQuality_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (id_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "s" && n.namespace_ ().empty ())
          {
            this->s_.set (s_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "dir" && n.namespace_ ().empty ())
          {
            this->dir_.set (dir_traits::create (i, f, this));
            continue;
          }
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "id",
            "");
        }

        if (!s_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "s",
            "");
        }

        if (!dir_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "dir",
            "");
        }
      }

      t_road_railroad_switch_mainTrack* t_road_railroad_switch_mainTrack::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_road_railroad_switch_mainTrack (*this, f, c);
      }

      t_road_railroad_switch_mainTrack& t_road_railroad_switch_mainTrack::
      operator= (const t_road_railroad_switch_mainTrack& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->include_ = x.include_;
          this->userData_ = x.userData_;
          this->dataQuality_ = x.dataQuality_;
          this->id_ = x.id_;
          this->s_ = x.s_;
          this->dir_ = x.dir_;
        }

        return *this;
      }

      t_road_railroad_switch_mainTrack::
      ~t_road_railroad_switch_mainTrack ()
      {
      }

      // t_road_railroad_switch_partner
      //

      t_road_railroad_switch_partner::
      t_road_railroad_switch_partner (const id_type& id)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        name_ (this),
        id_ (id, this)
      {
      }

      t_road_railroad_switch_partner::
      t_road_railroad_switch_partner (const t_road_railroad_switch_partner& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        include_ (x.include_, f, this),
        userData_ (x.userData_, f, this),
        dataQuality_ (x.dataQuality_, f, this),
        name_ (x.name_, f, this),
        id_ (x.id_, f, this)
      {
      }

      t_road_railroad_switch_partner::
      t_road_railroad_switch_partner (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        name_ (this),
        id_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void t_road_railroad_switch_partner::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // include
          //
          if (n.name () == "include" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< include_type > r (
              include_traits::create (i, f, this));

            this->include_.push_back (::std::move (r));
            continue;
          }

          // userData
          //
          if (n.name () == "userData" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< userData_type > r (
              userData_traits::create (i, f, this));

            this->userData_.push_back (::std::move (r));
            continue;
          }

          // dataQuality
          //
          if (n.name () == "dataQuality" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< dataQuality_type > r (
              dataQuality_traits::create (i, f, this));

            this->dataQuality_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            this->name_.set (name_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (id_traits::create (i, f, this));
            continue;
          }
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "id",
            "");
        }
      }

      t_road_railroad_switch_partner* t_road_railroad_switch_partner::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_road_railroad_switch_partner (*this, f, c);
      }

      t_road_railroad_switch_partner& t_road_railroad_switch_partner::
      operator= (const t_road_railroad_switch_partner& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->include_ = x.include_;
          this->userData_ = x.userData_;
          this->dataQuality_ = x.dataQuality_;
          this->name_ = x.name_;
          this->id_ = x.id_;
        }

        return *this;
      }

      t_road_railroad_switch_partner::
      ~t_road_railroad_switch_partner ()
      {
      }

      // t_road_railroad_switch_sideTrack
      //

      t_road_railroad_switch_sideTrack::
      t_road_railroad_switch_sideTrack (const id_type& id,
                                        const s_type& s,
                                        const dir_type& dir)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        id_ (id, this),
        s_ (s, this),
        dir_ (dir, this)
      {
      }

      t_road_railroad_switch_sideTrack::
      t_road_railroad_switch_sideTrack (const t_road_railroad_switch_sideTrack& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        include_ (x.include_, f, this),
        userData_ (x.userData_, f, this),
        dataQuality_ (x.dataQuality_, f, this),
        id_ (x.id_, f, this),
        s_ (x.s_, f, this),
        dir_ (x.dir_, f, this)
      {
      }

      t_road_railroad_switch_sideTrack::
      t_road_railroad_switch_sideTrack (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        id_ (this),
        s_ (this),
        dir_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void t_road_railroad_switch_sideTrack::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // include
          //
          if (n.name () == "include" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< include_type > r (
              include_traits::create (i, f, this));

            this->include_.push_back (::std::move (r));
            continue;
          }

          // userData
          //
          if (n.name () == "userData" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< userData_type > r (
              userData_traits::create (i, f, this));

            this->userData_.push_back (::std::move (r));
            continue;
          }

          // dataQuality
          //
          if (n.name () == "dataQuality" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< dataQuality_type > r (
              dataQuality_traits::create (i, f, this));

            this->dataQuality_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (id_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "s" && n.namespace_ ().empty ())
          {
            this->s_.set (s_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "dir" && n.namespace_ ().empty ())
          {
            this->dir_.set (dir_traits::create (i, f, this));
            continue;
          }
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "id",
            "");
        }

        if (!s_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "s",
            "");
        }

        if (!dir_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "dir",
            "");
        }
      }

      t_road_railroad_switch_sideTrack* t_road_railroad_switch_sideTrack::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_road_railroad_switch_sideTrack (*this, f, c);
      }

      t_road_railroad_switch_sideTrack& t_road_railroad_switch_sideTrack::
      operator= (const t_road_railroad_switch_sideTrack& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->include_ = x.include_;
          this->userData_ = x.userData_;
          this->dataQuality_ = x.dataQuality_;
          this->id_ = x.id_;
          this->s_ = x.s_;
          this->dir_ = x.dir_;
        }

        return *this;
      }

      t_road_railroad_switch_sideTrack::
      ~t_road_railroad_switch_sideTrack ()
      {
      }

      // t_station
      //

      t_station::
      t_station (const name_type& name,
                 const id_type& id)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        platform_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        name_ (name, this),
        id_ (id, this),
        type_ (this)
      {
      }

      t_station::
      t_station (const t_station& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        platform_ (x.platform_, f, this),
        include_ (x.include_, f, this),
        userData_ (x.userData_, f, this),
        dataQuality_ (x.dataQuality_, f, this),
        name_ (x.name_, f, this),
        id_ (x.id_, f, this),
        type_ (x.type_, f, this)
      {
      }

      t_station::
      t_station (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        platform_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        name_ (this),
        id_ (this),
        type_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void t_station::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // platform
          //
          if (n.name () == "platform" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< platform_type > r (
              platform_traits::create (i, f, this));

            this->platform_.push_back (::std::move (r));
            continue;
          }

          // include
          //
          if (n.name () == "include" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< include_type > r (
              include_traits::create (i, f, this));

            this->include_.push_back (::std::move (r));
            continue;
          }

          // userData
          //
          if (n.name () == "userData" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< userData_type > r (
              userData_traits::create (i, f, this));

            this->userData_.push_back (::std::move (r));
            continue;
          }

          // dataQuality
          //
          if (n.name () == "dataQuality" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< dataQuality_type > r (
              dataQuality_traits::create (i, f, this));

            this->dataQuality_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            this->name_.set (name_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (id_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "type" && n.namespace_ ().empty ())
          {
            this->type_.set (type_traits::create (i, f, this));
            continue;
          }
        }

        if (!name_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "name",
            "");
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "id",
            "");
        }
      }

      t_station* t_station::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_station (*this, f, c);
      }

      t_station& t_station::
      operator= (const t_station& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->platform_ = x.platform_;
          this->include_ = x.include_;
          this->userData_ = x.userData_;
          this->dataQuality_ = x.dataQuality_;
          this->name_ = x.name_;
          this->id_ = x.id_;
          this->type_ = x.type_;
        }

        return *this;
      }

      t_station::
      ~t_station ()
      {
      }

      // t_station_platform
      //

      t_station_platform::
      t_station_platform (const id_type& id)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        segment_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        name_ (this),
        id_ (id, this)
      {
      }

      t_station_platform::
      t_station_platform (const t_station_platform& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        segment_ (x.segment_, f, this),
        include_ (x.include_, f, this),
        userData_ (x.userData_, f, this),
        dataQuality_ (x.dataQuality_, f, this),
        name_ (x.name_, f, this),
        id_ (x.id_, f, this)
      {
      }

      t_station_platform::
      t_station_platform (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        segment_ (this),
        include_ (this),
        userData_ (this),
        dataQuality_ (this),
        name_ (this),
        id_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void t_station_platform::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // segment
          //
          if (n.name () == "segment" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< segment_type > r (
              segment_traits::create (i, f, this));

            this->segment_.push_back (::std::move (r));
            continue;
          }

          // include
          //
          if (n.name () == "include" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< include_type > r (
              include_traits::create (i, f, this));

            this->include_.push_back (::std::move (r));
            continue;
          }

          // userData
          //
          if (n.name () == "userData" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< userData_type > r (
              userData_traits::create (i, f, this));

            this->userData_.push_back (::std::move (r));
            continue;
          }

          // dataQuality
          //
          if (n.name () == "dataQuality" && n.namespace_ () == "http://code.asam.net/simulation/standard/opendrive_schema")
          {
            ::std::unique_ptr< dataQuality_type > r (
              dataQuality_traits::create (i, f, this));

            this->dataQuality_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            this->name_.set (name_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (id_traits::create (i, f, this));
            continue;
          }
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "id",
            "");
        }
      }

      t_station_platform* t_station_platform::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_station_platform (*this, f, c);
      }

      t_station_platform& t_station_platform::
      operator= (const t_station_platform& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->segment_ = x.segment_;
          this->include_ = x.include_;
          this->userData_ = x.userData_;
          this->dataQuality_ = x.dataQuality_;
          this->name_ = x.name_;
          this->id_ = x.id_;
        }

        return *this;
      }

      t_station_platform::
      ~t_station_platform ()
      {
      }

      // t_station_platform_segment
      //

      t_station_platform_segment::
      t_station_platform_segment (const roadId_type& roadId,
                                  const sStart_type& sStart,
                                  const sEnd_type& sEnd,
                                  const side_type& side)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (),
        roadId_ (roadId, this),
        sStart_ (sStart, this),
        sEnd_ (sEnd, this),
        side_ (side, this)
      {
      }

      t_station_platform_segment::
      t_station_platform_segment (const t_station_platform_segment& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (x, f, c),
        roadId_ (x.roadId_, f, this),
        sStart_ (x.sStart_, f, this),
        sEnd_ (x.sEnd_, f, this),
        side_ (x.side_, f, this)
      {
      }

      t_station_platform_segment::
      t_station_platform_segment (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
      : ::simulation::standard::opendrive_schema::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
        roadId_ (this),
        sStart_ (this),
        sEnd_ (this),
        side_ (this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void t_station_platform_segment::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "roadId" && n.namespace_ ().empty ())
          {
            this->roadId_.set (roadId_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "sStart" && n.namespace_ ().empty ())
          {
            this->sStart_.set (sStart_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "sEnd" && n.namespace_ ().empty ())
          {
            this->sEnd_.set (sEnd_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "side" && n.namespace_ ().empty ())
          {
            this->side_.set (side_traits::create (i, f, this));
            continue;
          }
        }

        if (!roadId_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "roadId",
            "");
        }

        if (!sStart_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "sStart",
            "");
        }

        if (!sEnd_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "sEnd",
            "");
        }

        if (!side_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "side",
            "");
        }
      }

      t_station_platform_segment* t_station_platform_segment::
      _clone (::xml_schema::flags f,
              ::xml_schema::container* c) const
      {
        return new class t_station_platform_segment (*this, f, c);
      }

      t_station_platform_segment& t_station_platform_segment::
      operator= (const t_station_platform_segment& x)
      {
        if (this != &x)
        {
          static_cast< ::simulation::standard::opendrive_schema::_OpenDriveElement& > (*this) = x;
          this->roadId_ = x.roadId_;
          this->sStart_ = x.sStart_;
          this->sEnd_ = x.sEnd_;
          this->side_ = x.side_;
        }

        return *this;
      }

      t_station_platform_segment::
      ~t_station_platform_segment ()
      {
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace simulation
{
  namespace standard
  {
    namespace opendrive_schema
    {
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

