// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "opendrive_16_core.hxx"

// e_dataQuality_RawData_PostProcessing
// 

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (value v)
: ::xml_schema::string (_xsd_e_dataQuality_RawData_PostProcessing_literals_[v])
{
}

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (const char* v)
: ::xml_schema::string (v)
{
}

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (const e_dataQuality_RawData_PostProcessing& v,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_dataQuality_RawData_PostProcessing& e_dataQuality_RawData_PostProcessing::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_dataQuality_RawData_PostProcessing_literals_[v]);

  return *this;
}


// e_dataQuality_RawData_Source
// 

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (value v)
: ::xml_schema::string (_xsd_e_dataQuality_RawData_Source_literals_[v])
{
}

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (const char* v)
: ::xml_schema::string (v)
{
}

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (const e_dataQuality_RawData_Source& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_dataQuality_RawData_Source& e_dataQuality_RawData_Source::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_dataQuality_RawData_Source_literals_[v]);

  return *this;
}


// e_unit
// 

e_unit::
e_unit (value v)
: ::xml_schema::string (_xsd_e_unit_literals_[v])
{
}

e_unit::
e_unit (const char* v)
: ::xml_schema::string (v)
{
}

e_unit::
e_unit (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_unit::
e_unit (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_unit::
e_unit (const e_unit& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_unit& e_unit::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_unit_literals_[v]);

  return *this;
}


// e_unitDistance
// 

e_unitDistance::
e_unitDistance (value v)
: ::xml_schema::string (_xsd_e_unitDistance_literals_[v])
{
}

e_unitDistance::
e_unitDistance (const char* v)
: ::xml_schema::string (v)
{
}

e_unitDistance::
e_unitDistance (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_unitDistance::
e_unitDistance (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_unitDistance::
e_unitDistance (const e_unitDistance& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_unitDistance& e_unitDistance::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_unitDistance_literals_[v]);

  return *this;
}


// e_unitMass
// 

e_unitMass::
e_unitMass (value v)
: ::xml_schema::string (_xsd_e_unitMass_literals_[v])
{
}

e_unitMass::
e_unitMass (const char* v)
: ::xml_schema::string (v)
{
}

e_unitMass::
e_unitMass (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_unitMass::
e_unitMass (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_unitMass::
e_unitMass (const e_unitMass& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_unitMass& e_unitMass::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_unitMass_literals_[v]);

  return *this;
}


// e_unitSlope
// 

e_unitSlope::
e_unitSlope (value v)
: ::xml_schema::string (_xsd_e_unitSlope_literals_[v])
{
}

e_unitSlope::
e_unitSlope (const char* v)
: ::xml_schema::string (v)
{
}

e_unitSlope::
e_unitSlope (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_unitSlope::
e_unitSlope (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_unitSlope::
e_unitSlope (const e_unitSlope& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_unitSlope& e_unitSlope::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_unitSlope_literals_[v]);

  return *this;
}


// e_unitSpeed
// 

e_unitSpeed::
e_unitSpeed (value v)
: ::xml_schema::string (_xsd_e_unitSpeed_literals_[v])
{
}

e_unitSpeed::
e_unitSpeed (const char* v)
: ::xml_schema::string (v)
{
}

e_unitSpeed::
e_unitSpeed (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_unitSpeed::
e_unitSpeed (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_unitSpeed::
e_unitSpeed (const e_unitSpeed& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_unitSpeed& e_unitSpeed::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_unitSpeed_literals_[v]);

  return *this;
}


// t_grEqZero
// 


// t_grZero
// 


// t_yesNo
// 

t_yesNo::
t_yesNo (value v)
: ::xml_schema::string (_xsd_t_yesNo_literals_[v])
{
}

t_yesNo::
t_yesNo (const char* v)
: ::xml_schema::string (v)
{
}

t_yesNo::
t_yesNo (const ::std::string& v)
: ::xml_schema::string (v)
{
}

t_yesNo::
t_yesNo (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

t_yesNo::
t_yesNo (const t_yesNo& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

t_yesNo& t_yesNo::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_t_yesNo_literals_[v]);

  return *this;
}


// t_zeroOne
// 


// _OpenDriveElement
// 


// t_dataQuality
// 

const t_dataQuality::error_optional& t_dataQuality::
error () const
{
  return this->error_;
}

t_dataQuality::error_optional& t_dataQuality::
error ()
{
  return this->error_;
}

void t_dataQuality::
error (const error_type& x)
{
  this->error_.set (x);
}

void t_dataQuality::
error (const error_optional& x)
{
  this->error_ = x;
}

void t_dataQuality::
error (::std::auto_ptr< error_type > x)
{
  this->error_.set (x);
}

const t_dataQuality::rawData_optional& t_dataQuality::
rawData () const
{
  return this->rawData_;
}

t_dataQuality::rawData_optional& t_dataQuality::
rawData ()
{
  return this->rawData_;
}

void t_dataQuality::
rawData (const rawData_type& x)
{
  this->rawData_.set (x);
}

void t_dataQuality::
rawData (const rawData_optional& x)
{
  this->rawData_ = x;
}

void t_dataQuality::
rawData (::std::auto_ptr< rawData_type > x)
{
  this->rawData_.set (x);
}


// t_dataQuality_Error
// 

const t_dataQuality_Error::xyAbsolute_type& t_dataQuality_Error::
xyAbsolute () const
{
  return this->xyAbsolute_.get ();
}

t_dataQuality_Error::xyAbsolute_type& t_dataQuality_Error::
xyAbsolute ()
{
  return this->xyAbsolute_.get ();
}

void t_dataQuality_Error::
xyAbsolute (const xyAbsolute_type& x)
{
  this->xyAbsolute_.set (x);
}

const t_dataQuality_Error::zAbsolute_type& t_dataQuality_Error::
zAbsolute () const
{
  return this->zAbsolute_.get ();
}

t_dataQuality_Error::zAbsolute_type& t_dataQuality_Error::
zAbsolute ()
{
  return this->zAbsolute_.get ();
}

void t_dataQuality_Error::
zAbsolute (const zAbsolute_type& x)
{
  this->zAbsolute_.set (x);
}

const t_dataQuality_Error::xyRelative_type& t_dataQuality_Error::
xyRelative () const
{
  return this->xyRelative_.get ();
}

t_dataQuality_Error::xyRelative_type& t_dataQuality_Error::
xyRelative ()
{
  return this->xyRelative_.get ();
}

void t_dataQuality_Error::
xyRelative (const xyRelative_type& x)
{
  this->xyRelative_.set (x);
}

const t_dataQuality_Error::zRelative_type& t_dataQuality_Error::
zRelative () const
{
  return this->zRelative_.get ();
}

t_dataQuality_Error::zRelative_type& t_dataQuality_Error::
zRelative ()
{
  return this->zRelative_.get ();
}

void t_dataQuality_Error::
zRelative (const zRelative_type& x)
{
  this->zRelative_.set (x);
}


// t_dataQuality_RawData
// 

const t_dataQuality_RawData::date_type& t_dataQuality_RawData::
date () const
{
  return this->date_.get ();
}

t_dataQuality_RawData::date_type& t_dataQuality_RawData::
date ()
{
  return this->date_.get ();
}

void t_dataQuality_RawData::
date (const date_type& x)
{
  this->date_.set (x);
}

void t_dataQuality_RawData::
date (::std::auto_ptr< date_type > x)
{
  this->date_.set (x);
}

const t_dataQuality_RawData::source_type& t_dataQuality_RawData::
source () const
{
  return this->source_.get ();
}

t_dataQuality_RawData::source_type& t_dataQuality_RawData::
source ()
{
  return this->source_.get ();
}

void t_dataQuality_RawData::
source (const source_type& x)
{
  this->source_.set (x);
}

void t_dataQuality_RawData::
source (::std::auto_ptr< source_type > x)
{
  this->source_.set (x);
}

const t_dataQuality_RawData::sourceComment_optional& t_dataQuality_RawData::
sourceComment () const
{
  return this->sourceComment_;
}

t_dataQuality_RawData::sourceComment_optional& t_dataQuality_RawData::
sourceComment ()
{
  return this->sourceComment_;
}

void t_dataQuality_RawData::
sourceComment (const sourceComment_type& x)
{
  this->sourceComment_.set (x);
}

void t_dataQuality_RawData::
sourceComment (const sourceComment_optional& x)
{
  this->sourceComment_ = x;
}

void t_dataQuality_RawData::
sourceComment (::std::auto_ptr< sourceComment_type > x)
{
  this->sourceComment_.set (x);
}

const t_dataQuality_RawData::postProcessing_type& t_dataQuality_RawData::
postProcessing () const
{
  return this->postProcessing_.get ();
}

t_dataQuality_RawData::postProcessing_type& t_dataQuality_RawData::
postProcessing ()
{
  return this->postProcessing_.get ();
}

void t_dataQuality_RawData::
postProcessing (const postProcessing_type& x)
{
  this->postProcessing_.set (x);
}

void t_dataQuality_RawData::
postProcessing (::std::auto_ptr< postProcessing_type > x)
{
  this->postProcessing_.set (x);
}

const t_dataQuality_RawData::postProcessingComment_optional& t_dataQuality_RawData::
postProcessingComment () const
{
  return this->postProcessingComment_;
}

t_dataQuality_RawData::postProcessingComment_optional& t_dataQuality_RawData::
postProcessingComment ()
{
  return this->postProcessingComment_;
}

void t_dataQuality_RawData::
postProcessingComment (const postProcessingComment_type& x)
{
  this->postProcessingComment_.set (x);
}

void t_dataQuality_RawData::
postProcessingComment (const postProcessingComment_optional& x)
{
  this->postProcessingComment_ = x;
}

void t_dataQuality_RawData::
postProcessingComment (::std::auto_ptr< postProcessingComment_type > x)
{
  this->postProcessingComment_.set (x);
}


// t_header
// 

const t_header::geoReference_optional& t_header::
geoReference () const
{
  return this->geoReference_;
}

t_header::geoReference_optional& t_header::
geoReference ()
{
  return this->geoReference_;
}

void t_header::
geoReference (const geoReference_type& x)
{
  this->geoReference_.set (x);
}

void t_header::
geoReference (const geoReference_optional& x)
{
  this->geoReference_ = x;
}

void t_header::
geoReference (::std::auto_ptr< geoReference_type > x)
{
  this->geoReference_.set (x);
}

const t_header::offset_optional& t_header::
offset () const
{
  return this->offset_;
}

t_header::offset_optional& t_header::
offset ()
{
  return this->offset_;
}

void t_header::
offset (const offset_type& x)
{
  this->offset_.set (x);
}

void t_header::
offset (const offset_optional& x)
{
  this->offset_ = x;
}

void t_header::
offset (::std::auto_ptr< offset_type > x)
{
  this->offset_.set (x);
}

const t_header::include_sequence& t_header::
include () const
{
  return this->include_;
}

t_header::include_sequence& t_header::
include ()
{
  return this->include_;
}

void t_header::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_header::userData_sequence& t_header::
userData () const
{
  return this->userData_;
}

t_header::userData_sequence& t_header::
userData ()
{
  return this->userData_;
}

void t_header::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_header::dataQuality_sequence& t_header::
dataQuality () const
{
  return this->dataQuality_;
}

t_header::dataQuality_sequence& t_header::
dataQuality ()
{
  return this->dataQuality_;
}

void t_header::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_header::revMajor_type& t_header::
revMajor () const
{
  return this->revMajor_.get ();
}

t_header::revMajor_type t_header::
revMajor_default_value ()
{
  return revMajor_type (1LL);
}

const t_header::revMinor_type& t_header::
revMinor () const
{
  return this->revMinor_.get ();
}

t_header::revMinor_type& t_header::
revMinor ()
{
  return this->revMinor_.get ();
}

void t_header::
revMinor (const revMinor_type& x)
{
  this->revMinor_.set (x);
}

const t_header::name_optional& t_header::
name () const
{
  return this->name_;
}

t_header::name_optional& t_header::
name ()
{
  return this->name_;
}

void t_header::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_header::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_header::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const t_header::version_optional& t_header::
version () const
{
  return this->version_;
}

t_header::version_optional& t_header::
version ()
{
  return this->version_;
}

void t_header::
version (const version_type& x)
{
  this->version_.set (x);
}

void t_header::
version (const version_optional& x)
{
  this->version_ = x;
}

void t_header::
version (::std::auto_ptr< version_type > x)
{
  this->version_.set (x);
}

const t_header::date_optional& t_header::
date () const
{
  return this->date_;
}

t_header::date_optional& t_header::
date ()
{
  return this->date_;
}

void t_header::
date (const date_type& x)
{
  this->date_.set (x);
}

void t_header::
date (const date_optional& x)
{
  this->date_ = x;
}

void t_header::
date (::std::auto_ptr< date_type > x)
{
  this->date_.set (x);
}

const t_header::north_optional& t_header::
north () const
{
  return this->north_;
}

t_header::north_optional& t_header::
north ()
{
  return this->north_;
}

void t_header::
north (const north_type& x)
{
  this->north_.set (x);
}

void t_header::
north (const north_optional& x)
{
  this->north_ = x;
}

const t_header::south_optional& t_header::
south () const
{
  return this->south_;
}

t_header::south_optional& t_header::
south ()
{
  return this->south_;
}

void t_header::
south (const south_type& x)
{
  this->south_.set (x);
}

void t_header::
south (const south_optional& x)
{
  this->south_ = x;
}

const t_header::east_optional& t_header::
east () const
{
  return this->east_;
}

t_header::east_optional& t_header::
east ()
{
  return this->east_;
}

void t_header::
east (const east_type& x)
{
  this->east_.set (x);
}

void t_header::
east (const east_optional& x)
{
  this->east_ = x;
}

const t_header::west_optional& t_header::
west () const
{
  return this->west_;
}

t_header::west_optional& t_header::
west ()
{
  return this->west_;
}

void t_header::
west (const west_type& x)
{
  this->west_.set (x);
}

void t_header::
west (const west_optional& x)
{
  this->west_ = x;
}

const t_header::vendor_optional& t_header::
vendor () const
{
  return this->vendor_;
}

t_header::vendor_optional& t_header::
vendor ()
{
  return this->vendor_;
}

void t_header::
vendor (const vendor_type& x)
{
  this->vendor_.set (x);
}

void t_header::
vendor (const vendor_optional& x)
{
  this->vendor_ = x;
}

void t_header::
vendor (::std::auto_ptr< vendor_type > x)
{
  this->vendor_.set (x);
}


// t_header_GeoReference
// 

const t_header_GeoReference::include_sequence& t_header_GeoReference::
include () const
{
  return this->include_;
}

t_header_GeoReference::include_sequence& t_header_GeoReference::
include ()
{
  return this->include_;
}

void t_header_GeoReference::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_header_GeoReference::userData_sequence& t_header_GeoReference::
userData () const
{
  return this->userData_;
}

t_header_GeoReference::userData_sequence& t_header_GeoReference::
userData ()
{
  return this->userData_;
}

void t_header_GeoReference::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_header_GeoReference::dataQuality_sequence& t_header_GeoReference::
dataQuality () const
{
  return this->dataQuality_;
}

t_header_GeoReference::dataQuality_sequence& t_header_GeoReference::
dataQuality ()
{
  return this->dataQuality_;
}

void t_header_GeoReference::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_header_Offset
// 

const t_header_Offset::include_sequence& t_header_Offset::
include () const
{
  return this->include_;
}

t_header_Offset::include_sequence& t_header_Offset::
include ()
{
  return this->include_;
}

void t_header_Offset::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_header_Offset::userData_sequence& t_header_Offset::
userData () const
{
  return this->userData_;
}

t_header_Offset::userData_sequence& t_header_Offset::
userData ()
{
  return this->userData_;
}

void t_header_Offset::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_header_Offset::dataQuality_sequence& t_header_Offset::
dataQuality () const
{
  return this->dataQuality_;
}

t_header_Offset::dataQuality_sequence& t_header_Offset::
dataQuality ()
{
  return this->dataQuality_;
}

void t_header_Offset::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_header_Offset::x_type& t_header_Offset::
x () const
{
  return this->x_.get ();
}

t_header_Offset::x_type& t_header_Offset::
x ()
{
  return this->x_.get ();
}

void t_header_Offset::
x (const x_type& x)
{
  this->x_.set (x);
}

const t_header_Offset::y_type& t_header_Offset::
y () const
{
  return this->y_.get ();
}

t_header_Offset::y_type& t_header_Offset::
y ()
{
  return this->y_.get ();
}

void t_header_Offset::
y (const y_type& x)
{
  this->y_.set (x);
}

const t_header_Offset::z_type& t_header_Offset::
z () const
{
  return this->z_.get ();
}

t_header_Offset::z_type& t_header_Offset::
z ()
{
  return this->z_.get ();
}

void t_header_Offset::
z (const z_type& x)
{
  this->z_.set (x);
}

const t_header_Offset::hdg_type& t_header_Offset::
hdg () const
{
  return this->hdg_.get ();
}

t_header_Offset::hdg_type& t_header_Offset::
hdg ()
{
  return this->hdg_.get ();
}

void t_header_Offset::
hdg (const hdg_type& x)
{
  this->hdg_.set (x);
}


// t_include
// 

const t_include::file_type& t_include::
file () const
{
  return this->file_.get ();
}

t_include::file_type& t_include::
file ()
{
  return this->file_.get ();
}

void t_include::
file (const file_type& x)
{
  this->file_.set (x);
}

void t_include::
file (::std::auto_ptr< file_type > x)
{
  this->file_.set (x);
}


// t_userData
// 

const t_userData::code_type& t_userData::
code () const
{
  return this->code_.get ();
}

t_userData::code_type& t_userData::
code ()
{
  return this->code_.get ();
}

void t_userData::
code (const code_type& x)
{
  this->code_.set (x);
}

void t_userData::
code (::std::auto_ptr< code_type > x)
{
  this->code_.set (x);
}

const t_userData::value_optional& t_userData::
value () const
{
  return this->value_;
}

t_userData::value_optional& t_userData::
value ()
{
  return this->value_;
}

void t_userData::
value (const value_type& x)
{
  this->value_.set (x);
}

void t_userData::
value (const value_optional& x)
{
  this->value_ = x;
}

void t_userData::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}


// OpenDRIVE
// 

const OpenDRIVE::header_type& OpenDRIVE::
header () const
{
  return this->header_.get ();
}

OpenDRIVE::header_type& OpenDRIVE::
header ()
{
  return this->header_.get ();
}

void OpenDRIVE::
header (const header_type& x)
{
  this->header_.set (x);
}

void OpenDRIVE::
header (::std::auto_ptr< header_type > x)
{
  this->header_.set (x);
}

const OpenDRIVE::road_sequence& OpenDRIVE::
road () const
{
  return this->road_;
}

OpenDRIVE::road_sequence& OpenDRIVE::
road ()
{
  return this->road_;
}

void OpenDRIVE::
road (const road_sequence& s)
{
  this->road_ = s;
}

const OpenDRIVE::controller_sequence& OpenDRIVE::
controller () const
{
  return this->controller_;
}

OpenDRIVE::controller_sequence& OpenDRIVE::
controller ()
{
  return this->controller_;
}

void OpenDRIVE::
controller (const controller_sequence& s)
{
  this->controller_ = s;
}

const OpenDRIVE::junction_sequence& OpenDRIVE::
junction () const
{
  return this->junction_;
}

OpenDRIVE::junction_sequence& OpenDRIVE::
junction ()
{
  return this->junction_;
}

void OpenDRIVE::
junction (const junction_sequence& s)
{
  this->junction_ = s;
}

const OpenDRIVE::junctionGroup_sequence& OpenDRIVE::
junctionGroup () const
{
  return this->junctionGroup_;
}

OpenDRIVE::junctionGroup_sequence& OpenDRIVE::
junctionGroup ()
{
  return this->junctionGroup_;
}

void OpenDRIVE::
junctionGroup (const junctionGroup_sequence& s)
{
  this->junctionGroup_ = s;
}

const OpenDRIVE::station_sequence& OpenDRIVE::
station () const
{
  return this->station_;
}

OpenDRIVE::station_sequence& OpenDRIVE::
station ()
{
  return this->station_;
}

void OpenDRIVE::
station (const station_sequence& s)
{
  this->station_ = s;
}

const OpenDRIVE::include_sequence& OpenDRIVE::
include () const
{
  return this->include_;
}

OpenDRIVE::include_sequence& OpenDRIVE::
include ()
{
  return this->include_;
}

void OpenDRIVE::
include (const include_sequence& s)
{
  this->include_ = s;
}

const OpenDRIVE::userData_sequence& OpenDRIVE::
userData () const
{
  return this->userData_;
}

OpenDRIVE::userData_sequence& OpenDRIVE::
userData ()
{
  return this->userData_;
}

void OpenDRIVE::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const OpenDRIVE::dataQuality_sequence& OpenDRIVE::
dataQuality () const
{
  return this->dataQuality_;
}

OpenDRIVE::dataQuality_sequence& OpenDRIVE::
dataQuality ()
{
  return this->dataQuality_;
}

void OpenDRIVE::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// e_dataQuality_RawData_PostProcessing
//

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_dataQuality_RawData_PostProcessing_convert ();
}

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_dataQuality_RawData_PostProcessing_convert ();
}

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_dataQuality_RawData_PostProcessing_convert ();
}

e_dataQuality_RawData_PostProcessing* e_dataQuality_RawData_PostProcessing::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_dataQuality_RawData_PostProcessing (*this, f, c);
}

e_dataQuality_RawData_PostProcessing::value e_dataQuality_RawData_PostProcessing::
_xsd_e_dataQuality_RawData_PostProcessing_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_dataQuality_RawData_PostProcessing_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_dataQuality_RawData_PostProcessing_indexes_,
                    _xsd_e_dataQuality_RawData_PostProcessing_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_e_dataQuality_RawData_PostProcessing_indexes_ + 4 || _xsd_e_dataQuality_RawData_PostProcessing_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_dataQuality_RawData_PostProcessing::
_xsd_e_dataQuality_RawData_PostProcessing_literals_[4] =
{
  "raw",
  "cleaned",
  "processed",
  "fused"
};

const e_dataQuality_RawData_PostProcessing::value e_dataQuality_RawData_PostProcessing::
_xsd_e_dataQuality_RawData_PostProcessing_indexes_[4] =
{
  ::e_dataQuality_RawData_PostProcessing::cleaned,
  ::e_dataQuality_RawData_PostProcessing::fused,
  ::e_dataQuality_RawData_PostProcessing::processed,
  ::e_dataQuality_RawData_PostProcessing::raw
};

// e_dataQuality_RawData_Source
//

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_dataQuality_RawData_Source_convert ();
}

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_dataQuality_RawData_Source_convert ();
}

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_dataQuality_RawData_Source_convert ();
}

e_dataQuality_RawData_Source* e_dataQuality_RawData_Source::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_dataQuality_RawData_Source (*this, f, c);
}

e_dataQuality_RawData_Source::value e_dataQuality_RawData_Source::
_xsd_e_dataQuality_RawData_Source_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_dataQuality_RawData_Source_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_dataQuality_RawData_Source_indexes_,
                    _xsd_e_dataQuality_RawData_Source_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_e_dataQuality_RawData_Source_indexes_ + 3 || _xsd_e_dataQuality_RawData_Source_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_dataQuality_RawData_Source::
_xsd_e_dataQuality_RawData_Source_literals_[3] =
{
  "sensor",
  "cadaster",
  "custom"
};

const e_dataQuality_RawData_Source::value e_dataQuality_RawData_Source::
_xsd_e_dataQuality_RawData_Source_indexes_[3] =
{
  ::e_dataQuality_RawData_Source::cadaster,
  ::e_dataQuality_RawData_Source::custom,
  ::e_dataQuality_RawData_Source::sensor
};

// e_unit
//

e_unit::
e_unit (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_unit_convert ();
}

e_unit::
e_unit (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_unit_convert ();
}

e_unit::
e_unit (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_unit_convert ();
}

e_unit* e_unit::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_unit (*this, f, c);
}

e_unit::value e_unit::
_xsd_e_unit_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_unit_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_unit_indexes_,
                    _xsd_e_unit_indexes_ + 10,
                    *this,
                    c));

  if (i == _xsd_e_unit_indexes_ + 10 || _xsd_e_unit_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_unit::
_xsd_e_unit_literals_[10] =
{
  "m",
  "km",
  "ft",
  "mile",
  "m/s",
  "mph",
  "km/h",
  "kg",
  "t",
  "%"
};

const e_unit::value e_unit::
_xsd_e_unit_indexes_[10] =
{
  ::e_unit::cxx_,
  ::e_unit::ft,
  ::e_unit::kg,
  ::e_unit::km,
  ::e_unit::km_h,
  ::e_unit::m,
  ::e_unit::m_s,
  ::e_unit::mile,
  ::e_unit::mph,
  ::e_unit::t
};

// e_unitDistance
//

e_unitDistance::
e_unitDistance (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_unitDistance_convert ();
}

e_unitDistance::
e_unitDistance (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_unitDistance_convert ();
}

e_unitDistance::
e_unitDistance (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_unitDistance_convert ();
}

e_unitDistance* e_unitDistance::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_unitDistance (*this, f, c);
}

e_unitDistance::value e_unitDistance::
_xsd_e_unitDistance_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_unitDistance_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_unitDistance_indexes_,
                    _xsd_e_unitDistance_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_e_unitDistance_indexes_ + 4 || _xsd_e_unitDistance_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_unitDistance::
_xsd_e_unitDistance_literals_[4] =
{
  "m",
  "km",
  "ft",
  "mile"
};

const e_unitDistance::value e_unitDistance::
_xsd_e_unitDistance_indexes_[4] =
{
  ::e_unitDistance::ft,
  ::e_unitDistance::km,
  ::e_unitDistance::m,
  ::e_unitDistance::mile
};

// e_unitMass
//

e_unitMass::
e_unitMass (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_unitMass_convert ();
}

e_unitMass::
e_unitMass (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_unitMass_convert ();
}

e_unitMass::
e_unitMass (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_unitMass_convert ();
}

e_unitMass* e_unitMass::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_unitMass (*this, f, c);
}

e_unitMass::value e_unitMass::
_xsd_e_unitMass_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_unitMass_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_unitMass_indexes_,
                    _xsd_e_unitMass_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_unitMass_indexes_ + 2 || _xsd_e_unitMass_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_unitMass::
_xsd_e_unitMass_literals_[2] =
{
  "kg",
  "t"
};

const e_unitMass::value e_unitMass::
_xsd_e_unitMass_indexes_[2] =
{
  ::e_unitMass::kg,
  ::e_unitMass::t
};

// e_unitSlope
//

e_unitSlope::
e_unitSlope (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_unitSlope_convert ();
}

e_unitSlope::
e_unitSlope (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_unitSlope_convert ();
}

e_unitSlope::
e_unitSlope (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_unitSlope_convert ();
}

e_unitSlope* e_unitSlope::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_unitSlope (*this, f, c);
}

e_unitSlope::value e_unitSlope::
_xsd_e_unitSlope_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_unitSlope_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_unitSlope_indexes_,
                    _xsd_e_unitSlope_indexes_ + 1,
                    *this,
                    c));

  if (i == _xsd_e_unitSlope_indexes_ + 1 || _xsd_e_unitSlope_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_unitSlope::
_xsd_e_unitSlope_literals_[1] =
{
  "%"
};

const e_unitSlope::value e_unitSlope::
_xsd_e_unitSlope_indexes_[1] =
{
  ::e_unitSlope::cxx_
};

// e_unitSpeed
//

e_unitSpeed::
e_unitSpeed (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_unitSpeed_convert ();
}

e_unitSpeed::
e_unitSpeed (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_unitSpeed_convert ();
}

e_unitSpeed::
e_unitSpeed (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_unitSpeed_convert ();
}

e_unitSpeed* e_unitSpeed::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_unitSpeed (*this, f, c);
}

e_unitSpeed::value e_unitSpeed::
_xsd_e_unitSpeed_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_unitSpeed_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_unitSpeed_indexes_,
                    _xsd_e_unitSpeed_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_e_unitSpeed_indexes_ + 3 || _xsd_e_unitSpeed_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_unitSpeed::
_xsd_e_unitSpeed_literals_[3] =
{
  "m/s",
  "mph",
  "km/h"
};

const e_unitSpeed::value e_unitSpeed::
_xsd_e_unitSpeed_indexes_[3] =
{
  ::e_unitSpeed::km_h,
  ::e_unitSpeed::m_s,
  ::e_unitSpeed::mph
};

// t_grEqZero
//

t_grEqZero::
t_grEqZero (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

t_grEqZero::
t_grEqZero (const t_grEqZero& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

t_grEqZero::
t_grEqZero (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

t_grEqZero::
t_grEqZero (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

t_grEqZero::
t_grEqZero (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

t_grEqZero* t_grEqZero::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_grEqZero (*this, f, c);
}

t_grEqZero::
~t_grEqZero ()
{
}

// t_grZero
//

t_grZero::
t_grZero (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

t_grZero::
t_grZero (const t_grZero& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

t_grZero::
t_grZero (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

t_grZero::
t_grZero (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

t_grZero::
t_grZero (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

t_grZero* t_grZero::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_grZero (*this, f, c);
}

t_grZero::
~t_grZero ()
{
}

// t_yesNo
//

t_yesNo::
t_yesNo (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_t_yesNo_convert ();
}

t_yesNo::
t_yesNo (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_t_yesNo_convert ();
}

t_yesNo::
t_yesNo (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_t_yesNo_convert ();
}

t_yesNo* t_yesNo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_yesNo (*this, f, c);
}

t_yesNo::value t_yesNo::
_xsd_t_yesNo_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_t_yesNo_literals_);
  const value* i (::std::lower_bound (
                    _xsd_t_yesNo_indexes_,
                    _xsd_t_yesNo_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_t_yesNo_indexes_ + 2 || _xsd_t_yesNo_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const t_yesNo::
_xsd_t_yesNo_literals_[2] =
{
  "yes",
  "no"
};

const t_yesNo::value t_yesNo::
_xsd_t_yesNo_indexes_[2] =
{
  ::t_yesNo::no,
  ::t_yesNo::yes
};

// t_zeroOne
//

t_zeroOne::
t_zeroOne (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

t_zeroOne::
t_zeroOne (const t_zeroOne& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

t_zeroOne::
t_zeroOne (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

t_zeroOne::
t_zeroOne (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

t_zeroOne::
t_zeroOne (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

t_zeroOne* t_zeroOne::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_zeroOne (*this, f, c);
}

t_zeroOne::
~t_zeroOne ()
{
}

// _OpenDriveElement
//

_OpenDriveElement::
_OpenDriveElement ()
: ::xml_schema::type ()
{
}

_OpenDriveElement::
_OpenDriveElement (const _OpenDriveElement& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

_OpenDriveElement::
_OpenDriveElement (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

_OpenDriveElement::
_OpenDriveElement (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

_OpenDriveElement::
_OpenDriveElement (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

_OpenDriveElement* _OpenDriveElement::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class _OpenDriveElement (*this, f, c);
}

_OpenDriveElement::
~_OpenDriveElement ()
{
}

// t_dataQuality
//

t_dataQuality::
t_dataQuality ()
: ::xml_schema::type (),
  error_ (this),
  rawData_ (this)
{
}

t_dataQuality::
t_dataQuality (const t_dataQuality& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  error_ (x.error_, f, this),
  rawData_ (x.rawData_, f, this)
{
}

t_dataQuality::
t_dataQuality (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  error_ (this),
  rawData_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_dataQuality::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // error
    //
    if (n.name () == "error" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< error_type > r (
        error_traits::create (i, f, this));

      if (!this->error_)
      {
        this->error_.set (r);
        continue;
      }
    }

    // rawData
    //
    if (n.name () == "rawData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rawData_type > r (
        rawData_traits::create (i, f, this));

      if (!this->rawData_)
      {
        this->rawData_.set (r);
        continue;
      }
    }

    break;
  }
}

t_dataQuality* t_dataQuality::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_dataQuality (*this, f, c);
}

t_dataQuality& t_dataQuality::
operator= (const t_dataQuality& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->error_ = x.error_;
    this->rawData_ = x.rawData_;
  }

  return *this;
}

t_dataQuality::
~t_dataQuality ()
{
}

// t_dataQuality_Error
//

t_dataQuality_Error::
t_dataQuality_Error (const xyAbsolute_type& xyAbsolute,
                     const zAbsolute_type& zAbsolute,
                     const xyRelative_type& xyRelative,
                     const zRelative_type& zRelative)
: ::xml_schema::type (),
  xyAbsolute_ (xyAbsolute, this),
  zAbsolute_ (zAbsolute, this),
  xyRelative_ (xyRelative, this),
  zRelative_ (zRelative, this)
{
}

t_dataQuality_Error::
t_dataQuality_Error (const t_dataQuality_Error& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  xyAbsolute_ (x.xyAbsolute_, f, this),
  zAbsolute_ (x.zAbsolute_, f, this),
  xyRelative_ (x.xyRelative_, f, this),
  zRelative_ (x.zRelative_, f, this)
{
}

t_dataQuality_Error::
t_dataQuality_Error (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  xyAbsolute_ (this),
  zAbsolute_ (this),
  xyRelative_ (this),
  zRelative_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_dataQuality_Error::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "xyAbsolute" && n.namespace_ ().empty ())
    {
      this->xyAbsolute_.set (xyAbsolute_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zAbsolute" && n.namespace_ ().empty ())
    {
      this->zAbsolute_.set (zAbsolute_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "xyRelative" && n.namespace_ ().empty ())
    {
      this->xyRelative_.set (xyRelative_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zRelative" && n.namespace_ ().empty ())
    {
      this->zRelative_.set (zRelative_traits::create (i, f, this));
      continue;
    }
  }

  if (!xyAbsolute_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "xyAbsolute",
      "");
  }

  if (!zAbsolute_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zAbsolute",
      "");
  }

  if (!xyRelative_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "xyRelative",
      "");
  }

  if (!zRelative_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zRelative",
      "");
  }
}

t_dataQuality_Error* t_dataQuality_Error::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_dataQuality_Error (*this, f, c);
}

t_dataQuality_Error& t_dataQuality_Error::
operator= (const t_dataQuality_Error& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->xyAbsolute_ = x.xyAbsolute_;
    this->zAbsolute_ = x.zAbsolute_;
    this->xyRelative_ = x.xyRelative_;
    this->zRelative_ = x.zRelative_;
  }

  return *this;
}

t_dataQuality_Error::
~t_dataQuality_Error ()
{
}

// t_dataQuality_RawData
//

t_dataQuality_RawData::
t_dataQuality_RawData (const date_type& date,
                       const source_type& source,
                       const postProcessing_type& postProcessing)
: ::xml_schema::type (),
  date_ (date, this),
  source_ (source, this),
  sourceComment_ (this),
  postProcessing_ (postProcessing, this),
  postProcessingComment_ (this)
{
}

t_dataQuality_RawData::
t_dataQuality_RawData (const t_dataQuality_RawData& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  date_ (x.date_, f, this),
  source_ (x.source_, f, this),
  sourceComment_ (x.sourceComment_, f, this),
  postProcessing_ (x.postProcessing_, f, this),
  postProcessingComment_ (x.postProcessingComment_, f, this)
{
}

t_dataQuality_RawData::
t_dataQuality_RawData (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  date_ (this),
  source_ (this),
  sourceComment_ (this),
  postProcessing_ (this),
  postProcessingComment_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_dataQuality_RawData::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "date" && n.namespace_ ().empty ())
    {
      this->date_.set (date_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "source" && n.namespace_ ().empty ())
    {
      this->source_.set (source_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sourceComment" && n.namespace_ ().empty ())
    {
      this->sourceComment_.set (sourceComment_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "postProcessing" && n.namespace_ ().empty ())
    {
      this->postProcessing_.set (postProcessing_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "postProcessingComment" && n.namespace_ ().empty ())
    {
      this->postProcessingComment_.set (postProcessingComment_traits::create (i, f, this));
      continue;
    }
  }

  if (!date_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "date",
      "");
  }

  if (!source_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "source",
      "");
  }

  if (!postProcessing_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "postProcessing",
      "");
  }
}

t_dataQuality_RawData* t_dataQuality_RawData::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_dataQuality_RawData (*this, f, c);
}

t_dataQuality_RawData& t_dataQuality_RawData::
operator= (const t_dataQuality_RawData& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->date_ = x.date_;
    this->source_ = x.source_;
    this->sourceComment_ = x.sourceComment_;
    this->postProcessing_ = x.postProcessing_;
    this->postProcessingComment_ = x.postProcessingComment_;
  }

  return *this;
}

t_dataQuality_RawData::
~t_dataQuality_RawData ()
{
}

// t_header
//

t_header::
t_header (const revMinor_type& revMinor)
: ::_OpenDriveElement (),
  geoReference_ (this),
  offset_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  revMajor_ (revMajor_default_value (), this),
  revMinor_ (revMinor, this),
  name_ (this),
  version_ (this),
  date_ (this),
  north_ (this),
  south_ (this),
  east_ (this),
  west_ (this),
  vendor_ (this)
{
}

t_header::
t_header (const t_header& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  geoReference_ (x.geoReference_, f, this),
  offset_ (x.offset_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  revMajor_ (x.revMajor_, f, this),
  revMinor_ (x.revMinor_, f, this),
  name_ (x.name_, f, this),
  version_ (x.version_, f, this),
  date_ (x.date_, f, this),
  north_ (x.north_, f, this),
  south_ (x.south_, f, this),
  east_ (x.east_, f, this),
  west_ (x.west_, f, this),
  vendor_ (x.vendor_, f, this)
{
}

t_header::
t_header (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  geoReference_ (this),
  offset_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  revMajor_ (this),
  revMinor_ (this),
  name_ (this),
  version_ (this),
  date_ (this),
  north_ (this),
  south_ (this),
  east_ (this),
  west_ (this),
  vendor_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_header::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // geoReference
    //
    if (n.name () == "geoReference" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geoReference_type > r (
        geoReference_traits::create (i, f, this));

      if (!this->geoReference_)
      {
        this->geoReference_.set (r);
        continue;
      }
    }

    // offset
    //
    if (n.name () == "offset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< offset_type > r (
        offset_traits::create (i, f, this));

      if (!this->offset_)
      {
        this->offset_.set (r);
        continue;
      }
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "revMajor" && n.namespace_ ().empty ())
    {
      this->revMajor_.set (revMajor_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "revMinor" && n.namespace_ ().empty ())
    {
      this->revMinor_.set (revMinor_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "date" && n.namespace_ ().empty ())
    {
      this->date_.set (date_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "north" && n.namespace_ ().empty ())
    {
      this->north_.set (north_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "south" && n.namespace_ ().empty ())
    {
      this->south_.set (south_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "east" && n.namespace_ ().empty ())
    {
      this->east_.set (east_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "west" && n.namespace_ ().empty ())
    {
      this->west_.set (west_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vendor" && n.namespace_ ().empty ())
    {
      this->vendor_.set (vendor_traits::create (i, f, this));
      continue;
    }
  }

  if (!revMajor_.present ())
  {
    this->revMajor_.set (revMajor_default_value ());
  }

  if (!revMinor_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "revMinor",
      "");
  }
}

t_header* t_header::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_header (*this, f, c);
}

t_header& t_header::
operator= (const t_header& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->geoReference_ = x.geoReference_;
    this->offset_ = x.offset_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->revMajor_ = x.revMajor_;
    this->revMinor_ = x.revMinor_;
    this->name_ = x.name_;
    this->version_ = x.version_;
    this->date_ = x.date_;
    this->north_ = x.north_;
    this->south_ = x.south_;
    this->east_ = x.east_;
    this->west_ = x.west_;
    this->vendor_ = x.vendor_;
  }

  return *this;
}

t_header::
~t_header ()
{
}

// t_header_GeoReference
//

t_header_GeoReference::
t_header_GeoReference ()
: ::xml_schema::type (),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_header_GeoReference::
t_header_GeoReference (const t_header_GeoReference& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_header_GeoReference::
t_header_GeoReference (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_header_GeoReference::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_header_GeoReference* t_header_GeoReference::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_header_GeoReference (*this, f, c);
}

t_header_GeoReference& t_header_GeoReference::
operator= (const t_header_GeoReference& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_header_GeoReference::
~t_header_GeoReference ()
{
}

// t_header_Offset
//

t_header_Offset::
t_header_Offset (const x_type& x,
                 const y_type& y,
                 const z_type& z,
                 const hdg_type& hdg)
: ::_OpenDriveElement (),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this),
  hdg_ (hdg, this)
{
}

t_header_Offset::
t_header_Offset (const t_header_Offset& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this),
  hdg_ (x.hdg_, f, this)
{
}

t_header_Offset::
t_header_Offset (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  x_ (this),
  y_ (this),
  z_ (this),
  hdg_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_header_Offset::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hdg" && n.namespace_ ().empty ())
    {
      this->hdg_.set (hdg_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "z",
      "");
  }

  if (!hdg_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "hdg",
      "");
  }
}

t_header_Offset* t_header_Offset::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_header_Offset (*this, f, c);
}

t_header_Offset& t_header_Offset::
operator= (const t_header_Offset& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
    this->hdg_ = x.hdg_;
  }

  return *this;
}

t_header_Offset::
~t_header_Offset ()
{
}

// t_include
//

t_include::
t_include (const file_type& file)
: ::xml_schema::type (),
  file_ (file, this)
{
}

t_include::
t_include (const t_include& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  file_ (x.file_, f, this)
{
}

t_include::
t_include (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  file_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_include::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "file" && n.namespace_ ().empty ())
    {
      this->file_.set (file_traits::create (i, f, this));
      continue;
    }
  }

  if (!file_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "file",
      "");
  }
}

t_include* t_include::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_include (*this, f, c);
}

t_include& t_include::
operator= (const t_include& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->file_ = x.file_;
  }

  return *this;
}

t_include::
~t_include ()
{
}

// t_userData
//

t_userData::
t_userData (const code_type& code)
: ::xml_schema::type (),
  code_ (code, this),
  value_ (this)
{
}

t_userData::
t_userData (const t_userData& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  code_ (x.code_, f, this),
  value_ (x.value_, f, this)
{
}

t_userData::
t_userData (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  code_ (this),
  value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_userData::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "code" && n.namespace_ ().empty ())
    {
      this->code_.set (code_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (value_traits::create (i, f, this));
      continue;
    }
  }

  if (!code_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "code",
      "");
  }
}

t_userData* t_userData::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_userData (*this, f, c);
}

t_userData& t_userData::
operator= (const t_userData& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->code_ = x.code_;
    this->value_ = x.value_;
  }

  return *this;
}

t_userData::
~t_userData ()
{
}

// OpenDRIVE
//

OpenDRIVE::
OpenDRIVE (const header_type& header)
: ::xml_schema::type (),
  header_ (header, this),
  road_ (this),
  controller_ (this),
  junction_ (this),
  junctionGroup_ (this),
  station_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

OpenDRIVE::
OpenDRIVE (::std::auto_ptr< header_type > header)
: ::xml_schema::type (),
  header_ (header, this),
  road_ (this),
  controller_ (this),
  junction_ (this),
  junctionGroup_ (this),
  station_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

OpenDRIVE::
OpenDRIVE (const OpenDRIVE& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  header_ (x.header_, f, this),
  road_ (x.road_, f, this),
  controller_ (x.controller_, f, this),
  junction_ (x.junction_, f, this),
  junctionGroup_ (x.junctionGroup_, f, this),
  station_ (x.station_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

OpenDRIVE::
OpenDRIVE (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  header_ (this),
  road_ (this),
  controller_ (this),
  junction_ (this),
  junctionGroup_ (this),
  station_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void OpenDRIVE::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // header
    //
    if (n.name () == "header" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< header_type > r (
        header_traits::create (i, f, this));

      if (!header_.present ())
      {
        this->header_.set (r);
        continue;
      }
    }

    // road
    //
    if (n.name () == "road" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< road_type > r (
        road_traits::create (i, f, this));

      this->road_.push_back (r);
      continue;
    }

    // controller
    //
    if (n.name () == "controller" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< controller_type > r (
        controller_traits::create (i, f, this));

      this->controller_.push_back (r);
      continue;
    }

    // junction
    //
    if (n.name () == "junction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< junction_type > r (
        junction_traits::create (i, f, this));

      this->junction_.push_back (r);
      continue;
    }

    // junctionGroup
    //
    if (n.name () == "junctionGroup" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< junctionGroup_type > r (
        junctionGroup_traits::create (i, f, this));

      this->junctionGroup_.push_back (r);
      continue;
    }

    // station
    //
    if (n.name () == "station" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< station_type > r (
        station_traits::create (i, f, this));

      this->station_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  if (!header_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "header",
      "");
  }
}

OpenDRIVE* OpenDRIVE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OpenDRIVE (*this, f, c);
}

OpenDRIVE& OpenDRIVE::
operator= (const OpenDRIVE& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->header_ = x.header_;
    this->road_ = x.road_;
    this->controller_ = x.controller_;
    this->junction_ = x.junction_;
    this->junctionGroup_ = x.junctionGroup_;
    this->station_ = x.station_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

OpenDRIVE::
~OpenDRIVE ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::OpenDRIVE_ (isrc, f, p);
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::OpenDRIVE_ (isrc, f, p);
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::OpenDRIVE > (
      ::OpenDRIVE_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "OpenDRIVE" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::OpenDRIVE > r (
      ::xsd::cxx::tree::traits< ::OpenDRIVE, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "OpenDRIVE",
    "");
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "OpenDRIVE" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::OpenDRIVE > r (
      ::xsd::cxx::tree::traits< ::OpenDRIVE, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "OpenDRIVE",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

