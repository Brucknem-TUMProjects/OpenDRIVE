// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "opendrive_16_object.hxx"

// e_borderType
// 

e_borderType::
e_borderType (value v)
: ::xml_schema::string (_xsd_e_borderType_literals_[v])
{
}

e_borderType::
e_borderType (const char* v)
: ::xml_schema::string (v)
{
}

e_borderType::
e_borderType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_borderType::
e_borderType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_borderType::
e_borderType (const e_borderType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_borderType& e_borderType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_borderType_literals_[v]);

  return *this;
}


// e_bridgeType
// 

e_bridgeType::
e_bridgeType (value v)
: ::xml_schema::string (_xsd_e_bridgeType_literals_[v])
{
}

e_bridgeType::
e_bridgeType (const char* v)
: ::xml_schema::string (v)
{
}

e_bridgeType::
e_bridgeType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_bridgeType::
e_bridgeType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_bridgeType::
e_bridgeType (const e_bridgeType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_bridgeType& e_bridgeType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_bridgeType_literals_[v]);

  return *this;
}


// e_objectType
// 

e_objectType::
e_objectType (value v)
: ::xml_schema::string (_xsd_e_objectType_literals_[v])
{
}

e_objectType::
e_objectType (const char* v)
: ::xml_schema::string (v)
{
}

e_objectType::
e_objectType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_objectType::
e_objectType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_objectType::
e_objectType (const e_objectType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_objectType& e_objectType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_objectType_literals_[v]);

  return *this;
}


// e_orientation
// 

e_orientation::
e_orientation (value v)
: ::xml_schema::string (_xsd_e_orientation_literals_[v])
{
}

e_orientation::
e_orientation (const char* v)
: ::xml_schema::string (v)
{
}

e_orientation::
e_orientation (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_orientation::
e_orientation (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_orientation::
e_orientation (const e_orientation& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_orientation& e_orientation::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_orientation_literals_[v]);

  return *this;
}


// e_outlineFillType
// 

e_outlineFillType::
e_outlineFillType (value v)
: ::xml_schema::string (_xsd_e_outlineFillType_literals_[v])
{
}

e_outlineFillType::
e_outlineFillType (const char* v)
: ::xml_schema::string (v)
{
}

e_outlineFillType::
e_outlineFillType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_outlineFillType::
e_outlineFillType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_outlineFillType::
e_outlineFillType (const e_outlineFillType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_outlineFillType& e_outlineFillType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_outlineFillType_literals_[v]);

  return *this;
}


// e_road_objects_object_parkingSpace_access
// 

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (value v)
: ::xml_schema::string (_xsd_e_road_objects_object_parkingSpace_access_literals_[v])
{
}

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (const char* v)
: ::xml_schema::string (v)
{
}

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (const e_road_objects_object_parkingSpace_access& v,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_road_objects_object_parkingSpace_access& e_road_objects_object_parkingSpace_access::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_road_objects_object_parkingSpace_access_literals_[v]);

  return *this;
}


// e_sideType
// 

e_sideType::
e_sideType (value v)
: ::xml_schema::string (_xsd_e_sideType_literals_[v])
{
}

e_sideType::
e_sideType (const char* v)
: ::xml_schema::string (v)
{
}

e_sideType::
e_sideType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_sideType::
e_sideType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_sideType::
e_sideType (const e_sideType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_sideType& e_sideType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_sideType_literals_[v]);

  return *this;
}


// e_tunnelType
// 

e_tunnelType::
e_tunnelType (value v)
: ::xml_schema::string (_xsd_e_tunnelType_literals_[v])
{
}

e_tunnelType::
e_tunnelType (const char* v)
: ::xml_schema::string (v)
{
}

e_tunnelType::
e_tunnelType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_tunnelType::
e_tunnelType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_tunnelType::
e_tunnelType (const e_tunnelType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_tunnelType& e_tunnelType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_tunnelType_literals_[v]);

  return *this;
}


// t_road_objects
// 

const t_road_objects::object_sequence& t_road_objects::
object () const
{
  return this->object_;
}

t_road_objects::object_sequence& t_road_objects::
object ()
{
  return this->object_;
}

void t_road_objects::
object (const object_sequence& s)
{
  this->object_ = s;
}

const t_road_objects::objectReference_sequence& t_road_objects::
objectReference () const
{
  return this->objectReference_;
}

t_road_objects::objectReference_sequence& t_road_objects::
objectReference ()
{
  return this->objectReference_;
}

void t_road_objects::
objectReference (const objectReference_sequence& s)
{
  this->objectReference_ = s;
}

const t_road_objects::tunnel_sequence& t_road_objects::
tunnel () const
{
  return this->tunnel_;
}

t_road_objects::tunnel_sequence& t_road_objects::
tunnel ()
{
  return this->tunnel_;
}

void t_road_objects::
tunnel (const tunnel_sequence& s)
{
  this->tunnel_ = s;
}

const t_road_objects::bridge_sequence& t_road_objects::
bridge () const
{
  return this->bridge_;
}

t_road_objects::bridge_sequence& t_road_objects::
bridge ()
{
  return this->bridge_;
}

void t_road_objects::
bridge (const bridge_sequence& s)
{
  this->bridge_ = s;
}

const t_road_objects::include_sequence& t_road_objects::
include () const
{
  return this->include_;
}

t_road_objects::include_sequence& t_road_objects::
include ()
{
  return this->include_;
}

void t_road_objects::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects::userData_sequence& t_road_objects::
userData () const
{
  return this->userData_;
}

t_road_objects::userData_sequence& t_road_objects::
userData ()
{
  return this->userData_;
}

void t_road_objects::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects::dataQuality_sequence& t_road_objects::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects::dataQuality_sequence& t_road_objects::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_road_objects_bridge
// 

const t_road_objects_bridge::validity_sequence& t_road_objects_bridge::
validity () const
{
  return this->validity_;
}

t_road_objects_bridge::validity_sequence& t_road_objects_bridge::
validity ()
{
  return this->validity_;
}

void t_road_objects_bridge::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const t_road_objects_bridge::include_sequence& t_road_objects_bridge::
include () const
{
  return this->include_;
}

t_road_objects_bridge::include_sequence& t_road_objects_bridge::
include ()
{
  return this->include_;
}

void t_road_objects_bridge::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_bridge::userData_sequence& t_road_objects_bridge::
userData () const
{
  return this->userData_;
}

t_road_objects_bridge::userData_sequence& t_road_objects_bridge::
userData ()
{
  return this->userData_;
}

void t_road_objects_bridge::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_bridge::dataQuality_sequence& t_road_objects_bridge::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_bridge::dataQuality_sequence& t_road_objects_bridge::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_bridge::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_road_objects_bridge::s_type& t_road_objects_bridge::
s () const
{
  return this->s_.get ();
}

t_road_objects_bridge::s_type& t_road_objects_bridge::
s ()
{
  return this->s_.get ();
}

void t_road_objects_bridge::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_objects_bridge::
s (::std::auto_ptr< s_type > x)
{
  this->s_.set (x);
}

const t_road_objects_bridge::length_type& t_road_objects_bridge::
length () const
{
  return this->length_.get ();
}

t_road_objects_bridge::length_type& t_road_objects_bridge::
length ()
{
  return this->length_.get ();
}

void t_road_objects_bridge::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road_objects_bridge::
length (::std::auto_ptr< length_type > x)
{
  this->length_.set (x);
}

const t_road_objects_bridge::name_optional& t_road_objects_bridge::
name () const
{
  return this->name_;
}

t_road_objects_bridge::name_optional& t_road_objects_bridge::
name ()
{
  return this->name_;
}

void t_road_objects_bridge::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_road_objects_bridge::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_road_objects_bridge::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const t_road_objects_bridge::id_type& t_road_objects_bridge::
id () const
{
  return this->id_.get ();
}

t_road_objects_bridge::id_type& t_road_objects_bridge::
id ()
{
  return this->id_.get ();
}

void t_road_objects_bridge::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_objects_bridge::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const t_road_objects_bridge::type_type& t_road_objects_bridge::
type () const
{
  return this->type_.get ();
}

t_road_objects_bridge::type_type& t_road_objects_bridge::
type ()
{
  return this->type_.get ();
}

void t_road_objects_bridge::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_objects_bridge::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// t_road_objects_object
// 

const t_road_objects_object::repeat_sequence& t_road_objects_object::
repeat () const
{
  return this->repeat_;
}

t_road_objects_object::repeat_sequence& t_road_objects_object::
repeat ()
{
  return this->repeat_;
}

void t_road_objects_object::
repeat (const repeat_sequence& s)
{
  this->repeat_ = s;
}

const t_road_objects_object::outline_optional& t_road_objects_object::
outline () const
{
  return this->outline_;
}

t_road_objects_object::outline_optional& t_road_objects_object::
outline ()
{
  return this->outline_;
}

void t_road_objects_object::
outline (const outline_type& x)
{
  this->outline_.set (x);
}

void t_road_objects_object::
outline (const outline_optional& x)
{
  this->outline_ = x;
}

void t_road_objects_object::
outline (::std::auto_ptr< outline_type > x)
{
  this->outline_.set (x);
}

const t_road_objects_object::outlines_optional& t_road_objects_object::
outlines () const
{
  return this->outlines_;
}

t_road_objects_object::outlines_optional& t_road_objects_object::
outlines ()
{
  return this->outlines_;
}

void t_road_objects_object::
outlines (const outlines_type& x)
{
  this->outlines_.set (x);
}

void t_road_objects_object::
outlines (const outlines_optional& x)
{
  this->outlines_ = x;
}

void t_road_objects_object::
outlines (::std::auto_ptr< outlines_type > x)
{
  this->outlines_.set (x);
}

const t_road_objects_object::material_sequence& t_road_objects_object::
material () const
{
  return this->material_;
}

t_road_objects_object::material_sequence& t_road_objects_object::
material ()
{
  return this->material_;
}

void t_road_objects_object::
material (const material_sequence& s)
{
  this->material_ = s;
}

const t_road_objects_object::validity_sequence& t_road_objects_object::
validity () const
{
  return this->validity_;
}

t_road_objects_object::validity_sequence& t_road_objects_object::
validity ()
{
  return this->validity_;
}

void t_road_objects_object::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const t_road_objects_object::parkingSpace_optional& t_road_objects_object::
parkingSpace () const
{
  return this->parkingSpace_;
}

t_road_objects_object::parkingSpace_optional& t_road_objects_object::
parkingSpace ()
{
  return this->parkingSpace_;
}

void t_road_objects_object::
parkingSpace (const parkingSpace_type& x)
{
  this->parkingSpace_.set (x);
}

void t_road_objects_object::
parkingSpace (const parkingSpace_optional& x)
{
  this->parkingSpace_ = x;
}

void t_road_objects_object::
parkingSpace (::std::auto_ptr< parkingSpace_type > x)
{
  this->parkingSpace_.set (x);
}

const t_road_objects_object::markings_optional& t_road_objects_object::
markings () const
{
  return this->markings_;
}

t_road_objects_object::markings_optional& t_road_objects_object::
markings ()
{
  return this->markings_;
}

void t_road_objects_object::
markings (const markings_type& x)
{
  this->markings_.set (x);
}

void t_road_objects_object::
markings (const markings_optional& x)
{
  this->markings_ = x;
}

void t_road_objects_object::
markings (::std::auto_ptr< markings_type > x)
{
  this->markings_.set (x);
}

const t_road_objects_object::borders_optional& t_road_objects_object::
borders () const
{
  return this->borders_;
}

t_road_objects_object::borders_optional& t_road_objects_object::
borders ()
{
  return this->borders_;
}

void t_road_objects_object::
borders (const borders_type& x)
{
  this->borders_.set (x);
}

void t_road_objects_object::
borders (const borders_optional& x)
{
  this->borders_ = x;
}

void t_road_objects_object::
borders (::std::auto_ptr< borders_type > x)
{
  this->borders_.set (x);
}

const t_road_objects_object::include_sequence& t_road_objects_object::
include () const
{
  return this->include_;
}

t_road_objects_object::include_sequence& t_road_objects_object::
include ()
{
  return this->include_;
}

void t_road_objects_object::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object::userData_sequence& t_road_objects_object::
userData () const
{
  return this->userData_;
}

t_road_objects_object::userData_sequence& t_road_objects_object::
userData ()
{
  return this->userData_;
}

void t_road_objects_object::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object::dataQuality_sequence& t_road_objects_object::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object::dataQuality_sequence& t_road_objects_object::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_road_objects_object::t_type& t_road_objects_object::
t () const
{
  return this->t_.get ();
}

t_road_objects_object::t_type& t_road_objects_object::
t ()
{
  return this->t_.get ();
}

void t_road_objects_object::
t (const t_type& x)
{
  this->t_.set (x);
}

const t_road_objects_object::zOffset_type& t_road_objects_object::
zOffset () const
{
  return this->zOffset_.get ();
}

t_road_objects_object::zOffset_type& t_road_objects_object::
zOffset ()
{
  return this->zOffset_.get ();
}

void t_road_objects_object::
zOffset (const zOffset_type& x)
{
  this->zOffset_.set (x);
}

const t_road_objects_object::type_optional& t_road_objects_object::
type () const
{
  return this->type_;
}

t_road_objects_object::type_optional& t_road_objects_object::
type ()
{
  return this->type_;
}

void t_road_objects_object::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_objects_object::
type (const type_optional& x)
{
  this->type_ = x;
}

void t_road_objects_object::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const t_road_objects_object::validLength_optional& t_road_objects_object::
validLength () const
{
  return this->validLength_;
}

t_road_objects_object::validLength_optional& t_road_objects_object::
validLength ()
{
  return this->validLength_;
}

void t_road_objects_object::
validLength (const validLength_type& x)
{
  this->validLength_.set (x);
}

void t_road_objects_object::
validLength (const validLength_optional& x)
{
  this->validLength_ = x;
}

void t_road_objects_object::
validLength (::std::auto_ptr< validLength_type > x)
{
  this->validLength_.set (x);
}

const t_road_objects_object::orientation_optional& t_road_objects_object::
orientation () const
{
  return this->orientation_;
}

t_road_objects_object::orientation_optional& t_road_objects_object::
orientation ()
{
  return this->orientation_;
}

void t_road_objects_object::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void t_road_objects_object::
orientation (const orientation_optional& x)
{
  this->orientation_ = x;
}

void t_road_objects_object::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}

const t_road_objects_object::subtype_optional& t_road_objects_object::
subtype () const
{
  return this->subtype_;
}

t_road_objects_object::subtype_optional& t_road_objects_object::
subtype ()
{
  return this->subtype_;
}

void t_road_objects_object::
subtype (const subtype_type& x)
{
  this->subtype_.set (x);
}

void t_road_objects_object::
subtype (const subtype_optional& x)
{
  this->subtype_ = x;
}

void t_road_objects_object::
subtype (::std::auto_ptr< subtype_type > x)
{
  this->subtype_.set (x);
}

const t_road_objects_object::dynamic_optional& t_road_objects_object::
dynamic () const
{
  return this->dynamic_;
}

t_road_objects_object::dynamic_optional& t_road_objects_object::
dynamic ()
{
  return this->dynamic_;
}

void t_road_objects_object::
dynamic (const dynamic_type& x)
{
  this->dynamic_.set (x);
}

void t_road_objects_object::
dynamic (const dynamic_optional& x)
{
  this->dynamic_ = x;
}

void t_road_objects_object::
dynamic (::std::auto_ptr< dynamic_type > x)
{
  this->dynamic_.set (x);
}

const t_road_objects_object::hdg_optional& t_road_objects_object::
hdg () const
{
  return this->hdg_;
}

t_road_objects_object::hdg_optional& t_road_objects_object::
hdg ()
{
  return this->hdg_;
}

void t_road_objects_object::
hdg (const hdg_type& x)
{
  this->hdg_.set (x);
}

void t_road_objects_object::
hdg (const hdg_optional& x)
{
  this->hdg_ = x;
}

const t_road_objects_object::name_optional& t_road_objects_object::
name () const
{
  return this->name_;
}

t_road_objects_object::name_optional& t_road_objects_object::
name ()
{
  return this->name_;
}

void t_road_objects_object::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_road_objects_object::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_road_objects_object::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const t_road_objects_object::pitch_optional& t_road_objects_object::
pitch () const
{
  return this->pitch_;
}

t_road_objects_object::pitch_optional& t_road_objects_object::
pitch ()
{
  return this->pitch_;
}

void t_road_objects_object::
pitch (const pitch_type& x)
{
  this->pitch_.set (x);
}

void t_road_objects_object::
pitch (const pitch_optional& x)
{
  this->pitch_ = x;
}

const t_road_objects_object::id_type& t_road_objects_object::
id () const
{
  return this->id_.get ();
}

t_road_objects_object::id_type& t_road_objects_object::
id ()
{
  return this->id_.get ();
}

void t_road_objects_object::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_objects_object::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const t_road_objects_object::roll_optional& t_road_objects_object::
roll () const
{
  return this->roll_;
}

t_road_objects_object::roll_optional& t_road_objects_object::
roll ()
{
  return this->roll_;
}

void t_road_objects_object::
roll (const roll_type& x)
{
  this->roll_.set (x);
}

void t_road_objects_object::
roll (const roll_optional& x)
{
  this->roll_ = x;
}

const t_road_objects_object::height_optional& t_road_objects_object::
height () const
{
  return this->height_;
}

t_road_objects_object::height_optional& t_road_objects_object::
height ()
{
  return this->height_;
}

void t_road_objects_object::
height (const height_type& x)
{
  this->height_.set (x);
}

void t_road_objects_object::
height (const height_optional& x)
{
  this->height_ = x;
}

const t_road_objects_object::s_type& t_road_objects_object::
s () const
{
  return this->s_.get ();
}

t_road_objects_object::s_type& t_road_objects_object::
s ()
{
  return this->s_.get ();
}

void t_road_objects_object::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_objects_object::
s (::std::auto_ptr< s_type > x)
{
  this->s_.set (x);
}

const t_road_objects_object::length_optional& t_road_objects_object::
length () const
{
  return this->length_;
}

t_road_objects_object::length_optional& t_road_objects_object::
length ()
{
  return this->length_;
}

void t_road_objects_object::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road_objects_object::
length (const length_optional& x)
{
  this->length_ = x;
}

const t_road_objects_object::width_optional& t_road_objects_object::
width () const
{
  return this->width_;
}

t_road_objects_object::width_optional& t_road_objects_object::
width ()
{
  return this->width_;
}

void t_road_objects_object::
width (const width_type& x)
{
  this->width_.set (x);
}

void t_road_objects_object::
width (const width_optional& x)
{
  this->width_ = x;
}

const t_road_objects_object::radius_optional& t_road_objects_object::
radius () const
{
  return this->radius_;
}

t_road_objects_object::radius_optional& t_road_objects_object::
radius ()
{
  return this->radius_;
}

void t_road_objects_object::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void t_road_objects_object::
radius (const radius_optional& x)
{
  this->radius_ = x;
}


// t_road_objects_object_borders
// 

const t_road_objects_object_borders::border_sequence& t_road_objects_object_borders::
border () const
{
  return this->border_;
}

t_road_objects_object_borders::border_sequence& t_road_objects_object_borders::
border ()
{
  return this->border_;
}

void t_road_objects_object_borders::
border (const border_sequence& s)
{
  this->border_ = s;
}

const t_road_objects_object_borders::include_sequence& t_road_objects_object_borders::
include () const
{
  return this->include_;
}

t_road_objects_object_borders::include_sequence& t_road_objects_object_borders::
include ()
{
  return this->include_;
}

void t_road_objects_object_borders::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_borders::userData_sequence& t_road_objects_object_borders::
userData () const
{
  return this->userData_;
}

t_road_objects_object_borders::userData_sequence& t_road_objects_object_borders::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_borders::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_borders::dataQuality_sequence& t_road_objects_object_borders::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_borders::dataQuality_sequence& t_road_objects_object_borders::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_borders::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_road_objects_object_borders_border
// 

const t_road_objects_object_borders_border::cornerReference_sequence& t_road_objects_object_borders_border::
cornerReference () const
{
  return this->cornerReference_;
}

t_road_objects_object_borders_border::cornerReference_sequence& t_road_objects_object_borders_border::
cornerReference ()
{
  return this->cornerReference_;
}

void t_road_objects_object_borders_border::
cornerReference (const cornerReference_sequence& s)
{
  this->cornerReference_ = s;
}

const t_road_objects_object_borders_border::include_sequence& t_road_objects_object_borders_border::
include () const
{
  return this->include_;
}

t_road_objects_object_borders_border::include_sequence& t_road_objects_object_borders_border::
include ()
{
  return this->include_;
}

void t_road_objects_object_borders_border::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_borders_border::userData_sequence& t_road_objects_object_borders_border::
userData () const
{
  return this->userData_;
}

t_road_objects_object_borders_border::userData_sequence& t_road_objects_object_borders_border::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_borders_border::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_borders_border::dataQuality_sequence& t_road_objects_object_borders_border::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_borders_border::dataQuality_sequence& t_road_objects_object_borders_border::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_borders_border::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_road_objects_object_borders_border::width_type& t_road_objects_object_borders_border::
width () const
{
  return this->width_.get ();
}

t_road_objects_object_borders_border::width_type& t_road_objects_object_borders_border::
width ()
{
  return this->width_.get ();
}

void t_road_objects_object_borders_border::
width (const width_type& x)
{
  this->width_.set (x);
}

void t_road_objects_object_borders_border::
width (::std::auto_ptr< width_type > x)
{
  this->width_.set (x);
}

const t_road_objects_object_borders_border::type_type& t_road_objects_object_borders_border::
type () const
{
  return this->type_.get ();
}

t_road_objects_object_borders_border::type_type& t_road_objects_object_borders_border::
type ()
{
  return this->type_.get ();
}

void t_road_objects_object_borders_border::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_objects_object_borders_border::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const t_road_objects_object_borders_border::outlineId_type& t_road_objects_object_borders_border::
outlineId () const
{
  return this->outlineId_.get ();
}

t_road_objects_object_borders_border::outlineId_type& t_road_objects_object_borders_border::
outlineId ()
{
  return this->outlineId_.get ();
}

void t_road_objects_object_borders_border::
outlineId (const outlineId_type& x)
{
  this->outlineId_.set (x);
}

const t_road_objects_object_borders_border::useCompleteOutline_optional& t_road_objects_object_borders_border::
useCompleteOutline () const
{
  return this->useCompleteOutline_;
}

t_road_objects_object_borders_border::useCompleteOutline_optional& t_road_objects_object_borders_border::
useCompleteOutline ()
{
  return this->useCompleteOutline_;
}

void t_road_objects_object_borders_border::
useCompleteOutline (const useCompleteOutline_type& x)
{
  this->useCompleteOutline_.set (x);
}

void t_road_objects_object_borders_border::
useCompleteOutline (const useCompleteOutline_optional& x)
{
  this->useCompleteOutline_ = x;
}

void t_road_objects_object_borders_border::
useCompleteOutline (::std::auto_ptr< useCompleteOutline_type > x)
{
  this->useCompleteOutline_.set (x);
}


// t_road_objects_object_markings
// 

const t_road_objects_object_markings::marking_sequence& t_road_objects_object_markings::
marking () const
{
  return this->marking_;
}

t_road_objects_object_markings::marking_sequence& t_road_objects_object_markings::
marking ()
{
  return this->marking_;
}

void t_road_objects_object_markings::
marking (const marking_sequence& s)
{
  this->marking_ = s;
}

const t_road_objects_object_markings::include_sequence& t_road_objects_object_markings::
include () const
{
  return this->include_;
}

t_road_objects_object_markings::include_sequence& t_road_objects_object_markings::
include ()
{
  return this->include_;
}

void t_road_objects_object_markings::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_markings::userData_sequence& t_road_objects_object_markings::
userData () const
{
  return this->userData_;
}

t_road_objects_object_markings::userData_sequence& t_road_objects_object_markings::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_markings::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_markings::dataQuality_sequence& t_road_objects_object_markings::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_markings::dataQuality_sequence& t_road_objects_object_markings::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_markings::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_road_objects_object_markings_marking
// 

const t_road_objects_object_markings_marking::cornerReference_sequence& t_road_objects_object_markings_marking::
cornerReference () const
{
  return this->cornerReference_;
}

t_road_objects_object_markings_marking::cornerReference_sequence& t_road_objects_object_markings_marking::
cornerReference ()
{
  return this->cornerReference_;
}

void t_road_objects_object_markings_marking::
cornerReference (const cornerReference_sequence& s)
{
  this->cornerReference_ = s;
}

const t_road_objects_object_markings_marking::include_sequence& t_road_objects_object_markings_marking::
include () const
{
  return this->include_;
}

t_road_objects_object_markings_marking::include_sequence& t_road_objects_object_markings_marking::
include ()
{
  return this->include_;
}

void t_road_objects_object_markings_marking::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_markings_marking::userData_sequence& t_road_objects_object_markings_marking::
userData () const
{
  return this->userData_;
}

t_road_objects_object_markings_marking::userData_sequence& t_road_objects_object_markings_marking::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_markings_marking::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_markings_marking::dataQuality_sequence& t_road_objects_object_markings_marking::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_markings_marking::dataQuality_sequence& t_road_objects_object_markings_marking::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_markings_marking::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_road_objects_object_markings_marking::side_type& t_road_objects_object_markings_marking::
side () const
{
  return this->side_.get ();
}

t_road_objects_object_markings_marking::side_type& t_road_objects_object_markings_marking::
side ()
{
  return this->side_.get ();
}

void t_road_objects_object_markings_marking::
side (const side_type& x)
{
  this->side_.set (x);
}

void t_road_objects_object_markings_marking::
side (::std::auto_ptr< side_type > x)
{
  this->side_.set (x);
}

const t_road_objects_object_markings_marking::weight_optional& t_road_objects_object_markings_marking::
weight () const
{
  return this->weight_;
}

t_road_objects_object_markings_marking::weight_optional& t_road_objects_object_markings_marking::
weight ()
{
  return this->weight_;
}

void t_road_objects_object_markings_marking::
weight (const weight_type& x)
{
  this->weight_.set (x);
}

void t_road_objects_object_markings_marking::
weight (const weight_optional& x)
{
  this->weight_ = x;
}

void t_road_objects_object_markings_marking::
weight (::std::auto_ptr< weight_type > x)
{
  this->weight_.set (x);
}

const t_road_objects_object_markings_marking::width_optional& t_road_objects_object_markings_marking::
width () const
{
  return this->width_;
}

t_road_objects_object_markings_marking::width_optional& t_road_objects_object_markings_marking::
width ()
{
  return this->width_;
}

void t_road_objects_object_markings_marking::
width (const width_type& x)
{
  this->width_.set (x);
}

void t_road_objects_object_markings_marking::
width (const width_optional& x)
{
  this->width_ = x;
}

void t_road_objects_object_markings_marking::
width (::std::auto_ptr< width_type > x)
{
  this->width_.set (x);
}

const t_road_objects_object_markings_marking::color_type& t_road_objects_object_markings_marking::
color () const
{
  return this->color_.get ();
}

t_road_objects_object_markings_marking::color_type& t_road_objects_object_markings_marking::
color ()
{
  return this->color_.get ();
}

void t_road_objects_object_markings_marking::
color (const color_type& x)
{
  this->color_.set (x);
}

void t_road_objects_object_markings_marking::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}

const t_road_objects_object_markings_marking::zOffset_optional& t_road_objects_object_markings_marking::
zOffset () const
{
  return this->zOffset_;
}

t_road_objects_object_markings_marking::zOffset_optional& t_road_objects_object_markings_marking::
zOffset ()
{
  return this->zOffset_;
}

void t_road_objects_object_markings_marking::
zOffset (const zOffset_type& x)
{
  this->zOffset_.set (x);
}

void t_road_objects_object_markings_marking::
zOffset (const zOffset_optional& x)
{
  this->zOffset_ = x;
}

void t_road_objects_object_markings_marking::
zOffset (::std::auto_ptr< zOffset_type > x)
{
  this->zOffset_.set (x);
}

const t_road_objects_object_markings_marking::spaceLength_type& t_road_objects_object_markings_marking::
spaceLength () const
{
  return this->spaceLength_.get ();
}

t_road_objects_object_markings_marking::spaceLength_type& t_road_objects_object_markings_marking::
spaceLength ()
{
  return this->spaceLength_.get ();
}

void t_road_objects_object_markings_marking::
spaceLength (const spaceLength_type& x)
{
  this->spaceLength_.set (x);
}

void t_road_objects_object_markings_marking::
spaceLength (::std::auto_ptr< spaceLength_type > x)
{
  this->spaceLength_.set (x);
}

const t_road_objects_object_markings_marking::lineLength_type& t_road_objects_object_markings_marking::
lineLength () const
{
  return this->lineLength_.get ();
}

t_road_objects_object_markings_marking::lineLength_type& t_road_objects_object_markings_marking::
lineLength ()
{
  return this->lineLength_.get ();
}

void t_road_objects_object_markings_marking::
lineLength (const lineLength_type& x)
{
  this->lineLength_.set (x);
}

void t_road_objects_object_markings_marking::
lineLength (::std::auto_ptr< lineLength_type > x)
{
  this->lineLength_.set (x);
}

const t_road_objects_object_markings_marking::startOffset_type& t_road_objects_object_markings_marking::
startOffset () const
{
  return this->startOffset_.get ();
}

t_road_objects_object_markings_marking::startOffset_type& t_road_objects_object_markings_marking::
startOffset ()
{
  return this->startOffset_.get ();
}

void t_road_objects_object_markings_marking::
startOffset (const startOffset_type& x)
{
  this->startOffset_.set (x);
}

const t_road_objects_object_markings_marking::stopOffset_type& t_road_objects_object_markings_marking::
stopOffset () const
{
  return this->stopOffset_.get ();
}

t_road_objects_object_markings_marking::stopOffset_type& t_road_objects_object_markings_marking::
stopOffset ()
{
  return this->stopOffset_.get ();
}

void t_road_objects_object_markings_marking::
stopOffset (const stopOffset_type& x)
{
  this->stopOffset_.set (x);
}


// t_road_objects_object_markings_marking_cornerReference
// 

const t_road_objects_object_markings_marking_cornerReference::id_type& t_road_objects_object_markings_marking_cornerReference::
id () const
{
  return this->id_.get ();
}

t_road_objects_object_markings_marking_cornerReference::id_type& t_road_objects_object_markings_marking_cornerReference::
id ()
{
  return this->id_.get ();
}

void t_road_objects_object_markings_marking_cornerReference::
id (const id_type& x)
{
  this->id_.set (x);
}


// t_road_objects_object_material
// 

const t_road_objects_object_material::surface_optional& t_road_objects_object_material::
surface () const
{
  return this->surface_;
}

t_road_objects_object_material::surface_optional& t_road_objects_object_material::
surface ()
{
  return this->surface_;
}

void t_road_objects_object_material::
surface (const surface_type& x)
{
  this->surface_.set (x);
}

void t_road_objects_object_material::
surface (const surface_optional& x)
{
  this->surface_ = x;
}

void t_road_objects_object_material::
surface (::std::auto_ptr< surface_type > x)
{
  this->surface_.set (x);
}

const t_road_objects_object_material::friction_optional& t_road_objects_object_material::
friction () const
{
  return this->friction_;
}

t_road_objects_object_material::friction_optional& t_road_objects_object_material::
friction ()
{
  return this->friction_;
}

void t_road_objects_object_material::
friction (const friction_type& x)
{
  this->friction_.set (x);
}

void t_road_objects_object_material::
friction (const friction_optional& x)
{
  this->friction_ = x;
}

void t_road_objects_object_material::
friction (::std::auto_ptr< friction_type > x)
{
  this->friction_.set (x);
}

const t_road_objects_object_material::roughness_optional& t_road_objects_object_material::
roughness () const
{
  return this->roughness_;
}

t_road_objects_object_material::roughness_optional& t_road_objects_object_material::
roughness ()
{
  return this->roughness_;
}

void t_road_objects_object_material::
roughness (const roughness_type& x)
{
  this->roughness_.set (x);
}

void t_road_objects_object_material::
roughness (const roughness_optional& x)
{
  this->roughness_ = x;
}

void t_road_objects_object_material::
roughness (::std::auto_ptr< roughness_type > x)
{
  this->roughness_.set (x);
}


// t_road_objects_object_outlines
// 

const t_road_objects_object_outlines::outline_sequence& t_road_objects_object_outlines::
outline () const
{
  return this->outline_;
}

t_road_objects_object_outlines::outline_sequence& t_road_objects_object_outlines::
outline ()
{
  return this->outline_;
}

void t_road_objects_object_outlines::
outline (const outline_sequence& s)
{
  this->outline_ = s;
}

const t_road_objects_object_outlines::include_sequence& t_road_objects_object_outlines::
include () const
{
  return this->include_;
}

t_road_objects_object_outlines::include_sequence& t_road_objects_object_outlines::
include ()
{
  return this->include_;
}

void t_road_objects_object_outlines::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_outlines::userData_sequence& t_road_objects_object_outlines::
userData () const
{
  return this->userData_;
}

t_road_objects_object_outlines::userData_sequence& t_road_objects_object_outlines::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_outlines::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_outlines::dataQuality_sequence& t_road_objects_object_outlines::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_outlines::dataQuality_sequence& t_road_objects_object_outlines::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_outlines::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_road_objects_object_outlines_outline
// 

const t_road_objects_object_outlines_outline::cornerRoad_sequence& t_road_objects_object_outlines_outline::
cornerRoad () const
{
  return this->cornerRoad_;
}

t_road_objects_object_outlines_outline::cornerRoad_sequence& t_road_objects_object_outlines_outline::
cornerRoad ()
{
  return this->cornerRoad_;
}

void t_road_objects_object_outlines_outline::
cornerRoad (const cornerRoad_sequence& s)
{
  this->cornerRoad_ = s;
}

const t_road_objects_object_outlines_outline::cornerLocal_sequence& t_road_objects_object_outlines_outline::
cornerLocal () const
{
  return this->cornerLocal_;
}

t_road_objects_object_outlines_outline::cornerLocal_sequence& t_road_objects_object_outlines_outline::
cornerLocal ()
{
  return this->cornerLocal_;
}

void t_road_objects_object_outlines_outline::
cornerLocal (const cornerLocal_sequence& s)
{
  this->cornerLocal_ = s;
}

const t_road_objects_object_outlines_outline::include_sequence& t_road_objects_object_outlines_outline::
include () const
{
  return this->include_;
}

t_road_objects_object_outlines_outline::include_sequence& t_road_objects_object_outlines_outline::
include ()
{
  return this->include_;
}

void t_road_objects_object_outlines_outline::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_outlines_outline::userData_sequence& t_road_objects_object_outlines_outline::
userData () const
{
  return this->userData_;
}

t_road_objects_object_outlines_outline::userData_sequence& t_road_objects_object_outlines_outline::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_outlines_outline::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_outlines_outline::dataQuality_sequence& t_road_objects_object_outlines_outline::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_outlines_outline::dataQuality_sequence& t_road_objects_object_outlines_outline::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_outlines_outline::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_road_objects_object_outlines_outline::id_optional& t_road_objects_object_outlines_outline::
id () const
{
  return this->id_;
}

t_road_objects_object_outlines_outline::id_optional& t_road_objects_object_outlines_outline::
id ()
{
  return this->id_;
}

void t_road_objects_object_outlines_outline::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_objects_object_outlines_outline::
id (const id_optional& x)
{
  this->id_ = x;
}

const t_road_objects_object_outlines_outline::fillType_optional& t_road_objects_object_outlines_outline::
fillType () const
{
  return this->fillType_;
}

t_road_objects_object_outlines_outline::fillType_optional& t_road_objects_object_outlines_outline::
fillType ()
{
  return this->fillType_;
}

void t_road_objects_object_outlines_outline::
fillType (const fillType_type& x)
{
  this->fillType_.set (x);
}

void t_road_objects_object_outlines_outline::
fillType (const fillType_optional& x)
{
  this->fillType_ = x;
}

void t_road_objects_object_outlines_outline::
fillType (::std::auto_ptr< fillType_type > x)
{
  this->fillType_.set (x);
}

const t_road_objects_object_outlines_outline::outer_optional& t_road_objects_object_outlines_outline::
outer () const
{
  return this->outer_;
}

t_road_objects_object_outlines_outline::outer_optional& t_road_objects_object_outlines_outline::
outer ()
{
  return this->outer_;
}

void t_road_objects_object_outlines_outline::
outer (const outer_type& x)
{
  this->outer_.set (x);
}

void t_road_objects_object_outlines_outline::
outer (const outer_optional& x)
{
  this->outer_ = x;
}

void t_road_objects_object_outlines_outline::
outer (::std::auto_ptr< outer_type > x)
{
  this->outer_.set (x);
}

const t_road_objects_object_outlines_outline::closed_optional& t_road_objects_object_outlines_outline::
closed () const
{
  return this->closed_;
}

t_road_objects_object_outlines_outline::closed_optional& t_road_objects_object_outlines_outline::
closed ()
{
  return this->closed_;
}

void t_road_objects_object_outlines_outline::
closed (const closed_type& x)
{
  this->closed_.set (x);
}

void t_road_objects_object_outlines_outline::
closed (const closed_optional& x)
{
  this->closed_ = x;
}

void t_road_objects_object_outlines_outline::
closed (::std::auto_ptr< closed_type > x)
{
  this->closed_.set (x);
}

const t_road_objects_object_outlines_outline::laneType_optional& t_road_objects_object_outlines_outline::
laneType () const
{
  return this->laneType_;
}

t_road_objects_object_outlines_outline::laneType_optional& t_road_objects_object_outlines_outline::
laneType ()
{
  return this->laneType_;
}

void t_road_objects_object_outlines_outline::
laneType (const laneType_type& x)
{
  this->laneType_.set (x);
}

void t_road_objects_object_outlines_outline::
laneType (const laneType_optional& x)
{
  this->laneType_ = x;
}

void t_road_objects_object_outlines_outline::
laneType (::std::auto_ptr< laneType_type > x)
{
  this->laneType_.set (x);
}


// t_road_objects_object_outlines_outline_cornerLocal
// 

const t_road_objects_object_outlines_outline_cornerLocal::u_type& t_road_objects_object_outlines_outline_cornerLocal::
u () const
{
  return this->u_.get ();
}

t_road_objects_object_outlines_outline_cornerLocal::u_type& t_road_objects_object_outlines_outline_cornerLocal::
u ()
{
  return this->u_.get ();
}

void t_road_objects_object_outlines_outline_cornerLocal::
u (const u_type& x)
{
  this->u_.set (x);
}

const t_road_objects_object_outlines_outline_cornerLocal::v_type& t_road_objects_object_outlines_outline_cornerLocal::
v () const
{
  return this->v_.get ();
}

t_road_objects_object_outlines_outline_cornerLocal::v_type& t_road_objects_object_outlines_outline_cornerLocal::
v ()
{
  return this->v_.get ();
}

void t_road_objects_object_outlines_outline_cornerLocal::
v (const v_type& x)
{
  this->v_.set (x);
}

const t_road_objects_object_outlines_outline_cornerLocal::z_type& t_road_objects_object_outlines_outline_cornerLocal::
z () const
{
  return this->z_.get ();
}

t_road_objects_object_outlines_outline_cornerLocal::z_type& t_road_objects_object_outlines_outline_cornerLocal::
z ()
{
  return this->z_.get ();
}

void t_road_objects_object_outlines_outline_cornerLocal::
z (const z_type& x)
{
  this->z_.set (x);
}

const t_road_objects_object_outlines_outline_cornerLocal::height_type& t_road_objects_object_outlines_outline_cornerLocal::
height () const
{
  return this->height_.get ();
}

t_road_objects_object_outlines_outline_cornerLocal::height_type& t_road_objects_object_outlines_outline_cornerLocal::
height ()
{
  return this->height_.get ();
}

void t_road_objects_object_outlines_outline_cornerLocal::
height (const height_type& x)
{
  this->height_.set (x);
}

const t_road_objects_object_outlines_outline_cornerLocal::id_optional& t_road_objects_object_outlines_outline_cornerLocal::
id () const
{
  return this->id_;
}

t_road_objects_object_outlines_outline_cornerLocal::id_optional& t_road_objects_object_outlines_outline_cornerLocal::
id ()
{
  return this->id_;
}

void t_road_objects_object_outlines_outline_cornerLocal::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_objects_object_outlines_outline_cornerLocal::
id (const id_optional& x)
{
  this->id_ = x;
}


// t_road_objects_object_outlines_outline_cornerRoad
// 

const t_road_objects_object_outlines_outline_cornerRoad::s_type& t_road_objects_object_outlines_outline_cornerRoad::
s () const
{
  return this->s_.get ();
}

t_road_objects_object_outlines_outline_cornerRoad::s_type& t_road_objects_object_outlines_outline_cornerRoad::
s ()
{
  return this->s_.get ();
}

void t_road_objects_object_outlines_outline_cornerRoad::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_objects_object_outlines_outline_cornerRoad::
s (::std::auto_ptr< s_type > x)
{
  this->s_.set (x);
}

const t_road_objects_object_outlines_outline_cornerRoad::t_type& t_road_objects_object_outlines_outline_cornerRoad::
t () const
{
  return this->t_.get ();
}

t_road_objects_object_outlines_outline_cornerRoad::t_type& t_road_objects_object_outlines_outline_cornerRoad::
t ()
{
  return this->t_.get ();
}

void t_road_objects_object_outlines_outline_cornerRoad::
t (const t_type& x)
{
  this->t_.set (x);
}

const t_road_objects_object_outlines_outline_cornerRoad::dz_type& t_road_objects_object_outlines_outline_cornerRoad::
dz () const
{
  return this->dz_.get ();
}

t_road_objects_object_outlines_outline_cornerRoad::dz_type& t_road_objects_object_outlines_outline_cornerRoad::
dz ()
{
  return this->dz_.get ();
}

void t_road_objects_object_outlines_outline_cornerRoad::
dz (const dz_type& x)
{
  this->dz_.set (x);
}

const t_road_objects_object_outlines_outline_cornerRoad::height_type& t_road_objects_object_outlines_outline_cornerRoad::
height () const
{
  return this->height_.get ();
}

t_road_objects_object_outlines_outline_cornerRoad::height_type& t_road_objects_object_outlines_outline_cornerRoad::
height ()
{
  return this->height_.get ();
}

void t_road_objects_object_outlines_outline_cornerRoad::
height (const height_type& x)
{
  this->height_.set (x);
}

const t_road_objects_object_outlines_outline_cornerRoad::id_optional& t_road_objects_object_outlines_outline_cornerRoad::
id () const
{
  return this->id_;
}

t_road_objects_object_outlines_outline_cornerRoad::id_optional& t_road_objects_object_outlines_outline_cornerRoad::
id ()
{
  return this->id_;
}

void t_road_objects_object_outlines_outline_cornerRoad::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_objects_object_outlines_outline_cornerRoad::
id (const id_optional& x)
{
  this->id_ = x;
}


// t_road_objects_object_parkingSpace
// 

const t_road_objects_object_parkingSpace::access_type& t_road_objects_object_parkingSpace::
access () const
{
  return this->access_.get ();
}

t_road_objects_object_parkingSpace::access_type& t_road_objects_object_parkingSpace::
access ()
{
  return this->access_.get ();
}

void t_road_objects_object_parkingSpace::
access (const access_type& x)
{
  this->access_.set (x);
}

void t_road_objects_object_parkingSpace::
access (::std::auto_ptr< access_type > x)
{
  this->access_.set (x);
}

const t_road_objects_object_parkingSpace::restrictions_optional& t_road_objects_object_parkingSpace::
restrictions () const
{
  return this->restrictions_;
}

t_road_objects_object_parkingSpace::restrictions_optional& t_road_objects_object_parkingSpace::
restrictions ()
{
  return this->restrictions_;
}

void t_road_objects_object_parkingSpace::
restrictions (const restrictions_type& x)
{
  this->restrictions_.set (x);
}

void t_road_objects_object_parkingSpace::
restrictions (const restrictions_optional& x)
{
  this->restrictions_ = x;
}

void t_road_objects_object_parkingSpace::
restrictions (::std::auto_ptr< restrictions_type > x)
{
  this->restrictions_.set (x);
}


// t_road_objects_object_repeat
// 

const t_road_objects_object_repeat::s_type& t_road_objects_object_repeat::
s () const
{
  return this->s_.get ();
}

t_road_objects_object_repeat::s_type& t_road_objects_object_repeat::
s ()
{
  return this->s_.get ();
}

void t_road_objects_object_repeat::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_objects_object_repeat::
s (::std::auto_ptr< s_type > x)
{
  this->s_.set (x);
}

const t_road_objects_object_repeat::length_type& t_road_objects_object_repeat::
length () const
{
  return this->length_.get ();
}

t_road_objects_object_repeat::length_type& t_road_objects_object_repeat::
length ()
{
  return this->length_.get ();
}

void t_road_objects_object_repeat::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road_objects_object_repeat::
length (::std::auto_ptr< length_type > x)
{
  this->length_.set (x);
}

const t_road_objects_object_repeat::distance_type& t_road_objects_object_repeat::
distance () const
{
  return this->distance_.get ();
}

t_road_objects_object_repeat::distance_type& t_road_objects_object_repeat::
distance ()
{
  return this->distance_.get ();
}

void t_road_objects_object_repeat::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

void t_road_objects_object_repeat::
distance (::std::auto_ptr< distance_type > x)
{
  this->distance_.set (x);
}

const t_road_objects_object_repeat::tStart_type& t_road_objects_object_repeat::
tStart () const
{
  return this->tStart_.get ();
}

t_road_objects_object_repeat::tStart_type& t_road_objects_object_repeat::
tStart ()
{
  return this->tStart_.get ();
}

void t_road_objects_object_repeat::
tStart (const tStart_type& x)
{
  this->tStart_.set (x);
}

const t_road_objects_object_repeat::tEnd_type& t_road_objects_object_repeat::
tEnd () const
{
  return this->tEnd_.get ();
}

t_road_objects_object_repeat::tEnd_type& t_road_objects_object_repeat::
tEnd ()
{
  return this->tEnd_.get ();
}

void t_road_objects_object_repeat::
tEnd (const tEnd_type& x)
{
  this->tEnd_.set (x);
}

const t_road_objects_object_repeat::heightStart_type& t_road_objects_object_repeat::
heightStart () const
{
  return this->heightStart_.get ();
}

t_road_objects_object_repeat::heightStart_type& t_road_objects_object_repeat::
heightStart ()
{
  return this->heightStart_.get ();
}

void t_road_objects_object_repeat::
heightStart (const heightStart_type& x)
{
  this->heightStart_.set (x);
}

const t_road_objects_object_repeat::heightEnd_type& t_road_objects_object_repeat::
heightEnd () const
{
  return this->heightEnd_.get ();
}

t_road_objects_object_repeat::heightEnd_type& t_road_objects_object_repeat::
heightEnd ()
{
  return this->heightEnd_.get ();
}

void t_road_objects_object_repeat::
heightEnd (const heightEnd_type& x)
{
  this->heightEnd_.set (x);
}

const t_road_objects_object_repeat::zOffsetStart_type& t_road_objects_object_repeat::
zOffsetStart () const
{
  return this->zOffsetStart_.get ();
}

t_road_objects_object_repeat::zOffsetStart_type& t_road_objects_object_repeat::
zOffsetStart ()
{
  return this->zOffsetStart_.get ();
}

void t_road_objects_object_repeat::
zOffsetStart (const zOffsetStart_type& x)
{
  this->zOffsetStart_.set (x);
}

const t_road_objects_object_repeat::zOffsetEnd_type& t_road_objects_object_repeat::
zOffsetEnd () const
{
  return this->zOffsetEnd_.get ();
}

t_road_objects_object_repeat::zOffsetEnd_type& t_road_objects_object_repeat::
zOffsetEnd ()
{
  return this->zOffsetEnd_.get ();
}

void t_road_objects_object_repeat::
zOffsetEnd (const zOffsetEnd_type& x)
{
  this->zOffsetEnd_.set (x);
}

const t_road_objects_object_repeat::widthStart_optional& t_road_objects_object_repeat::
widthStart () const
{
  return this->widthStart_;
}

t_road_objects_object_repeat::widthStart_optional& t_road_objects_object_repeat::
widthStart ()
{
  return this->widthStart_;
}

void t_road_objects_object_repeat::
widthStart (const widthStart_type& x)
{
  this->widthStart_.set (x);
}

void t_road_objects_object_repeat::
widthStart (const widthStart_optional& x)
{
  this->widthStart_ = x;
}

void t_road_objects_object_repeat::
widthStart (::std::auto_ptr< widthStart_type > x)
{
  this->widthStart_.set (x);
}

const t_road_objects_object_repeat::widthEnd_optional& t_road_objects_object_repeat::
widthEnd () const
{
  return this->widthEnd_;
}

t_road_objects_object_repeat::widthEnd_optional& t_road_objects_object_repeat::
widthEnd ()
{
  return this->widthEnd_;
}

void t_road_objects_object_repeat::
widthEnd (const widthEnd_type& x)
{
  this->widthEnd_.set (x);
}

void t_road_objects_object_repeat::
widthEnd (const widthEnd_optional& x)
{
  this->widthEnd_ = x;
}

void t_road_objects_object_repeat::
widthEnd (::std::auto_ptr< widthEnd_type > x)
{
  this->widthEnd_.set (x);
}

const t_road_objects_object_repeat::lengthStart_optional& t_road_objects_object_repeat::
lengthStart () const
{
  return this->lengthStart_;
}

t_road_objects_object_repeat::lengthStart_optional& t_road_objects_object_repeat::
lengthStart ()
{
  return this->lengthStart_;
}

void t_road_objects_object_repeat::
lengthStart (const lengthStart_type& x)
{
  this->lengthStart_.set (x);
}

void t_road_objects_object_repeat::
lengthStart (const lengthStart_optional& x)
{
  this->lengthStart_ = x;
}

void t_road_objects_object_repeat::
lengthStart (::std::auto_ptr< lengthStart_type > x)
{
  this->lengthStart_.set (x);
}

const t_road_objects_object_repeat::lengthEnd_optional& t_road_objects_object_repeat::
lengthEnd () const
{
  return this->lengthEnd_;
}

t_road_objects_object_repeat::lengthEnd_optional& t_road_objects_object_repeat::
lengthEnd ()
{
  return this->lengthEnd_;
}

void t_road_objects_object_repeat::
lengthEnd (const lengthEnd_type& x)
{
  this->lengthEnd_.set (x);
}

void t_road_objects_object_repeat::
lengthEnd (const lengthEnd_optional& x)
{
  this->lengthEnd_ = x;
}

void t_road_objects_object_repeat::
lengthEnd (::std::auto_ptr< lengthEnd_type > x)
{
  this->lengthEnd_.set (x);
}

const t_road_objects_object_repeat::radiusStart_optional& t_road_objects_object_repeat::
radiusStart () const
{
  return this->radiusStart_;
}

t_road_objects_object_repeat::radiusStart_optional& t_road_objects_object_repeat::
radiusStart ()
{
  return this->radiusStart_;
}

void t_road_objects_object_repeat::
radiusStart (const radiusStart_type& x)
{
  this->radiusStart_.set (x);
}

void t_road_objects_object_repeat::
radiusStart (const radiusStart_optional& x)
{
  this->radiusStart_ = x;
}

void t_road_objects_object_repeat::
radiusStart (::std::auto_ptr< radiusStart_type > x)
{
  this->radiusStart_.set (x);
}

const t_road_objects_object_repeat::radiusEnd_optional& t_road_objects_object_repeat::
radiusEnd () const
{
  return this->radiusEnd_;
}

t_road_objects_object_repeat::radiusEnd_optional& t_road_objects_object_repeat::
radiusEnd ()
{
  return this->radiusEnd_;
}

void t_road_objects_object_repeat::
radiusEnd (const radiusEnd_type& x)
{
  this->radiusEnd_.set (x);
}

void t_road_objects_object_repeat::
radiusEnd (const radiusEnd_optional& x)
{
  this->radiusEnd_ = x;
}

void t_road_objects_object_repeat::
radiusEnd (::std::auto_ptr< radiusEnd_type > x)
{
  this->radiusEnd_.set (x);
}


// t_road_objects_objectReference
// 

const t_road_objects_objectReference::validity_sequence& t_road_objects_objectReference::
validity () const
{
  return this->validity_;
}

t_road_objects_objectReference::validity_sequence& t_road_objects_objectReference::
validity ()
{
  return this->validity_;
}

void t_road_objects_objectReference::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const t_road_objects_objectReference::include_sequence& t_road_objects_objectReference::
include () const
{
  return this->include_;
}

t_road_objects_objectReference::include_sequence& t_road_objects_objectReference::
include ()
{
  return this->include_;
}

void t_road_objects_objectReference::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_objectReference::userData_sequence& t_road_objects_objectReference::
userData () const
{
  return this->userData_;
}

t_road_objects_objectReference::userData_sequence& t_road_objects_objectReference::
userData ()
{
  return this->userData_;
}

void t_road_objects_objectReference::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_objectReference::dataQuality_sequence& t_road_objects_objectReference::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_objectReference::dataQuality_sequence& t_road_objects_objectReference::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_objectReference::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_road_objects_objectReference::s_type& t_road_objects_objectReference::
s () const
{
  return this->s_.get ();
}

t_road_objects_objectReference::s_type& t_road_objects_objectReference::
s ()
{
  return this->s_.get ();
}

void t_road_objects_objectReference::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_objects_objectReference::
s (::std::auto_ptr< s_type > x)
{
  this->s_.set (x);
}

const t_road_objects_objectReference::t_type& t_road_objects_objectReference::
t () const
{
  return this->t_.get ();
}

t_road_objects_objectReference::t_type& t_road_objects_objectReference::
t ()
{
  return this->t_.get ();
}

void t_road_objects_objectReference::
t (const t_type& x)
{
  this->t_.set (x);
}

const t_road_objects_objectReference::id_type& t_road_objects_objectReference::
id () const
{
  return this->id_.get ();
}

t_road_objects_objectReference::id_type& t_road_objects_objectReference::
id ()
{
  return this->id_.get ();
}

void t_road_objects_objectReference::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_objects_objectReference::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const t_road_objects_objectReference::zOffset_optional& t_road_objects_objectReference::
zOffset () const
{
  return this->zOffset_;
}

t_road_objects_objectReference::zOffset_optional& t_road_objects_objectReference::
zOffset ()
{
  return this->zOffset_;
}

void t_road_objects_objectReference::
zOffset (const zOffset_type& x)
{
  this->zOffset_.set (x);
}

void t_road_objects_objectReference::
zOffset (const zOffset_optional& x)
{
  this->zOffset_ = x;
}

const t_road_objects_objectReference::validLength_optional& t_road_objects_objectReference::
validLength () const
{
  return this->validLength_;
}

t_road_objects_objectReference::validLength_optional& t_road_objects_objectReference::
validLength ()
{
  return this->validLength_;
}

void t_road_objects_objectReference::
validLength (const validLength_type& x)
{
  this->validLength_.set (x);
}

void t_road_objects_objectReference::
validLength (const validLength_optional& x)
{
  this->validLength_ = x;
}

void t_road_objects_objectReference::
validLength (::std::auto_ptr< validLength_type > x)
{
  this->validLength_.set (x);
}

const t_road_objects_objectReference::orientation_type& t_road_objects_objectReference::
orientation () const
{
  return this->orientation_.get ();
}

t_road_objects_objectReference::orientation_type& t_road_objects_objectReference::
orientation ()
{
  return this->orientation_.get ();
}

void t_road_objects_objectReference::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void t_road_objects_objectReference::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}


// t_road_objects_tunnel
// 

const t_road_objects_tunnel::validity_sequence& t_road_objects_tunnel::
validity () const
{
  return this->validity_;
}

t_road_objects_tunnel::validity_sequence& t_road_objects_tunnel::
validity ()
{
  return this->validity_;
}

void t_road_objects_tunnel::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const t_road_objects_tunnel::include_sequence& t_road_objects_tunnel::
include () const
{
  return this->include_;
}

t_road_objects_tunnel::include_sequence& t_road_objects_tunnel::
include ()
{
  return this->include_;
}

void t_road_objects_tunnel::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_tunnel::userData_sequence& t_road_objects_tunnel::
userData () const
{
  return this->userData_;
}

t_road_objects_tunnel::userData_sequence& t_road_objects_tunnel::
userData ()
{
  return this->userData_;
}

void t_road_objects_tunnel::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_tunnel::dataQuality_sequence& t_road_objects_tunnel::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_tunnel::dataQuality_sequence& t_road_objects_tunnel::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_tunnel::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_road_objects_tunnel::s_type& t_road_objects_tunnel::
s () const
{
  return this->s_.get ();
}

t_road_objects_tunnel::s_type& t_road_objects_tunnel::
s ()
{
  return this->s_.get ();
}

void t_road_objects_tunnel::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_objects_tunnel::
s (::std::auto_ptr< s_type > x)
{
  this->s_.set (x);
}

const t_road_objects_tunnel::length_type& t_road_objects_tunnel::
length () const
{
  return this->length_.get ();
}

t_road_objects_tunnel::length_type& t_road_objects_tunnel::
length ()
{
  return this->length_.get ();
}

void t_road_objects_tunnel::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road_objects_tunnel::
length (::std::auto_ptr< length_type > x)
{
  this->length_.set (x);
}

const t_road_objects_tunnel::name_optional& t_road_objects_tunnel::
name () const
{
  return this->name_;
}

t_road_objects_tunnel::name_optional& t_road_objects_tunnel::
name ()
{
  return this->name_;
}

void t_road_objects_tunnel::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_road_objects_tunnel::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_road_objects_tunnel::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const t_road_objects_tunnel::id_type& t_road_objects_tunnel::
id () const
{
  return this->id_.get ();
}

t_road_objects_tunnel::id_type& t_road_objects_tunnel::
id ()
{
  return this->id_.get ();
}

void t_road_objects_tunnel::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_objects_tunnel::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const t_road_objects_tunnel::type_type& t_road_objects_tunnel::
type () const
{
  return this->type_.get ();
}

t_road_objects_tunnel::type_type& t_road_objects_tunnel::
type ()
{
  return this->type_.get ();
}

void t_road_objects_tunnel::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_objects_tunnel::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const t_road_objects_tunnel::lighting_optional& t_road_objects_tunnel::
lighting () const
{
  return this->lighting_;
}

t_road_objects_tunnel::lighting_optional& t_road_objects_tunnel::
lighting ()
{
  return this->lighting_;
}

void t_road_objects_tunnel::
lighting (const lighting_type& x)
{
  this->lighting_.set (x);
}

void t_road_objects_tunnel::
lighting (const lighting_optional& x)
{
  this->lighting_ = x;
}

void t_road_objects_tunnel::
lighting (::std::auto_ptr< lighting_type > x)
{
  this->lighting_.set (x);
}

const t_road_objects_tunnel::daylight_optional& t_road_objects_tunnel::
daylight () const
{
  return this->daylight_;
}

t_road_objects_tunnel::daylight_optional& t_road_objects_tunnel::
daylight ()
{
  return this->daylight_;
}

void t_road_objects_tunnel::
daylight (const daylight_type& x)
{
  this->daylight_.set (x);
}

void t_road_objects_tunnel::
daylight (const daylight_optional& x)
{
  this->daylight_ = x;
}

void t_road_objects_tunnel::
daylight (::std::auto_ptr< daylight_type > x)
{
  this->daylight_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// e_borderType
//

e_borderType::
e_borderType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_borderType_convert ();
}

e_borderType::
e_borderType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_borderType_convert ();
}

e_borderType::
e_borderType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_borderType_convert ();
}

e_borderType* e_borderType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_borderType (*this, f, c);
}

e_borderType::value e_borderType::
_xsd_e_borderType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_borderType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_borderType_indexes_,
                    _xsd_e_borderType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_borderType_indexes_ + 2 || _xsd_e_borderType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_borderType::
_xsd_e_borderType_literals_[2] =
{
  "concrete",
  "curb"
};

const e_borderType::value e_borderType::
_xsd_e_borderType_indexes_[2] =
{
  ::e_borderType::concrete,
  ::e_borderType::curb
};

// e_bridgeType
//

e_bridgeType::
e_bridgeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_bridgeType_convert ();
}

e_bridgeType::
e_bridgeType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_bridgeType_convert ();
}

e_bridgeType::
e_bridgeType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_bridgeType_convert ();
}

e_bridgeType* e_bridgeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_bridgeType (*this, f, c);
}

e_bridgeType::value e_bridgeType::
_xsd_e_bridgeType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_bridgeType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_bridgeType_indexes_,
                    _xsd_e_bridgeType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_e_bridgeType_indexes_ + 4 || _xsd_e_bridgeType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_bridgeType::
_xsd_e_bridgeType_literals_[4] =
{
  "concrete",
  "steel",
  "brick",
  "wood"
};

const e_bridgeType::value e_bridgeType::
_xsd_e_bridgeType_indexes_[4] =
{
  ::e_bridgeType::brick,
  ::e_bridgeType::concrete,
  ::e_bridgeType::steel,
  ::e_bridgeType::wood
};

// e_objectType
//

e_objectType::
e_objectType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_objectType_convert ();
}

e_objectType::
e_objectType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_objectType_convert ();
}

e_objectType::
e_objectType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_objectType_convert ();
}

e_objectType* e_objectType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_objectType (*this, f, c);
}

e_objectType::value e_objectType::
_xsd_e_objectType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_objectType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_objectType_indexes_,
                    _xsd_e_objectType_indexes_ + 26,
                    *this,
                    c));

  if (i == _xsd_e_objectType_indexes_ + 26 || _xsd_e_objectType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_objectType::
_xsd_e_objectType_literals_[26] =
{
  "none",
  "obstacle",
  "car",
  "pole",
  "tree",
  "vegetation",
  "barrier",
  "building",
  "parkingSpace",
  "patch",
  "railing",
  "trafficIsland",
  "crosswalk",
  "streetLamp",
  "gantry",
  "soundBarrier",
  "van",
  "bus",
  "trailer",
  "bike",
  "motorbike",
  "tram",
  "train",
  "pedestrian",
  "wind",
  "roadMark"
};

const e_objectType::value e_objectType::
_xsd_e_objectType_indexes_[26] =
{
  ::e_objectType::barrier,
  ::e_objectType::bike,
  ::e_objectType::building,
  ::e_objectType::bus,
  ::e_objectType::car,
  ::e_objectType::crosswalk,
  ::e_objectType::gantry,
  ::e_objectType::motorbike,
  ::e_objectType::none,
  ::e_objectType::obstacle,
  ::e_objectType::parkingSpace,
  ::e_objectType::patch,
  ::e_objectType::pedestrian,
  ::e_objectType::pole,
  ::e_objectType::railing,
  ::e_objectType::roadMark,
  ::e_objectType::soundBarrier,
  ::e_objectType::streetLamp,
  ::e_objectType::trafficIsland,
  ::e_objectType::trailer,
  ::e_objectType::train,
  ::e_objectType::tram,
  ::e_objectType::tree,
  ::e_objectType::van,
  ::e_objectType::vegetation,
  ::e_objectType::wind
};

// e_orientation
//

e_orientation::
e_orientation (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_orientation_convert ();
}

e_orientation::
e_orientation (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_orientation_convert ();
}

e_orientation::
e_orientation (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_orientation_convert ();
}

e_orientation* e_orientation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_orientation (*this, f, c);
}

e_orientation::value e_orientation::
_xsd_e_orientation_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_orientation_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_orientation_indexes_,
                    _xsd_e_orientation_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_e_orientation_indexes_ + 3 || _xsd_e_orientation_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_orientation::
_xsd_e_orientation_literals_[3] =
{
  "+",
  "-",
  "none"
};

const e_orientation::value e_orientation::
_xsd_e_orientation_indexes_[3] =
{
  ::e_orientation::cxx_,
  ::e_orientation::cxx_1,
  ::e_orientation::none
};

// e_outlineFillType
//

e_outlineFillType::
e_outlineFillType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_outlineFillType_convert ();
}

e_outlineFillType::
e_outlineFillType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_outlineFillType_convert ();
}

e_outlineFillType::
e_outlineFillType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_outlineFillType_convert ();
}

e_outlineFillType* e_outlineFillType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_outlineFillType (*this, f, c);
}

e_outlineFillType::value e_outlineFillType::
_xsd_e_outlineFillType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_outlineFillType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_outlineFillType_indexes_,
                    _xsd_e_outlineFillType_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_e_outlineFillType_indexes_ + 7 || _xsd_e_outlineFillType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_outlineFillType::
_xsd_e_outlineFillType_literals_[7] =
{
  "grass",
  "concrete",
  "cobble",
  "asphalt",
  "pavement",
  "gravel",
  "soil"
};

const e_outlineFillType::value e_outlineFillType::
_xsd_e_outlineFillType_indexes_[7] =
{
  ::e_outlineFillType::asphalt,
  ::e_outlineFillType::cobble,
  ::e_outlineFillType::concrete,
  ::e_outlineFillType::grass,
  ::e_outlineFillType::gravel,
  ::e_outlineFillType::pavement,
  ::e_outlineFillType::soil
};

// e_road_objects_object_parkingSpace_access
//

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_road_objects_object_parkingSpace_access_convert ();
}

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_road_objects_object_parkingSpace_access_convert ();
}

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_road_objects_object_parkingSpace_access_convert ();
}

e_road_objects_object_parkingSpace_access* e_road_objects_object_parkingSpace_access::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_road_objects_object_parkingSpace_access (*this, f, c);
}

e_road_objects_object_parkingSpace_access::value e_road_objects_object_parkingSpace_access::
_xsd_e_road_objects_object_parkingSpace_access_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_objects_object_parkingSpace_access_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_road_objects_object_parkingSpace_access_indexes_,
                    _xsd_e_road_objects_object_parkingSpace_access_indexes_ + 8,
                    *this,
                    c));

  if (i == _xsd_e_road_objects_object_parkingSpace_access_indexes_ + 8 || _xsd_e_road_objects_object_parkingSpace_access_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_road_objects_object_parkingSpace_access::
_xsd_e_road_objects_object_parkingSpace_access_literals_[8] =
{
  "all",
  "car",
  "women",
  "handicapped",
  "bus",
  "truck",
  "electric",
  "residents"
};

const e_road_objects_object_parkingSpace_access::value e_road_objects_object_parkingSpace_access::
_xsd_e_road_objects_object_parkingSpace_access_indexes_[8] =
{
  ::e_road_objects_object_parkingSpace_access::all,
  ::e_road_objects_object_parkingSpace_access::bus,
  ::e_road_objects_object_parkingSpace_access::car,
  ::e_road_objects_object_parkingSpace_access::electric,
  ::e_road_objects_object_parkingSpace_access::handicapped,
  ::e_road_objects_object_parkingSpace_access::residents,
  ::e_road_objects_object_parkingSpace_access::truck,
  ::e_road_objects_object_parkingSpace_access::women
};

// e_sideType
//

e_sideType::
e_sideType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_sideType_convert ();
}

e_sideType::
e_sideType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_sideType_convert ();
}

e_sideType::
e_sideType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_sideType_convert ();
}

e_sideType* e_sideType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_sideType (*this, f, c);
}

e_sideType::value e_sideType::
_xsd_e_sideType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_sideType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_sideType_indexes_,
                    _xsd_e_sideType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_e_sideType_indexes_ + 4 || _xsd_e_sideType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_sideType::
_xsd_e_sideType_literals_[4] =
{
  "left",
  "right",
  "front",
  "rear"
};

const e_sideType::value e_sideType::
_xsd_e_sideType_indexes_[4] =
{
  ::e_sideType::front,
  ::e_sideType::left,
  ::e_sideType::rear,
  ::e_sideType::right
};

// e_tunnelType
//

e_tunnelType::
e_tunnelType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_tunnelType_convert ();
}

e_tunnelType::
e_tunnelType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_tunnelType_convert ();
}

e_tunnelType::
e_tunnelType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_tunnelType_convert ();
}

e_tunnelType* e_tunnelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_tunnelType (*this, f, c);
}

e_tunnelType::value e_tunnelType::
_xsd_e_tunnelType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_tunnelType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_tunnelType_indexes_,
                    _xsd_e_tunnelType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_tunnelType_indexes_ + 2 || _xsd_e_tunnelType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_tunnelType::
_xsd_e_tunnelType_literals_[2] =
{
  "standard",
  "underpass"
};

const e_tunnelType::value e_tunnelType::
_xsd_e_tunnelType_indexes_[2] =
{
  ::e_tunnelType::standard,
  ::e_tunnelType::underpass
};

// t_road_objects
//

t_road_objects::
t_road_objects ()
: ::_OpenDriveElement (),
  object_ (this),
  objectReference_ (this),
  tunnel_ (this),
  bridge_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_road_objects::
t_road_objects (const t_road_objects& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  object_ (x.object_, f, this),
  objectReference_ (x.objectReference_, f, this),
  tunnel_ (x.tunnel_, f, this),
  bridge_ (x.bridge_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_objects::
t_road_objects (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  object_ (this),
  objectReference_ (this),
  tunnel_ (this),
  bridge_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_objects::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // object
    //
    if (n.name () == "object" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< object_type > r (
        object_traits::create (i, f, this));

      this->object_.push_back (r);
      continue;
    }

    // objectReference
    //
    if (n.name () == "objectReference" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< objectReference_type > r (
        objectReference_traits::create (i, f, this));

      this->objectReference_.push_back (r);
      continue;
    }

    // tunnel
    //
    if (n.name () == "tunnel" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tunnel_type > r (
        tunnel_traits::create (i, f, this));

      this->tunnel_.push_back (r);
      continue;
    }

    // bridge
    //
    if (n.name () == "bridge" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bridge_type > r (
        bridge_traits::create (i, f, this));

      this->bridge_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_road_objects* t_road_objects::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects (*this, f, c);
}

t_road_objects& t_road_objects::
operator= (const t_road_objects& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->object_ = x.object_;
    this->objectReference_ = x.objectReference_;
    this->tunnel_ = x.tunnel_;
    this->bridge_ = x.bridge_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_objects::
~t_road_objects ()
{
}

// t_road_objects_bridge
//

t_road_objects_bridge::
t_road_objects_bridge (const s_type& s,
                       const length_type& length,
                       const id_type& id,
                       const type_type& type)
: ::_OpenDriveElement (),
  validity_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  s_ (s, this),
  length_ (length, this),
  name_ (this),
  id_ (id, this),
  type_ (type, this)
{
}

t_road_objects_bridge::
t_road_objects_bridge (const t_road_objects_bridge& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  validity_ (x.validity_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  length_ (x.length_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

t_road_objects_bridge::
t_road_objects_bridge (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  validity_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  s_ (this),
  length_ (this),
  name_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_bridge::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

t_road_objects_bridge* t_road_objects_bridge::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_bridge (*this, f, c);
}

t_road_objects_bridge& t_road_objects_bridge::
operator= (const t_road_objects_bridge& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->validity_ = x.validity_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->length_ = x.length_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

t_road_objects_bridge::
~t_road_objects_bridge ()
{
}

// t_road_objects_object
//

t_road_objects_object::
t_road_objects_object (const t_type& t,
                       const zOffset_type& zOffset,
                       const id_type& id,
                       const s_type& s)
: ::_OpenDriveElement (),
  repeat_ (this),
  outline_ (this),
  outlines_ (this),
  material_ (this),
  validity_ (this),
  parkingSpace_ (this),
  markings_ (this),
  borders_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  t_ (t, this),
  zOffset_ (zOffset, this),
  type_ (this),
  validLength_ (this),
  orientation_ (this),
  subtype_ (this),
  dynamic_ (this),
  hdg_ (this),
  name_ (this),
  pitch_ (this),
  id_ (id, this),
  roll_ (this),
  height_ (this),
  s_ (s, this),
  length_ (this),
  width_ (this),
  radius_ (this)
{
}

t_road_objects_object::
t_road_objects_object (const t_road_objects_object& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  repeat_ (x.repeat_, f, this),
  outline_ (x.outline_, f, this),
  outlines_ (x.outlines_, f, this),
  material_ (x.material_, f, this),
  validity_ (x.validity_, f, this),
  parkingSpace_ (x.parkingSpace_, f, this),
  markings_ (x.markings_, f, this),
  borders_ (x.borders_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  t_ (x.t_, f, this),
  zOffset_ (x.zOffset_, f, this),
  type_ (x.type_, f, this),
  validLength_ (x.validLength_, f, this),
  orientation_ (x.orientation_, f, this),
  subtype_ (x.subtype_, f, this),
  dynamic_ (x.dynamic_, f, this),
  hdg_ (x.hdg_, f, this),
  name_ (x.name_, f, this),
  pitch_ (x.pitch_, f, this),
  id_ (x.id_, f, this),
  roll_ (x.roll_, f, this),
  height_ (x.height_, f, this),
  s_ (x.s_, f, this),
  length_ (x.length_, f, this),
  width_ (x.width_, f, this),
  radius_ (x.radius_, f, this)
{
}

t_road_objects_object::
t_road_objects_object (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  repeat_ (this),
  outline_ (this),
  outlines_ (this),
  material_ (this),
  validity_ (this),
  parkingSpace_ (this),
  markings_ (this),
  borders_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  t_ (this),
  zOffset_ (this),
  type_ (this),
  validLength_ (this),
  orientation_ (this),
  subtype_ (this),
  dynamic_ (this),
  hdg_ (this),
  name_ (this),
  pitch_ (this),
  id_ (this),
  roll_ (this),
  height_ (this),
  s_ (this),
  length_ (this),
  width_ (this),
  radius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // repeat
    //
    if (n.name () == "repeat" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< repeat_type > r (
        repeat_traits::create (i, f, this));

      this->repeat_.push_back (r);
      continue;
    }

    // outline
    //
    if (n.name () == "outline" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< outline_type > r (
        outline_traits::create (i, f, this));

      if (!this->outline_)
      {
        this->outline_.set (r);
        continue;
      }
    }

    // outlines
    //
    if (n.name () == "outlines" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< outlines_type > r (
        outlines_traits::create (i, f, this));

      if (!this->outlines_)
      {
        this->outlines_.set (r);
        continue;
      }
    }

    // material
    //
    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< material_type > r (
        material_traits::create (i, f, this));

      this->material_.push_back (r);
      continue;
    }

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (r);
      continue;
    }

    // parkingSpace
    //
    if (n.name () == "parkingSpace" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< parkingSpace_type > r (
        parkingSpace_traits::create (i, f, this));

      if (!this->parkingSpace_)
      {
        this->parkingSpace_.set (r);
        continue;
      }
    }

    // markings
    //
    if (n.name () == "markings" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< markings_type > r (
        markings_traits::create (i, f, this));

      if (!this->markings_)
      {
        this->markings_.set (r);
        continue;
      }
    }

    // borders
    //
    if (n.name () == "borders" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< borders_type > r (
        borders_traits::create (i, f, this));

      if (!this->borders_)
      {
        this->borders_.set (r);
        continue;
      }
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffset" && n.namespace_ ().empty ())
    {
      this->zOffset_.set (zOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "validLength" && n.namespace_ ().empty ())
    {
      this->validLength_.set (validLength_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      this->orientation_.set (orientation_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "subtype" && n.namespace_ ().empty ())
    {
      this->subtype_.set (subtype_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dynamic" && n.namespace_ ().empty ())
    {
      this->dynamic_.set (dynamic_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hdg" && n.namespace_ ().empty ())
    {
      this->hdg_.set (hdg_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "pitch" && n.namespace_ ().empty ())
    {
      this->pitch_.set (pitch_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "roll" && n.namespace_ ().empty ())
    {
      this->roll_.set (roll_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      this->radius_.set (radius_traits::create (i, f, this));
      continue;
    }
  }

  if (!t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t",
      "");
  }

  if (!zOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zOffset",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }
}

t_road_objects_object* t_road_objects_object::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object (*this, f, c);
}

t_road_objects_object& t_road_objects_object::
operator= (const t_road_objects_object& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->repeat_ = x.repeat_;
    this->outline_ = x.outline_;
    this->outlines_ = x.outlines_;
    this->material_ = x.material_;
    this->validity_ = x.validity_;
    this->parkingSpace_ = x.parkingSpace_;
    this->markings_ = x.markings_;
    this->borders_ = x.borders_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->t_ = x.t_;
    this->zOffset_ = x.zOffset_;
    this->type_ = x.type_;
    this->validLength_ = x.validLength_;
    this->orientation_ = x.orientation_;
    this->subtype_ = x.subtype_;
    this->dynamic_ = x.dynamic_;
    this->hdg_ = x.hdg_;
    this->name_ = x.name_;
    this->pitch_ = x.pitch_;
    this->id_ = x.id_;
    this->roll_ = x.roll_;
    this->height_ = x.height_;
    this->s_ = x.s_;
    this->length_ = x.length_;
    this->width_ = x.width_;
    this->radius_ = x.radius_;
  }

  return *this;
}

t_road_objects_object::
~t_road_objects_object ()
{
}

// t_road_objects_object_borders
//

t_road_objects_object_borders::
t_road_objects_object_borders ()
: ::_OpenDriveElement (),
  border_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_road_objects_object_borders::
t_road_objects_object_borders (const t_road_objects_object_borders& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  border_ (x.border_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_objects_object_borders::
t_road_objects_object_borders (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  border_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_objects_object_borders::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // border
    //
    if (n.name () == "border" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< border_type > r (
        border_traits::create (i, f, this));

      this->border_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_road_objects_object_borders* t_road_objects_object_borders::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_borders (*this, f, c);
}

t_road_objects_object_borders& t_road_objects_object_borders::
operator= (const t_road_objects_object_borders& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->border_ = x.border_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_objects_object_borders::
~t_road_objects_object_borders ()
{
}

// t_road_objects_object_borders_border
//

t_road_objects_object_borders_border::
t_road_objects_object_borders_border (const width_type& width,
                                      const type_type& type,
                                      const outlineId_type& outlineId)
: ::_OpenDriveElement (),
  cornerReference_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  width_ (width, this),
  type_ (type, this),
  outlineId_ (outlineId, this),
  useCompleteOutline_ (this)
{
}

t_road_objects_object_borders_border::
t_road_objects_object_borders_border (const t_road_objects_object_borders_border& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  cornerReference_ (x.cornerReference_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  width_ (x.width_, f, this),
  type_ (x.type_, f, this),
  outlineId_ (x.outlineId_, f, this),
  useCompleteOutline_ (x.useCompleteOutline_, f, this)
{
}

t_road_objects_object_borders_border::
t_road_objects_object_borders_border (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  cornerReference_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  width_ (this),
  type_ (this),
  outlineId_ (this),
  useCompleteOutline_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_borders_border::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cornerReference
    //
    if (n.name () == "cornerReference" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cornerReference_type > r (
        cornerReference_traits::create (i, f, this));

      this->cornerReference_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "outlineId" && n.namespace_ ().empty ())
    {
      this->outlineId_.set (outlineId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "useCompleteOutline" && n.namespace_ ().empty ())
    {
      this->useCompleteOutline_.set (useCompleteOutline_traits::create (i, f, this));
      continue;
    }
  }

  if (!width_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "width",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!outlineId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "outlineId",
      "");
  }
}

t_road_objects_object_borders_border* t_road_objects_object_borders_border::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_borders_border (*this, f, c);
}

t_road_objects_object_borders_border& t_road_objects_object_borders_border::
operator= (const t_road_objects_object_borders_border& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->cornerReference_ = x.cornerReference_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->width_ = x.width_;
    this->type_ = x.type_;
    this->outlineId_ = x.outlineId_;
    this->useCompleteOutline_ = x.useCompleteOutline_;
  }

  return *this;
}

t_road_objects_object_borders_border::
~t_road_objects_object_borders_border ()
{
}

// t_road_objects_object_markings
//

t_road_objects_object_markings::
t_road_objects_object_markings ()
: ::_OpenDriveElement (),
  marking_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_road_objects_object_markings::
t_road_objects_object_markings (const t_road_objects_object_markings& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  marking_ (x.marking_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_objects_object_markings::
t_road_objects_object_markings (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  marking_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_objects_object_markings::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // marking
    //
    if (n.name () == "marking" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< marking_type > r (
        marking_traits::create (i, f, this));

      this->marking_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_road_objects_object_markings* t_road_objects_object_markings::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_markings (*this, f, c);
}

t_road_objects_object_markings& t_road_objects_object_markings::
operator= (const t_road_objects_object_markings& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->marking_ = x.marking_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_objects_object_markings::
~t_road_objects_object_markings ()
{
}

// t_road_objects_object_markings_marking
//

t_road_objects_object_markings_marking::
t_road_objects_object_markings_marking (const side_type& side,
                                        const color_type& color,
                                        const spaceLength_type& spaceLength,
                                        const lineLength_type& lineLength,
                                        const startOffset_type& startOffset,
                                        const stopOffset_type& stopOffset)
: ::_OpenDriveElement (),
  cornerReference_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  side_ (side, this),
  weight_ (this),
  width_ (this),
  color_ (color, this),
  zOffset_ (this),
  spaceLength_ (spaceLength, this),
  lineLength_ (lineLength, this),
  startOffset_ (startOffset, this),
  stopOffset_ (stopOffset, this)
{
}

t_road_objects_object_markings_marking::
t_road_objects_object_markings_marking (const t_road_objects_object_markings_marking& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  cornerReference_ (x.cornerReference_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  side_ (x.side_, f, this),
  weight_ (x.weight_, f, this),
  width_ (x.width_, f, this),
  color_ (x.color_, f, this),
  zOffset_ (x.zOffset_, f, this),
  spaceLength_ (x.spaceLength_, f, this),
  lineLength_ (x.lineLength_, f, this),
  startOffset_ (x.startOffset_, f, this),
  stopOffset_ (x.stopOffset_, f, this)
{
}

t_road_objects_object_markings_marking::
t_road_objects_object_markings_marking (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  cornerReference_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  side_ (this),
  weight_ (this),
  width_ (this),
  color_ (this),
  zOffset_ (this),
  spaceLength_ (this),
  lineLength_ (this),
  startOffset_ (this),
  stopOffset_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_markings_marking::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cornerReference
    //
    if (n.name () == "cornerReference" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cornerReference_type > r (
        cornerReference_traits::create (i, f, this));

      this->cornerReference_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "side" && n.namespace_ ().empty ())
    {
      this->side_.set (side_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "weight" && n.namespace_ ().empty ())
    {
      this->weight_.set (weight_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      this->color_.set (color_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffset" && n.namespace_ ().empty ())
    {
      this->zOffset_.set (zOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "spaceLength" && n.namespace_ ().empty ())
    {
      this->spaceLength_.set (spaceLength_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lineLength" && n.namespace_ ().empty ())
    {
      this->lineLength_.set (lineLength_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "startOffset" && n.namespace_ ().empty ())
    {
      this->startOffset_.set (startOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "stopOffset" && n.namespace_ ().empty ())
    {
      this->stopOffset_.set (stopOffset_traits::create (i, f, this));
      continue;
    }
  }

  if (!side_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "side",
      "");
  }

  if (!color_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "color",
      "");
  }

  if (!spaceLength_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "spaceLength",
      "");
  }

  if (!lineLength_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "lineLength",
      "");
  }

  if (!startOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "startOffset",
      "");
  }

  if (!stopOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "stopOffset",
      "");
  }
}

t_road_objects_object_markings_marking* t_road_objects_object_markings_marking::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_markings_marking (*this, f, c);
}

t_road_objects_object_markings_marking& t_road_objects_object_markings_marking::
operator= (const t_road_objects_object_markings_marking& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->cornerReference_ = x.cornerReference_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->side_ = x.side_;
    this->weight_ = x.weight_;
    this->width_ = x.width_;
    this->color_ = x.color_;
    this->zOffset_ = x.zOffset_;
    this->spaceLength_ = x.spaceLength_;
    this->lineLength_ = x.lineLength_;
    this->startOffset_ = x.startOffset_;
    this->stopOffset_ = x.stopOffset_;
  }

  return *this;
}

t_road_objects_object_markings_marking::
~t_road_objects_object_markings_marking ()
{
}

// t_road_objects_object_markings_marking_cornerReference
//

t_road_objects_object_markings_marking_cornerReference::
t_road_objects_object_markings_marking_cornerReference (const id_type& id)
: ::_OpenDriveElement (),
  id_ (id, this)
{
}

t_road_objects_object_markings_marking_cornerReference::
t_road_objects_object_markings_marking_cornerReference (const t_road_objects_object_markings_marking_cornerReference& x,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  id_ (x.id_, f, this)
{
}

t_road_objects_object_markings_marking_cornerReference::
t_road_objects_object_markings_marking_cornerReference (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_markings_marking_cornerReference::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_road_objects_object_markings_marking_cornerReference* t_road_objects_object_markings_marking_cornerReference::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_markings_marking_cornerReference (*this, f, c);
}

t_road_objects_object_markings_marking_cornerReference& t_road_objects_object_markings_marking_cornerReference::
operator= (const t_road_objects_object_markings_marking_cornerReference& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->id_ = x.id_;
  }

  return *this;
}

t_road_objects_object_markings_marking_cornerReference::
~t_road_objects_object_markings_marking_cornerReference ()
{
}

// t_road_objects_object_material
//

t_road_objects_object_material::
t_road_objects_object_material ()
: ::_OpenDriveElement (),
  surface_ (this),
  friction_ (this),
  roughness_ (this)
{
}

t_road_objects_object_material::
t_road_objects_object_material (const t_road_objects_object_material& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  surface_ (x.surface_, f, this),
  friction_ (x.friction_, f, this),
  roughness_ (x.roughness_, f, this)
{
}

t_road_objects_object_material::
t_road_objects_object_material (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  surface_ (this),
  friction_ (this),
  roughness_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_material::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "surface" && n.namespace_ ().empty ())
    {
      this->surface_.set (surface_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "friction" && n.namespace_ ().empty ())
    {
      this->friction_.set (friction_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "roughness" && n.namespace_ ().empty ())
    {
      this->roughness_.set (roughness_traits::create (i, f, this));
      continue;
    }
  }
}

t_road_objects_object_material* t_road_objects_object_material::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_material (*this, f, c);
}

t_road_objects_object_material& t_road_objects_object_material::
operator= (const t_road_objects_object_material& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->surface_ = x.surface_;
    this->friction_ = x.friction_;
    this->roughness_ = x.roughness_;
  }

  return *this;
}

t_road_objects_object_material::
~t_road_objects_object_material ()
{
}

// t_road_objects_object_outlines
//

t_road_objects_object_outlines::
t_road_objects_object_outlines ()
: ::_OpenDriveElement (),
  outline_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_road_objects_object_outlines::
t_road_objects_object_outlines (const t_road_objects_object_outlines& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  outline_ (x.outline_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_objects_object_outlines::
t_road_objects_object_outlines (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  outline_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_objects_object_outlines::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // outline
    //
    if (n.name () == "outline" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< outline_type > r (
        outline_traits::create (i, f, this));

      this->outline_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_road_objects_object_outlines* t_road_objects_object_outlines::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_outlines (*this, f, c);
}

t_road_objects_object_outlines& t_road_objects_object_outlines::
operator= (const t_road_objects_object_outlines& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->outline_ = x.outline_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_objects_object_outlines::
~t_road_objects_object_outlines ()
{
}

// t_road_objects_object_outlines_outline
//

t_road_objects_object_outlines_outline::
t_road_objects_object_outlines_outline ()
: ::_OpenDriveElement (),
  cornerRoad_ (this),
  cornerLocal_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  id_ (this),
  fillType_ (this),
  outer_ (this),
  closed_ (this),
  laneType_ (this)
{
}

t_road_objects_object_outlines_outline::
t_road_objects_object_outlines_outline (const t_road_objects_object_outlines_outline& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  cornerRoad_ (x.cornerRoad_, f, this),
  cornerLocal_ (x.cornerLocal_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  id_ (x.id_, f, this),
  fillType_ (x.fillType_, f, this),
  outer_ (x.outer_, f, this),
  closed_ (x.closed_, f, this),
  laneType_ (x.laneType_, f, this)
{
}

t_road_objects_object_outlines_outline::
t_road_objects_object_outlines_outline (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  cornerRoad_ (this),
  cornerLocal_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  id_ (this),
  fillType_ (this),
  outer_ (this),
  closed_ (this),
  laneType_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_outlines_outline::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cornerRoad
    //
    if (n.name () == "cornerRoad" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cornerRoad_type > r (
        cornerRoad_traits::create (i, f, this));

      this->cornerRoad_.push_back (r);
      continue;
    }

    // cornerLocal
    //
    if (n.name () == "cornerLocal" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cornerLocal_type > r (
        cornerLocal_traits::create (i, f, this));

      this->cornerLocal_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "fillType" && n.namespace_ ().empty ())
    {
      this->fillType_.set (fillType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "outer" && n.namespace_ ().empty ())
    {
      this->outer_.set (outer_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "closed" && n.namespace_ ().empty ())
    {
      this->closed_.set (closed_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "laneType" && n.namespace_ ().empty ())
    {
      this->laneType_.set (laneType_traits::create (i, f, this));
      continue;
    }
  }
}

t_road_objects_object_outlines_outline* t_road_objects_object_outlines_outline::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_outlines_outline (*this, f, c);
}

t_road_objects_object_outlines_outline& t_road_objects_object_outlines_outline::
operator= (const t_road_objects_object_outlines_outline& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->cornerRoad_ = x.cornerRoad_;
    this->cornerLocal_ = x.cornerLocal_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->id_ = x.id_;
    this->fillType_ = x.fillType_;
    this->outer_ = x.outer_;
    this->closed_ = x.closed_;
    this->laneType_ = x.laneType_;
  }

  return *this;
}

t_road_objects_object_outlines_outline::
~t_road_objects_object_outlines_outline ()
{
}

// t_road_objects_object_outlines_outline_cornerLocal
//

t_road_objects_object_outlines_outline_cornerLocal::
t_road_objects_object_outlines_outline_cornerLocal (const u_type& u,
                                                    const v_type& v,
                                                    const z_type& z,
                                                    const height_type& height)
: ::_OpenDriveElement (),
  u_ (u, this),
  v_ (v, this),
  z_ (z, this),
  height_ (height, this),
  id_ (this)
{
}

t_road_objects_object_outlines_outline_cornerLocal::
t_road_objects_object_outlines_outline_cornerLocal (const t_road_objects_object_outlines_outline_cornerLocal& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  u_ (x.u_, f, this),
  v_ (x.v_, f, this),
  z_ (x.z_, f, this),
  height_ (x.height_, f, this),
  id_ (x.id_, f, this)
{
}

t_road_objects_object_outlines_outline_cornerLocal::
t_road_objects_object_outlines_outline_cornerLocal (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  u_ (this),
  v_ (this),
  z_ (this),
  height_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_outlines_outline_cornerLocal::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "u" && n.namespace_ ().empty ())
    {
      this->u_.set (u_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "v" && n.namespace_ ().empty ())
    {
      this->v_.set (v_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!u_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "u",
      "");
  }

  if (!v_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "v",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "z",
      "");
  }

  if (!height_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "height",
      "");
  }
}

t_road_objects_object_outlines_outline_cornerLocal* t_road_objects_object_outlines_outline_cornerLocal::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_outlines_outline_cornerLocal (*this, f, c);
}

t_road_objects_object_outlines_outline_cornerLocal& t_road_objects_object_outlines_outline_cornerLocal::
operator= (const t_road_objects_object_outlines_outline_cornerLocal& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->u_ = x.u_;
    this->v_ = x.v_;
    this->z_ = x.z_;
    this->height_ = x.height_;
    this->id_ = x.id_;
  }

  return *this;
}

t_road_objects_object_outlines_outline_cornerLocal::
~t_road_objects_object_outlines_outline_cornerLocal ()
{
}

// t_road_objects_object_outlines_outline_cornerRoad
//

t_road_objects_object_outlines_outline_cornerRoad::
t_road_objects_object_outlines_outline_cornerRoad (const s_type& s,
                                                   const t_type& t,
                                                   const dz_type& dz,
                                                   const height_type& height)
: ::_OpenDriveElement (),
  s_ (s, this),
  t_ (t, this),
  dz_ (dz, this),
  height_ (height, this),
  id_ (this)
{
}

t_road_objects_object_outlines_outline_cornerRoad::
t_road_objects_object_outlines_outline_cornerRoad (const t_road_objects_object_outlines_outline_cornerRoad& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  dz_ (x.dz_, f, this),
  height_ (x.height_, f, this),
  id_ (x.id_, f, this)
{
}

t_road_objects_object_outlines_outline_cornerRoad::
t_road_objects_object_outlines_outline_cornerRoad (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  s_ (this),
  t_ (this),
  dz_ (this),
  height_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_outlines_outline_cornerRoad::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dz" && n.namespace_ ().empty ())
    {
      this->dz_.set (dz_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t",
      "");
  }

  if (!dz_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "dz",
      "");
  }

  if (!height_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "height",
      "");
  }
}

t_road_objects_object_outlines_outline_cornerRoad* t_road_objects_object_outlines_outline_cornerRoad::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_outlines_outline_cornerRoad (*this, f, c);
}

t_road_objects_object_outlines_outline_cornerRoad& t_road_objects_object_outlines_outline_cornerRoad::
operator= (const t_road_objects_object_outlines_outline_cornerRoad& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->dz_ = x.dz_;
    this->height_ = x.height_;
    this->id_ = x.id_;
  }

  return *this;
}

t_road_objects_object_outlines_outline_cornerRoad::
~t_road_objects_object_outlines_outline_cornerRoad ()
{
}

// t_road_objects_object_parkingSpace
//

t_road_objects_object_parkingSpace::
t_road_objects_object_parkingSpace (const access_type& access)
: ::_OpenDriveElement (),
  access_ (access, this),
  restrictions_ (this)
{
}

t_road_objects_object_parkingSpace::
t_road_objects_object_parkingSpace (const t_road_objects_object_parkingSpace& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  access_ (x.access_, f, this),
  restrictions_ (x.restrictions_, f, this)
{
}

t_road_objects_object_parkingSpace::
t_road_objects_object_parkingSpace (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  access_ (this),
  restrictions_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_parkingSpace::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "access" && n.namespace_ ().empty ())
    {
      this->access_.set (access_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "restrictions" && n.namespace_ ().empty ())
    {
      this->restrictions_.set (restrictions_traits::create (i, f, this));
      continue;
    }
  }

  if (!access_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "access",
      "");
  }
}

t_road_objects_object_parkingSpace* t_road_objects_object_parkingSpace::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_parkingSpace (*this, f, c);
}

t_road_objects_object_parkingSpace& t_road_objects_object_parkingSpace::
operator= (const t_road_objects_object_parkingSpace& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->access_ = x.access_;
    this->restrictions_ = x.restrictions_;
  }

  return *this;
}

t_road_objects_object_parkingSpace::
~t_road_objects_object_parkingSpace ()
{
}

// t_road_objects_object_repeat
//

t_road_objects_object_repeat::
t_road_objects_object_repeat (const s_type& s,
                              const length_type& length,
                              const distance_type& distance,
                              const tStart_type& tStart,
                              const tEnd_type& tEnd,
                              const heightStart_type& heightStart,
                              const heightEnd_type& heightEnd,
                              const zOffsetStart_type& zOffsetStart,
                              const zOffsetEnd_type& zOffsetEnd)
: ::_OpenDriveElement (),
  s_ (s, this),
  length_ (length, this),
  distance_ (distance, this),
  tStart_ (tStart, this),
  tEnd_ (tEnd, this),
  heightStart_ (heightStart, this),
  heightEnd_ (heightEnd, this),
  zOffsetStart_ (zOffsetStart, this),
  zOffsetEnd_ (zOffsetEnd, this),
  widthStart_ (this),
  widthEnd_ (this),
  lengthStart_ (this),
  lengthEnd_ (this),
  radiusStart_ (this),
  radiusEnd_ (this)
{
}

t_road_objects_object_repeat::
t_road_objects_object_repeat (const t_road_objects_object_repeat& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  s_ (x.s_, f, this),
  length_ (x.length_, f, this),
  distance_ (x.distance_, f, this),
  tStart_ (x.tStart_, f, this),
  tEnd_ (x.tEnd_, f, this),
  heightStart_ (x.heightStart_, f, this),
  heightEnd_ (x.heightEnd_, f, this),
  zOffsetStart_ (x.zOffsetStart_, f, this),
  zOffsetEnd_ (x.zOffsetEnd_, f, this),
  widthStart_ (x.widthStart_, f, this),
  widthEnd_ (x.widthEnd_, f, this),
  lengthStart_ (x.lengthStart_, f, this),
  lengthEnd_ (x.lengthEnd_, f, this),
  radiusStart_ (x.radiusStart_, f, this),
  radiusEnd_ (x.radiusEnd_, f, this)
{
}

t_road_objects_object_repeat::
t_road_objects_object_repeat (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  s_ (this),
  length_ (this),
  distance_ (this),
  tStart_ (this),
  tEnd_ (this),
  heightStart_ (this),
  heightEnd_ (this),
  zOffsetStart_ (this),
  zOffsetEnd_ (this),
  widthStart_ (this),
  widthEnd_ (this),
  lengthStart_ (this),
  lengthEnd_ (this),
  radiusStart_ (this),
  radiusEnd_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_repeat::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      this->distance_.set (distance_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "tStart" && n.namespace_ ().empty ())
    {
      this->tStart_.set (tStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "tEnd" && n.namespace_ ().empty ())
    {
      this->tEnd_.set (tEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "heightStart" && n.namespace_ ().empty ())
    {
      this->heightStart_.set (heightStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "heightEnd" && n.namespace_ ().empty ())
    {
      this->heightEnd_.set (heightEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffsetStart" && n.namespace_ ().empty ())
    {
      this->zOffsetStart_.set (zOffsetStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffsetEnd" && n.namespace_ ().empty ())
    {
      this->zOffsetEnd_.set (zOffsetEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "widthStart" && n.namespace_ ().empty ())
    {
      this->widthStart_.set (widthStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "widthEnd" && n.namespace_ ().empty ())
    {
      this->widthEnd_.set (widthEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lengthStart" && n.namespace_ ().empty ())
    {
      this->lengthStart_.set (lengthStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lengthEnd" && n.namespace_ ().empty ())
    {
      this->lengthEnd_.set (lengthEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "radiusStart" && n.namespace_ ().empty ())
    {
      this->radiusStart_.set (radiusStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "radiusEnd" && n.namespace_ ().empty ())
    {
      this->radiusEnd_.set (radiusEnd_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }

  if (!distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "distance",
      "");
  }

  if (!tStart_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "tStart",
      "");
  }

  if (!tEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "tEnd",
      "");
  }

  if (!heightStart_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "heightStart",
      "");
  }

  if (!heightEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "heightEnd",
      "");
  }

  if (!zOffsetStart_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zOffsetStart",
      "");
  }

  if (!zOffsetEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zOffsetEnd",
      "");
  }
}

t_road_objects_object_repeat* t_road_objects_object_repeat::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_repeat (*this, f, c);
}

t_road_objects_object_repeat& t_road_objects_object_repeat::
operator= (const t_road_objects_object_repeat& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->s_ = x.s_;
    this->length_ = x.length_;
    this->distance_ = x.distance_;
    this->tStart_ = x.tStart_;
    this->tEnd_ = x.tEnd_;
    this->heightStart_ = x.heightStart_;
    this->heightEnd_ = x.heightEnd_;
    this->zOffsetStart_ = x.zOffsetStart_;
    this->zOffsetEnd_ = x.zOffsetEnd_;
    this->widthStart_ = x.widthStart_;
    this->widthEnd_ = x.widthEnd_;
    this->lengthStart_ = x.lengthStart_;
    this->lengthEnd_ = x.lengthEnd_;
    this->radiusStart_ = x.radiusStart_;
    this->radiusEnd_ = x.radiusEnd_;
  }

  return *this;
}

t_road_objects_object_repeat::
~t_road_objects_object_repeat ()
{
}

// t_road_objects_objectReference
//

t_road_objects_objectReference::
t_road_objects_objectReference (const s_type& s,
                                const t_type& t,
                                const id_type& id,
                                const orientation_type& orientation)
: ::_OpenDriveElement (),
  validity_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  s_ (s, this),
  t_ (t, this),
  id_ (id, this),
  zOffset_ (this),
  validLength_ (this),
  orientation_ (orientation, this)
{
}

t_road_objects_objectReference::
t_road_objects_objectReference (const t_road_objects_objectReference& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  validity_ (x.validity_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  id_ (x.id_, f, this),
  zOffset_ (x.zOffset_, f, this),
  validLength_ (x.validLength_, f, this),
  orientation_ (x.orientation_, f, this)
{
}

t_road_objects_objectReference::
t_road_objects_objectReference (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  validity_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  s_ (this),
  t_ (this),
  id_ (this),
  zOffset_ (this),
  validLength_ (this),
  orientation_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_objectReference::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffset" && n.namespace_ ().empty ())
    {
      this->zOffset_.set (zOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "validLength" && n.namespace_ ().empty ())
    {
      this->validLength_.set (validLength_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      this->orientation_.set (orientation_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!orientation_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "orientation",
      "");
  }
}

t_road_objects_objectReference* t_road_objects_objectReference::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_objectReference (*this, f, c);
}

t_road_objects_objectReference& t_road_objects_objectReference::
operator= (const t_road_objects_objectReference& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->validity_ = x.validity_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->id_ = x.id_;
    this->zOffset_ = x.zOffset_;
    this->validLength_ = x.validLength_;
    this->orientation_ = x.orientation_;
  }

  return *this;
}

t_road_objects_objectReference::
~t_road_objects_objectReference ()
{
}

// t_road_objects_tunnel
//

t_road_objects_tunnel::
t_road_objects_tunnel (const s_type& s,
                       const length_type& length,
                       const id_type& id,
                       const type_type& type)
: ::_OpenDriveElement (),
  validity_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  s_ (s, this),
  length_ (length, this),
  name_ (this),
  id_ (id, this),
  type_ (type, this),
  lighting_ (this),
  daylight_ (this)
{
}

t_road_objects_tunnel::
t_road_objects_tunnel (const t_road_objects_tunnel& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  validity_ (x.validity_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  length_ (x.length_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this),
  lighting_ (x.lighting_, f, this),
  daylight_ (x.daylight_, f, this)
{
}

t_road_objects_tunnel::
t_road_objects_tunnel (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  validity_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  s_ (this),
  length_ (this),
  name_ (this),
  id_ (this),
  type_ (this),
  lighting_ (this),
  daylight_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_tunnel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lighting" && n.namespace_ ().empty ())
    {
      this->lighting_.set (lighting_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "daylight" && n.namespace_ ().empty ())
    {
      this->daylight_.set (daylight_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

t_road_objects_tunnel* t_road_objects_tunnel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_tunnel (*this, f, c);
}

t_road_objects_tunnel& t_road_objects_tunnel::
operator= (const t_road_objects_tunnel& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->validity_ = x.validity_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->length_ = x.length_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->type_ = x.type_;
    this->lighting_ = x.lighting_;
    this->daylight_ = x.daylight_;
  }

  return *this;
}

t_road_objects_tunnel::
~t_road_objects_tunnel ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

