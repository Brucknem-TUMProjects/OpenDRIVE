// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "opendrive_16_road.hxx"

// e_countryCode
//

e_countryCode::
e_countryCode (const char* s)
: ::xml_schema::string (s)
{
}

e_countryCode::
e_countryCode (const ::std::string& s)
: ::xml_schema::string (s)
{
}

e_countryCode::
e_countryCode (const e_countryCode& o,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (o, f, c)
{
}

// e_countryCode_deprecated
// 

e_countryCode_deprecated::
e_countryCode_deprecated (value v)
: ::xml_schema::string (_xsd_e_countryCode_deprecated_literals_[v])
{
}

e_countryCode_deprecated::
e_countryCode_deprecated (const char* v)
: ::xml_schema::string (v)
{
}

e_countryCode_deprecated::
e_countryCode_deprecated (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_countryCode_deprecated::
e_countryCode_deprecated (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_countryCode_deprecated::
e_countryCode_deprecated (const e_countryCode_deprecated& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_countryCode_deprecated& e_countryCode_deprecated::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_countryCode_deprecated_literals_[v]);

  return *this;
}


// e_countryCode_iso3166alpha2
// 


// e_countryCode_iso3166alpha3_deprecated
// 


// e_direction
// 

e_direction::
e_direction (value v)
: ::xml_schema::string (_xsd_e_direction_literals_[v])
{
}

e_direction::
e_direction (const char* v)
: ::xml_schema::string (v)
{
}

e_direction::
e_direction (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_direction::
e_direction (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_direction::
e_direction (const e_direction& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_direction& e_direction::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_direction_literals_[v]);

  return *this;
}


// e_maxSpeedString
// 

e_maxSpeedString::
e_maxSpeedString (value v)
: ::xml_schema::string (_xsd_e_maxSpeedString_literals_[v])
{
}

e_maxSpeedString::
e_maxSpeedString (const char* v)
: ::xml_schema::string (v)
{
}

e_maxSpeedString::
e_maxSpeedString (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_maxSpeedString::
e_maxSpeedString (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_maxSpeedString::
e_maxSpeedString (const e_maxSpeedString& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_maxSpeedString& e_maxSpeedString::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_maxSpeedString_literals_[v]);

  return *this;
}


// e_paramPoly3_pRange
// 

e_paramPoly3_pRange::
e_paramPoly3_pRange (value v)
: ::xml_schema::string (_xsd_e_paramPoly3_pRange_literals_[v])
{
}

e_paramPoly3_pRange::
e_paramPoly3_pRange (const char* v)
: ::xml_schema::string (v)
{
}

e_paramPoly3_pRange::
e_paramPoly3_pRange (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_paramPoly3_pRange::
e_paramPoly3_pRange (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_paramPoly3_pRange::
e_paramPoly3_pRange (const e_paramPoly3_pRange& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_paramPoly3_pRange& e_paramPoly3_pRange::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_paramPoly3_pRange_literals_[v]);

  return *this;
}


// e_road_link_elementType
// 

e_road_link_elementType::
e_road_link_elementType (value v)
: ::xml_schema::string (_xsd_e_road_link_elementType_literals_[v])
{
}

e_road_link_elementType::
e_road_link_elementType (const char* v)
: ::xml_schema::string (v)
{
}

e_road_link_elementType::
e_road_link_elementType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_road_link_elementType::
e_road_link_elementType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_road_link_elementType::
e_road_link_elementType (const e_road_link_elementType& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_road_link_elementType& e_road_link_elementType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_road_link_elementType_literals_[v]);

  return *this;
}


// e_roadType
// 

e_roadType::
e_roadType (value v)
: ::xml_schema::string (_xsd_e_roadType_literals_[v])
{
}

e_roadType::
e_roadType (const char* v)
: ::xml_schema::string (v)
{
}

e_roadType::
e_roadType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_roadType::
e_roadType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_roadType::
e_roadType (const e_roadType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_roadType& e_roadType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_roadType_literals_[v]);

  return *this;
}


// e_trafficRule
// 

e_trafficRule::
e_trafficRule (value v)
: ::xml_schema::string (_xsd_e_trafficRule_literals_[v])
{
}

e_trafficRule::
e_trafficRule (const char* v)
: ::xml_schema::string (v)
{
}

e_trafficRule::
e_trafficRule (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_trafficRule::
e_trafficRule (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_trafficRule::
e_trafficRule (const e_trafficRule& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_trafficRule& e_trafficRule::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_trafficRule_literals_[v]);

  return *this;
}


// t_maxSpeed
//

t_maxSpeed::
t_maxSpeed (const char* s)
: ::xml_schema::string (s)
{
}

t_maxSpeed::
t_maxSpeed (const ::std::string& s)
: ::xml_schema::string (s)
{
}

t_maxSpeed::
t_maxSpeed (const t_maxSpeed& o,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (o, f, c)
{
}

// t_road
// 

const t_road::link_optional& t_road::
link () const
{
  return this->link_;
}

t_road::link_optional& t_road::
link ()
{
  return this->link_;
}

void t_road::
link (const link_type& x)
{
  this->link_.set (x);
}

void t_road::
link (const link_optional& x)
{
  this->link_ = x;
}

void t_road::
link (::std::auto_ptr< link_type > x)
{
  this->link_.set (x);
}

const t_road::type_sequence& t_road::
type () const
{
  return this->type_;
}

t_road::type_sequence& t_road::
type ()
{
  return this->type_;
}

void t_road::
type (const type_sequence& s)
{
  this->type_ = s;
}

const t_road::planView_type& t_road::
planView () const
{
  return this->planView_.get ();
}

t_road::planView_type& t_road::
planView ()
{
  return this->planView_.get ();
}

void t_road::
planView (const planView_type& x)
{
  this->planView_.set (x);
}

void t_road::
planView (::std::auto_ptr< planView_type > x)
{
  this->planView_.set (x);
}

const t_road::elevationProfile_optional& t_road::
elevationProfile () const
{
  return this->elevationProfile_;
}

t_road::elevationProfile_optional& t_road::
elevationProfile ()
{
  return this->elevationProfile_;
}

void t_road::
elevationProfile (const elevationProfile_type& x)
{
  this->elevationProfile_.set (x);
}

void t_road::
elevationProfile (const elevationProfile_optional& x)
{
  this->elevationProfile_ = x;
}

void t_road::
elevationProfile (::std::auto_ptr< elevationProfile_type > x)
{
  this->elevationProfile_.set (x);
}

const t_road::lateralProfile_optional& t_road::
lateralProfile () const
{
  return this->lateralProfile_;
}

t_road::lateralProfile_optional& t_road::
lateralProfile ()
{
  return this->lateralProfile_;
}

void t_road::
lateralProfile (const lateralProfile_type& x)
{
  this->lateralProfile_.set (x);
}

void t_road::
lateralProfile (const lateralProfile_optional& x)
{
  this->lateralProfile_ = x;
}

void t_road::
lateralProfile (::std::auto_ptr< lateralProfile_type > x)
{
  this->lateralProfile_.set (x);
}

const t_road::lanes_type& t_road::
lanes () const
{
  return this->lanes_.get ();
}

t_road::lanes_type& t_road::
lanes ()
{
  return this->lanes_.get ();
}

void t_road::
lanes (const lanes_type& x)
{
  this->lanes_.set (x);
}

void t_road::
lanes (::std::auto_ptr< lanes_type > x)
{
  this->lanes_.set (x);
}

const t_road::objects_optional& t_road::
objects () const
{
  return this->objects_;
}

t_road::objects_optional& t_road::
objects ()
{
  return this->objects_;
}

void t_road::
objects (const objects_type& x)
{
  this->objects_.set (x);
}

void t_road::
objects (const objects_optional& x)
{
  this->objects_ = x;
}

void t_road::
objects (::std::auto_ptr< objects_type > x)
{
  this->objects_.set (x);
}

const t_road::signals_optional& t_road::
signals () const
{
  return this->signals_;
}

t_road::signals_optional& t_road::
signals ()
{
  return this->signals_;
}

void t_road::
signals (const signals_type& x)
{
  this->signals_.set (x);
}

void t_road::
signals (const signals_optional& x)
{
  this->signals_ = x;
}

void t_road::
signals (::std::auto_ptr< signals_type > x)
{
  this->signals_.set (x);
}

const t_road::surface_optional& t_road::
surface () const
{
  return this->surface_;
}

t_road::surface_optional& t_road::
surface ()
{
  return this->surface_;
}

void t_road::
surface (const surface_type& x)
{
  this->surface_.set (x);
}

void t_road::
surface (const surface_optional& x)
{
  this->surface_ = x;
}

void t_road::
surface (::std::auto_ptr< surface_type > x)
{
  this->surface_.set (x);
}

const t_road::railroad_optional& t_road::
railroad () const
{
  return this->railroad_;
}

t_road::railroad_optional& t_road::
railroad ()
{
  return this->railroad_;
}

void t_road::
railroad (const railroad_type& x)
{
  this->railroad_.set (x);
}

void t_road::
railroad (const railroad_optional& x)
{
  this->railroad_ = x;
}

void t_road::
railroad (::std::auto_ptr< railroad_type > x)
{
  this->railroad_.set (x);
}

const t_road::include_sequence& t_road::
include () const
{
  return this->include_;
}

t_road::include_sequence& t_road::
include ()
{
  return this->include_;
}

void t_road::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road::userData_sequence& t_road::
userData () const
{
  return this->userData_;
}

t_road::userData_sequence& t_road::
userData ()
{
  return this->userData_;
}

void t_road::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road::dataQuality_sequence& t_road::
dataQuality () const
{
  return this->dataQuality_;
}

t_road::dataQuality_sequence& t_road::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_road::name_optional& t_road::
name () const
{
  return this->name_;
}

t_road::name_optional& t_road::
name ()
{
  return this->name_;
}

void t_road::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_road::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_road::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const t_road::length_type& t_road::
length () const
{
  return this->length_.get ();
}

t_road::length_type& t_road::
length ()
{
  return this->length_.get ();
}

void t_road::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road::
length (::std::auto_ptr< length_type > x)
{
  this->length_.set (x);
}

const t_road::id_type& t_road::
id () const
{
  return this->id_.get ();
}

t_road::id_type& t_road::
id ()
{
  return this->id_.get ();
}

void t_road::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const t_road::junction_type& t_road::
junction () const
{
  return this->junction_.get ();
}

t_road::junction_type& t_road::
junction ()
{
  return this->junction_.get ();
}

void t_road::
junction (const junction_type& x)
{
  this->junction_.set (x);
}

void t_road::
junction (::std::auto_ptr< junction_type > x)
{
  this->junction_.set (x);
}

const t_road::rule_optional& t_road::
rule () const
{
  return this->rule_;
}

t_road::rule_optional& t_road::
rule ()
{
  return this->rule_;
}

void t_road::
rule (const rule_type& x)
{
  this->rule_.set (x);
}

void t_road::
rule (const rule_optional& x)
{
  this->rule_ = x;
}

void t_road::
rule (::std::auto_ptr< rule_type > x)
{
  this->rule_.set (x);
}


// t_road_elevationProfile
// 

const t_road_elevationProfile::elevation_sequence& t_road_elevationProfile::
elevation () const
{
  return this->elevation_;
}

t_road_elevationProfile::elevation_sequence& t_road_elevationProfile::
elevation ()
{
  return this->elevation_;
}

void t_road_elevationProfile::
elevation (const elevation_sequence& s)
{
  this->elevation_ = s;
}

const t_road_elevationProfile::include_sequence& t_road_elevationProfile::
include () const
{
  return this->include_;
}

t_road_elevationProfile::include_sequence& t_road_elevationProfile::
include ()
{
  return this->include_;
}

void t_road_elevationProfile::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_elevationProfile::userData_sequence& t_road_elevationProfile::
userData () const
{
  return this->userData_;
}

t_road_elevationProfile::userData_sequence& t_road_elevationProfile::
userData ()
{
  return this->userData_;
}

void t_road_elevationProfile::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_elevationProfile::dataQuality_sequence& t_road_elevationProfile::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_elevationProfile::dataQuality_sequence& t_road_elevationProfile::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_elevationProfile::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_road_elevationProfile_elevation
// 

const t_road_elevationProfile_elevation::s_type& t_road_elevationProfile_elevation::
s () const
{
  return this->s_.get ();
}

t_road_elevationProfile_elevation::s_type& t_road_elevationProfile_elevation::
s ()
{
  return this->s_.get ();
}

void t_road_elevationProfile_elevation::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_elevationProfile_elevation::
s (::std::auto_ptr< s_type > x)
{
  this->s_.set (x);
}

const t_road_elevationProfile_elevation::a_type& t_road_elevationProfile_elevation::
a () const
{
  return this->a_.get ();
}

t_road_elevationProfile_elevation::a_type& t_road_elevationProfile_elevation::
a ()
{
  return this->a_.get ();
}

void t_road_elevationProfile_elevation::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_elevationProfile_elevation::b_type& t_road_elevationProfile_elevation::
b () const
{
  return this->b_.get ();
}

t_road_elevationProfile_elevation::b_type& t_road_elevationProfile_elevation::
b ()
{
  return this->b_.get ();
}

void t_road_elevationProfile_elevation::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_elevationProfile_elevation::c_type& t_road_elevationProfile_elevation::
c () const
{
  return this->c_.get ();
}

t_road_elevationProfile_elevation::c_type& t_road_elevationProfile_elevation::
c ()
{
  return this->c_.get ();
}

void t_road_elevationProfile_elevation::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_elevationProfile_elevation::d_type& t_road_elevationProfile_elevation::
d () const
{
  return this->d_.get ();
}

t_road_elevationProfile_elevation::d_type& t_road_elevationProfile_elevation::
d ()
{
  return this->d_.get ();
}

void t_road_elevationProfile_elevation::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_lateralProfile
// 

const t_road_lateralProfile::superelevation_sequence& t_road_lateralProfile::
superelevation () const
{
  return this->superelevation_;
}

t_road_lateralProfile::superelevation_sequence& t_road_lateralProfile::
superelevation ()
{
  return this->superelevation_;
}

void t_road_lateralProfile::
superelevation (const superelevation_sequence& s)
{
  this->superelevation_ = s;
}

const t_road_lateralProfile::shape_sequence& t_road_lateralProfile::
shape () const
{
  return this->shape_;
}

t_road_lateralProfile::shape_sequence& t_road_lateralProfile::
shape ()
{
  return this->shape_;
}

void t_road_lateralProfile::
shape (const shape_sequence& s)
{
  this->shape_ = s;
}

const t_road_lateralProfile::include_sequence& t_road_lateralProfile::
include () const
{
  return this->include_;
}

t_road_lateralProfile::include_sequence& t_road_lateralProfile::
include ()
{
  return this->include_;
}

void t_road_lateralProfile::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lateralProfile::userData_sequence& t_road_lateralProfile::
userData () const
{
  return this->userData_;
}

t_road_lateralProfile::userData_sequence& t_road_lateralProfile::
userData ()
{
  return this->userData_;
}

void t_road_lateralProfile::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lateralProfile::dataQuality_sequence& t_road_lateralProfile::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lateralProfile::dataQuality_sequence& t_road_lateralProfile::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lateralProfile::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_road_lateralProfile_shape
// 

const t_road_lateralProfile_shape::s_type& t_road_lateralProfile_shape::
s () const
{
  return this->s_.get ();
}

t_road_lateralProfile_shape::s_type& t_road_lateralProfile_shape::
s ()
{
  return this->s_.get ();
}

void t_road_lateralProfile_shape::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_lateralProfile_shape::
s (::std::auto_ptr< s_type > x)
{
  this->s_.set (x);
}

const t_road_lateralProfile_shape::t_type& t_road_lateralProfile_shape::
t () const
{
  return this->t_.get ();
}

t_road_lateralProfile_shape::t_type& t_road_lateralProfile_shape::
t ()
{
  return this->t_.get ();
}

void t_road_lateralProfile_shape::
t (const t_type& x)
{
  this->t_.set (x);
}

const t_road_lateralProfile_shape::a_type& t_road_lateralProfile_shape::
a () const
{
  return this->a_.get ();
}

t_road_lateralProfile_shape::a_type& t_road_lateralProfile_shape::
a ()
{
  return this->a_.get ();
}

void t_road_lateralProfile_shape::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_lateralProfile_shape::b_type& t_road_lateralProfile_shape::
b () const
{
  return this->b_.get ();
}

t_road_lateralProfile_shape::b_type& t_road_lateralProfile_shape::
b ()
{
  return this->b_.get ();
}

void t_road_lateralProfile_shape::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_lateralProfile_shape::c_type& t_road_lateralProfile_shape::
c () const
{
  return this->c_.get ();
}

t_road_lateralProfile_shape::c_type& t_road_lateralProfile_shape::
c ()
{
  return this->c_.get ();
}

void t_road_lateralProfile_shape::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_lateralProfile_shape::d_type& t_road_lateralProfile_shape::
d () const
{
  return this->d_.get ();
}

t_road_lateralProfile_shape::d_type& t_road_lateralProfile_shape::
d ()
{
  return this->d_.get ();
}

void t_road_lateralProfile_shape::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_lateralProfile_superelevation
// 

const t_road_lateralProfile_superelevation::s_type& t_road_lateralProfile_superelevation::
s () const
{
  return this->s_.get ();
}

t_road_lateralProfile_superelevation::s_type& t_road_lateralProfile_superelevation::
s ()
{
  return this->s_.get ();
}

void t_road_lateralProfile_superelevation::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_lateralProfile_superelevation::
s (::std::auto_ptr< s_type > x)
{
  this->s_.set (x);
}

const t_road_lateralProfile_superelevation::a_type& t_road_lateralProfile_superelevation::
a () const
{
  return this->a_.get ();
}

t_road_lateralProfile_superelevation::a_type& t_road_lateralProfile_superelevation::
a ()
{
  return this->a_.get ();
}

void t_road_lateralProfile_superelevation::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_lateralProfile_superelevation::b_type& t_road_lateralProfile_superelevation::
b () const
{
  return this->b_.get ();
}

t_road_lateralProfile_superelevation::b_type& t_road_lateralProfile_superelevation::
b ()
{
  return this->b_.get ();
}

void t_road_lateralProfile_superelevation::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_lateralProfile_superelevation::c_type& t_road_lateralProfile_superelevation::
c () const
{
  return this->c_.get ();
}

t_road_lateralProfile_superelevation::c_type& t_road_lateralProfile_superelevation::
c ()
{
  return this->c_.get ();
}

void t_road_lateralProfile_superelevation::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_lateralProfile_superelevation::d_type& t_road_lateralProfile_superelevation::
d () const
{
  return this->d_.get ();
}

t_road_lateralProfile_superelevation::d_type& t_road_lateralProfile_superelevation::
d ()
{
  return this->d_.get ();
}

void t_road_lateralProfile_superelevation::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_link
// 

const t_road_link::predecessor_optional& t_road_link::
predecessor () const
{
  return this->predecessor_;
}

t_road_link::predecessor_optional& t_road_link::
predecessor ()
{
  return this->predecessor_;
}

void t_road_link::
predecessor (const predecessor_type& x)
{
  this->predecessor_.set (x);
}

void t_road_link::
predecessor (const predecessor_optional& x)
{
  this->predecessor_ = x;
}

void t_road_link::
predecessor (::std::auto_ptr< predecessor_type > x)
{
  this->predecessor_.set (x);
}

const t_road_link::successor_optional& t_road_link::
successor () const
{
  return this->successor_;
}

t_road_link::successor_optional& t_road_link::
successor ()
{
  return this->successor_;
}

void t_road_link::
successor (const successor_type& x)
{
  this->successor_.set (x);
}

void t_road_link::
successor (const successor_optional& x)
{
  this->successor_ = x;
}

void t_road_link::
successor (::std::auto_ptr< successor_type > x)
{
  this->successor_.set (x);
}

const t_road_link::include_sequence& t_road_link::
include () const
{
  return this->include_;
}

t_road_link::include_sequence& t_road_link::
include ()
{
  return this->include_;
}

void t_road_link::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_link::userData_sequence& t_road_link::
userData () const
{
  return this->userData_;
}

t_road_link::userData_sequence& t_road_link::
userData ()
{
  return this->userData_;
}

void t_road_link::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_link::dataQuality_sequence& t_road_link::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_link::dataQuality_sequence& t_road_link::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_link::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_road_link_predecessorSuccessor
// 

const t_road_link_predecessorSuccessor::elementId_type& t_road_link_predecessorSuccessor::
elementId () const
{
  return this->elementId_.get ();
}

t_road_link_predecessorSuccessor::elementId_type& t_road_link_predecessorSuccessor::
elementId ()
{
  return this->elementId_.get ();
}

void t_road_link_predecessorSuccessor::
elementId (const elementId_type& x)
{
  this->elementId_.set (x);
}

void t_road_link_predecessorSuccessor::
elementId (::std::auto_ptr< elementId_type > x)
{
  this->elementId_.set (x);
}

const t_road_link_predecessorSuccessor::elementType_optional& t_road_link_predecessorSuccessor::
elementType () const
{
  return this->elementType_;
}

t_road_link_predecessorSuccessor::elementType_optional& t_road_link_predecessorSuccessor::
elementType ()
{
  return this->elementType_;
}

void t_road_link_predecessorSuccessor::
elementType (const elementType_type& x)
{
  this->elementType_.set (x);
}

void t_road_link_predecessorSuccessor::
elementType (const elementType_optional& x)
{
  this->elementType_ = x;
}

void t_road_link_predecessorSuccessor::
elementType (::std::auto_ptr< elementType_type > x)
{
  this->elementType_.set (x);
}

const t_road_link_predecessorSuccessor::contactPoint_optional& t_road_link_predecessorSuccessor::
contactPoint () const
{
  return this->contactPoint_;
}

t_road_link_predecessorSuccessor::contactPoint_optional& t_road_link_predecessorSuccessor::
contactPoint ()
{
  return this->contactPoint_;
}

void t_road_link_predecessorSuccessor::
contactPoint (const contactPoint_type& x)
{
  this->contactPoint_.set (x);
}

void t_road_link_predecessorSuccessor::
contactPoint (const contactPoint_optional& x)
{
  this->contactPoint_ = x;
}

void t_road_link_predecessorSuccessor::
contactPoint (::std::auto_ptr< contactPoint_type > x)
{
  this->contactPoint_.set (x);
}

const t_road_link_predecessorSuccessor::elementS_optional& t_road_link_predecessorSuccessor::
elementS () const
{
  return this->elementS_;
}

t_road_link_predecessorSuccessor::elementS_optional& t_road_link_predecessorSuccessor::
elementS ()
{
  return this->elementS_;
}

void t_road_link_predecessorSuccessor::
elementS (const elementS_type& x)
{
  this->elementS_.set (x);
}

void t_road_link_predecessorSuccessor::
elementS (const elementS_optional& x)
{
  this->elementS_ = x;
}

void t_road_link_predecessorSuccessor::
elementS (::std::auto_ptr< elementS_type > x)
{
  this->elementS_.set (x);
}

const t_road_link_predecessorSuccessor::elementDir_optional& t_road_link_predecessorSuccessor::
elementDir () const
{
  return this->elementDir_;
}

t_road_link_predecessorSuccessor::elementDir_optional& t_road_link_predecessorSuccessor::
elementDir ()
{
  return this->elementDir_;
}

void t_road_link_predecessorSuccessor::
elementDir (const elementDir_type& x)
{
  this->elementDir_.set (x);
}

void t_road_link_predecessorSuccessor::
elementDir (const elementDir_optional& x)
{
  this->elementDir_ = x;
}

void t_road_link_predecessorSuccessor::
elementDir (::std::auto_ptr< elementDir_type > x)
{
  this->elementDir_.set (x);
}


// t_road_planView
// 

const t_road_planView::geometry_sequence& t_road_planView::
geometry () const
{
  return this->geometry_;
}

t_road_planView::geometry_sequence& t_road_planView::
geometry ()
{
  return this->geometry_;
}

void t_road_planView::
geometry (const geometry_sequence& s)
{
  this->geometry_ = s;
}

const t_road_planView::include_sequence& t_road_planView::
include () const
{
  return this->include_;
}

t_road_planView::include_sequence& t_road_planView::
include ()
{
  return this->include_;
}

void t_road_planView::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_planView::userData_sequence& t_road_planView::
userData () const
{
  return this->userData_;
}

t_road_planView::userData_sequence& t_road_planView::
userData ()
{
  return this->userData_;
}

void t_road_planView::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_planView::dataQuality_sequence& t_road_planView::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_planView::dataQuality_sequence& t_road_planView::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_planView::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_road_planView_geometry
// 

const t_road_planView_geometry::line_optional& t_road_planView_geometry::
line () const
{
  return this->line_;
}

t_road_planView_geometry::line_optional& t_road_planView_geometry::
line ()
{
  return this->line_;
}

void t_road_planView_geometry::
line (const line_type& x)
{
  this->line_.set (x);
}

void t_road_planView_geometry::
line (const line_optional& x)
{
  this->line_ = x;
}

void t_road_planView_geometry::
line (::std::auto_ptr< line_type > x)
{
  this->line_.set (x);
}

const t_road_planView_geometry::spiral_optional& t_road_planView_geometry::
spiral () const
{
  return this->spiral_;
}

t_road_planView_geometry::spiral_optional& t_road_planView_geometry::
spiral ()
{
  return this->spiral_;
}

void t_road_planView_geometry::
spiral (const spiral_type& x)
{
  this->spiral_.set (x);
}

void t_road_planView_geometry::
spiral (const spiral_optional& x)
{
  this->spiral_ = x;
}

void t_road_planView_geometry::
spiral (::std::auto_ptr< spiral_type > x)
{
  this->spiral_.set (x);
}

const t_road_planView_geometry::arc_optional& t_road_planView_geometry::
arc () const
{
  return this->arc_;
}

t_road_planView_geometry::arc_optional& t_road_planView_geometry::
arc ()
{
  return this->arc_;
}

void t_road_planView_geometry::
arc (const arc_type& x)
{
  this->arc_.set (x);
}

void t_road_planView_geometry::
arc (const arc_optional& x)
{
  this->arc_ = x;
}

void t_road_planView_geometry::
arc (::std::auto_ptr< arc_type > x)
{
  this->arc_.set (x);
}

const t_road_planView_geometry::poly3_optional& t_road_planView_geometry::
poly3 () const
{
  return this->poly3_;
}

t_road_planView_geometry::poly3_optional& t_road_planView_geometry::
poly3 ()
{
  return this->poly3_;
}

void t_road_planView_geometry::
poly3 (const poly3_type& x)
{
  this->poly3_.set (x);
}

void t_road_planView_geometry::
poly3 (const poly3_optional& x)
{
  this->poly3_ = x;
}

void t_road_planView_geometry::
poly3 (::std::auto_ptr< poly3_type > x)
{
  this->poly3_.set (x);
}

const t_road_planView_geometry::paramPoly3_optional& t_road_planView_geometry::
paramPoly3 () const
{
  return this->paramPoly3_;
}

t_road_planView_geometry::paramPoly3_optional& t_road_planView_geometry::
paramPoly3 ()
{
  return this->paramPoly3_;
}

void t_road_planView_geometry::
paramPoly3 (const paramPoly3_type& x)
{
  this->paramPoly3_.set (x);
}

void t_road_planView_geometry::
paramPoly3 (const paramPoly3_optional& x)
{
  this->paramPoly3_ = x;
}

void t_road_planView_geometry::
paramPoly3 (::std::auto_ptr< paramPoly3_type > x)
{
  this->paramPoly3_.set (x);
}

const t_road_planView_geometry::include_sequence& t_road_planView_geometry::
include () const
{
  return this->include_;
}

t_road_planView_geometry::include_sequence& t_road_planView_geometry::
include ()
{
  return this->include_;
}

void t_road_planView_geometry::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_planView_geometry::userData_sequence& t_road_planView_geometry::
userData () const
{
  return this->userData_;
}

t_road_planView_geometry::userData_sequence& t_road_planView_geometry::
userData ()
{
  return this->userData_;
}

void t_road_planView_geometry::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_planView_geometry::dataQuality_sequence& t_road_planView_geometry::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_planView_geometry::dataQuality_sequence& t_road_planView_geometry::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_planView_geometry::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_road_planView_geometry::s_type& t_road_planView_geometry::
s () const
{
  return this->s_.get ();
}

t_road_planView_geometry::s_type& t_road_planView_geometry::
s ()
{
  return this->s_.get ();
}

void t_road_planView_geometry::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_planView_geometry::
s (::std::auto_ptr< s_type > x)
{
  this->s_.set (x);
}

const t_road_planView_geometry::x_type& t_road_planView_geometry::
x () const
{
  return this->x_.get ();
}

t_road_planView_geometry::x_type& t_road_planView_geometry::
x ()
{
  return this->x_.get ();
}

void t_road_planView_geometry::
x (const x_type& x)
{
  this->x_.set (x);
}

const t_road_planView_geometry::y_type& t_road_planView_geometry::
y () const
{
  return this->y_.get ();
}

t_road_planView_geometry::y_type& t_road_planView_geometry::
y ()
{
  return this->y_.get ();
}

void t_road_planView_geometry::
y (const y_type& x)
{
  this->y_.set (x);
}

const t_road_planView_geometry::hdg_type& t_road_planView_geometry::
hdg () const
{
  return this->hdg_.get ();
}

t_road_planView_geometry::hdg_type& t_road_planView_geometry::
hdg ()
{
  return this->hdg_.get ();
}

void t_road_planView_geometry::
hdg (const hdg_type& x)
{
  this->hdg_.set (x);
}

const t_road_planView_geometry::length_type& t_road_planView_geometry::
length () const
{
  return this->length_.get ();
}

t_road_planView_geometry::length_type& t_road_planView_geometry::
length ()
{
  return this->length_.get ();
}

void t_road_planView_geometry::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road_planView_geometry::
length (::std::auto_ptr< length_type > x)
{
  this->length_.set (x);
}


// t_road_planView_geometry_arc
// 

const t_road_planView_geometry_arc::curvature_type& t_road_planView_geometry_arc::
curvature () const
{
  return this->curvature_.get ();
}

t_road_planView_geometry_arc::curvature_type& t_road_planView_geometry_arc::
curvature ()
{
  return this->curvature_.get ();
}

void t_road_planView_geometry_arc::
curvature (const curvature_type& x)
{
  this->curvature_.set (x);
}


// t_road_planView_geometry_line
// 


// t_road_planView_geometry_paramPoly3
// 

const t_road_planView_geometry_paramPoly3::aU_type& t_road_planView_geometry_paramPoly3::
aU () const
{
  return this->aU_.get ();
}

t_road_planView_geometry_paramPoly3::aU_type& t_road_planView_geometry_paramPoly3::
aU ()
{
  return this->aU_.get ();
}

void t_road_planView_geometry_paramPoly3::
aU (const aU_type& x)
{
  this->aU_.set (x);
}

const t_road_planView_geometry_paramPoly3::bU_type& t_road_planView_geometry_paramPoly3::
bU () const
{
  return this->bU_.get ();
}

t_road_planView_geometry_paramPoly3::bU_type& t_road_planView_geometry_paramPoly3::
bU ()
{
  return this->bU_.get ();
}

void t_road_planView_geometry_paramPoly3::
bU (const bU_type& x)
{
  this->bU_.set (x);
}

const t_road_planView_geometry_paramPoly3::cU_type& t_road_planView_geometry_paramPoly3::
cU () const
{
  return this->cU_.get ();
}

t_road_planView_geometry_paramPoly3::cU_type& t_road_planView_geometry_paramPoly3::
cU ()
{
  return this->cU_.get ();
}

void t_road_planView_geometry_paramPoly3::
cU (const cU_type& x)
{
  this->cU_.set (x);
}

const t_road_planView_geometry_paramPoly3::dU_type& t_road_planView_geometry_paramPoly3::
dU () const
{
  return this->dU_.get ();
}

t_road_planView_geometry_paramPoly3::dU_type& t_road_planView_geometry_paramPoly3::
dU ()
{
  return this->dU_.get ();
}

void t_road_planView_geometry_paramPoly3::
dU (const dU_type& x)
{
  this->dU_.set (x);
}

const t_road_planView_geometry_paramPoly3::aV_type& t_road_planView_geometry_paramPoly3::
aV () const
{
  return this->aV_.get ();
}

t_road_planView_geometry_paramPoly3::aV_type& t_road_planView_geometry_paramPoly3::
aV ()
{
  return this->aV_.get ();
}

void t_road_planView_geometry_paramPoly3::
aV (const aV_type& x)
{
  this->aV_.set (x);
}

const t_road_planView_geometry_paramPoly3::bV_type& t_road_planView_geometry_paramPoly3::
bV () const
{
  return this->bV_.get ();
}

t_road_planView_geometry_paramPoly3::bV_type& t_road_planView_geometry_paramPoly3::
bV ()
{
  return this->bV_.get ();
}

void t_road_planView_geometry_paramPoly3::
bV (const bV_type& x)
{
  this->bV_.set (x);
}

const t_road_planView_geometry_paramPoly3::cV_type& t_road_planView_geometry_paramPoly3::
cV () const
{
  return this->cV_.get ();
}

t_road_planView_geometry_paramPoly3::cV_type& t_road_planView_geometry_paramPoly3::
cV ()
{
  return this->cV_.get ();
}

void t_road_planView_geometry_paramPoly3::
cV (const cV_type& x)
{
  this->cV_.set (x);
}

const t_road_planView_geometry_paramPoly3::dV_type& t_road_planView_geometry_paramPoly3::
dV () const
{
  return this->dV_.get ();
}

t_road_planView_geometry_paramPoly3::dV_type& t_road_planView_geometry_paramPoly3::
dV ()
{
  return this->dV_.get ();
}

void t_road_planView_geometry_paramPoly3::
dV (const dV_type& x)
{
  this->dV_.set (x);
}

const t_road_planView_geometry_paramPoly3::pRange_type& t_road_planView_geometry_paramPoly3::
pRange () const
{
  return this->pRange_.get ();
}

t_road_planView_geometry_paramPoly3::pRange_type& t_road_planView_geometry_paramPoly3::
pRange ()
{
  return this->pRange_.get ();
}

void t_road_planView_geometry_paramPoly3::
pRange (const pRange_type& x)
{
  this->pRange_.set (x);
}

void t_road_planView_geometry_paramPoly3::
pRange (::std::auto_ptr< pRange_type > x)
{
  this->pRange_.set (x);
}


// t_road_planView_geometry_poly3
// 

const t_road_planView_geometry_poly3::a_type& t_road_planView_geometry_poly3::
a () const
{
  return this->a_.get ();
}

t_road_planView_geometry_poly3::a_type& t_road_planView_geometry_poly3::
a ()
{
  return this->a_.get ();
}

void t_road_planView_geometry_poly3::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_planView_geometry_poly3::b_type& t_road_planView_geometry_poly3::
b () const
{
  return this->b_.get ();
}

t_road_planView_geometry_poly3::b_type& t_road_planView_geometry_poly3::
b ()
{
  return this->b_.get ();
}

void t_road_planView_geometry_poly3::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_planView_geometry_poly3::c_type& t_road_planView_geometry_poly3::
c () const
{
  return this->c_.get ();
}

t_road_planView_geometry_poly3::c_type& t_road_planView_geometry_poly3::
c ()
{
  return this->c_.get ();
}

void t_road_planView_geometry_poly3::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_planView_geometry_poly3::d_type& t_road_planView_geometry_poly3::
d () const
{
  return this->d_.get ();
}

t_road_planView_geometry_poly3::d_type& t_road_planView_geometry_poly3::
d ()
{
  return this->d_.get ();
}

void t_road_planView_geometry_poly3::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_planView_geometry_spiral
// 

const t_road_planView_geometry_spiral::curvStart_type& t_road_planView_geometry_spiral::
curvStart () const
{
  return this->curvStart_.get ();
}

t_road_planView_geometry_spiral::curvStart_type& t_road_planView_geometry_spiral::
curvStart ()
{
  return this->curvStart_.get ();
}

void t_road_planView_geometry_spiral::
curvStart (const curvStart_type& x)
{
  this->curvStart_.set (x);
}

const t_road_planView_geometry_spiral::curvEnd_type& t_road_planView_geometry_spiral::
curvEnd () const
{
  return this->curvEnd_.get ();
}

t_road_planView_geometry_spiral::curvEnd_type& t_road_planView_geometry_spiral::
curvEnd ()
{
  return this->curvEnd_.get ();
}

void t_road_planView_geometry_spiral::
curvEnd (const curvEnd_type& x)
{
  this->curvEnd_.set (x);
}


// t_road_surface
// 

const t_road_surface::CRG_sequence& t_road_surface::
CRG () const
{
  return this->CRG_;
}

t_road_surface::CRG_sequence& t_road_surface::
CRG ()
{
  return this->CRG_;
}

void t_road_surface::
CRG (const CRG_sequence& s)
{
  this->CRG_ = s;
}

const t_road_surface::include_sequence& t_road_surface::
include () const
{
  return this->include_;
}

t_road_surface::include_sequence& t_road_surface::
include ()
{
  return this->include_;
}

void t_road_surface::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_surface::userData_sequence& t_road_surface::
userData () const
{
  return this->userData_;
}

t_road_surface::userData_sequence& t_road_surface::
userData ()
{
  return this->userData_;
}

void t_road_surface::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_surface::dataQuality_sequence& t_road_surface::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_surface::dataQuality_sequence& t_road_surface::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_surface::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_road_surface_CRG
// 

const t_road_surface_CRG::file_type& t_road_surface_CRG::
file () const
{
  return this->file_.get ();
}

t_road_surface_CRG::file_type& t_road_surface_CRG::
file ()
{
  return this->file_.get ();
}

void t_road_surface_CRG::
file (const file_type& x)
{
  this->file_.set (x);
}

void t_road_surface_CRG::
file (::std::auto_ptr< file_type > x)
{
  this->file_.set (x);
}

const t_road_surface_CRG::sStart_type& t_road_surface_CRG::
sStart () const
{
  return this->sStart_.get ();
}

t_road_surface_CRG::sStart_type& t_road_surface_CRG::
sStart ()
{
  return this->sStart_.get ();
}

void t_road_surface_CRG::
sStart (const sStart_type& x)
{
  this->sStart_.set (x);
}

void t_road_surface_CRG::
sStart (::std::auto_ptr< sStart_type > x)
{
  this->sStart_.set (x);
}

const t_road_surface_CRG::sEnd_type& t_road_surface_CRG::
sEnd () const
{
  return this->sEnd_.get ();
}

t_road_surface_CRG::sEnd_type& t_road_surface_CRG::
sEnd ()
{
  return this->sEnd_.get ();
}

void t_road_surface_CRG::
sEnd (const sEnd_type& x)
{
  this->sEnd_.set (x);
}

void t_road_surface_CRG::
sEnd (::std::auto_ptr< sEnd_type > x)
{
  this->sEnd_.set (x);
}

const t_road_surface_CRG::orientation_type& t_road_surface_CRG::
orientation () const
{
  return this->orientation_.get ();
}

t_road_surface_CRG::orientation_type& t_road_surface_CRG::
orientation ()
{
  return this->orientation_.get ();
}

void t_road_surface_CRG::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void t_road_surface_CRG::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}

const t_road_surface_CRG::mode_type& t_road_surface_CRG::
mode () const
{
  return this->mode_.get ();
}

t_road_surface_CRG::mode_type& t_road_surface_CRG::
mode ()
{
  return this->mode_.get ();
}

void t_road_surface_CRG::
mode (const mode_type& x)
{
  this->mode_.set (x);
}

void t_road_surface_CRG::
mode (::std::auto_ptr< mode_type > x)
{
  this->mode_.set (x);
}

const t_road_surface_CRG::purpose_optional& t_road_surface_CRG::
purpose () const
{
  return this->purpose_;
}

t_road_surface_CRG::purpose_optional& t_road_surface_CRG::
purpose ()
{
  return this->purpose_;
}

void t_road_surface_CRG::
purpose (const purpose_type& x)
{
  this->purpose_.set (x);
}

void t_road_surface_CRG::
purpose (const purpose_optional& x)
{
  this->purpose_ = x;
}

void t_road_surface_CRG::
purpose (::std::auto_ptr< purpose_type > x)
{
  this->purpose_.set (x);
}

const t_road_surface_CRG::sOffset_optional& t_road_surface_CRG::
sOffset () const
{
  return this->sOffset_;
}

t_road_surface_CRG::sOffset_optional& t_road_surface_CRG::
sOffset ()
{
  return this->sOffset_;
}

void t_road_surface_CRG::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_surface_CRG::
sOffset (const sOffset_optional& x)
{
  this->sOffset_ = x;
}

const t_road_surface_CRG::tOffset_optional& t_road_surface_CRG::
tOffset () const
{
  return this->tOffset_;
}

t_road_surface_CRG::tOffset_optional& t_road_surface_CRG::
tOffset ()
{
  return this->tOffset_;
}

void t_road_surface_CRG::
tOffset (const tOffset_type& x)
{
  this->tOffset_.set (x);
}

void t_road_surface_CRG::
tOffset (const tOffset_optional& x)
{
  this->tOffset_ = x;
}

const t_road_surface_CRG::zOffset_optional& t_road_surface_CRG::
zOffset () const
{
  return this->zOffset_;
}

t_road_surface_CRG::zOffset_optional& t_road_surface_CRG::
zOffset ()
{
  return this->zOffset_;
}

void t_road_surface_CRG::
zOffset (const zOffset_type& x)
{
  this->zOffset_.set (x);
}

void t_road_surface_CRG::
zOffset (const zOffset_optional& x)
{
  this->zOffset_ = x;
}

const t_road_surface_CRG::zScale_optional& t_road_surface_CRG::
zScale () const
{
  return this->zScale_;
}

t_road_surface_CRG::zScale_optional& t_road_surface_CRG::
zScale ()
{
  return this->zScale_;
}

void t_road_surface_CRG::
zScale (const zScale_type& x)
{
  this->zScale_.set (x);
}

void t_road_surface_CRG::
zScale (const zScale_optional& x)
{
  this->zScale_ = x;
}

const t_road_surface_CRG::hOffset_optional& t_road_surface_CRG::
hOffset () const
{
  return this->hOffset_;
}

t_road_surface_CRG::hOffset_optional& t_road_surface_CRG::
hOffset ()
{
  return this->hOffset_;
}

void t_road_surface_CRG::
hOffset (const hOffset_type& x)
{
  this->hOffset_.set (x);
}

void t_road_surface_CRG::
hOffset (const hOffset_optional& x)
{
  this->hOffset_ = x;
}


// t_road_type
// 

const t_road_type::speed_optional& t_road_type::
speed () const
{
  return this->speed_;
}

t_road_type::speed_optional& t_road_type::
speed ()
{
  return this->speed_;
}

void t_road_type::
speed (const speed_type& x)
{
  this->speed_.set (x);
}

void t_road_type::
speed (const speed_optional& x)
{
  this->speed_ = x;
}

void t_road_type::
speed (::std::auto_ptr< speed_type > x)
{
  this->speed_.set (x);
}

const t_road_type::include_sequence& t_road_type::
include () const
{
  return this->include_;
}

t_road_type::include_sequence& t_road_type::
include ()
{
  return this->include_;
}

void t_road_type::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_type::userData_sequence& t_road_type::
userData () const
{
  return this->userData_;
}

t_road_type::userData_sequence& t_road_type::
userData ()
{
  return this->userData_;
}

void t_road_type::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_type::dataQuality_sequence& t_road_type::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_type::dataQuality_sequence& t_road_type::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_type::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_road_type::s_type& t_road_type::
s () const
{
  return this->s_.get ();
}

t_road_type::s_type& t_road_type::
s ()
{
  return this->s_.get ();
}

void t_road_type::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_type::
s (::std::auto_ptr< s_type > x)
{
  this->s_.set (x);
}

const t_road_type::type_type& t_road_type::
type () const
{
  return this->type_.get ();
}

t_road_type::type_type& t_road_type::
type ()
{
  return this->type_.get ();
}

void t_road_type::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_type::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const t_road_type::country_optional& t_road_type::
country () const
{
  return this->country_;
}

t_road_type::country_optional& t_road_type::
country ()
{
  return this->country_;
}

void t_road_type::
country (const country_type& x)
{
  this->country_.set (x);
}

void t_road_type::
country (const country_optional& x)
{
  this->country_ = x;
}

void t_road_type::
country (::std::auto_ptr< country_type > x)
{
  this->country_.set (x);
}


// t_road_type_speed
// 

const t_road_type_speed::max_type& t_road_type_speed::
max () const
{
  return this->max_.get ();
}

t_road_type_speed::max_type& t_road_type_speed::
max ()
{
  return this->max_.get ();
}

void t_road_type_speed::
max (const max_type& x)
{
  this->max_.set (x);
}

void t_road_type_speed::
max (::std::auto_ptr< max_type > x)
{
  this->max_.set (x);
}

const t_road_type_speed::unit_optional& t_road_type_speed::
unit () const
{
  return this->unit_;
}

t_road_type_speed::unit_optional& t_road_type_speed::
unit ()
{
  return this->unit_;
}

void t_road_type_speed::
unit (const unit_type& x)
{
  this->unit_.set (x);
}

void t_road_type_speed::
unit (const unit_optional& x)
{
  this->unit_ = x;
}

void t_road_type_speed::
unit (::std::auto_ptr< unit_type > x)
{
  this->unit_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// e_countryCode
//

e_countryCode::
e_countryCode (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

e_countryCode::
e_countryCode (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

e_countryCode::
e_countryCode (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

e_countryCode* e_countryCode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_countryCode (*this, f, c);
}

// e_countryCode_deprecated
//

e_countryCode_deprecated::
e_countryCode_deprecated (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_countryCode_deprecated_convert ();
}

e_countryCode_deprecated::
e_countryCode_deprecated (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_countryCode_deprecated_convert ();
}

e_countryCode_deprecated::
e_countryCode_deprecated (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_countryCode_deprecated_convert ();
}

e_countryCode_deprecated* e_countryCode_deprecated::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_countryCode_deprecated (*this, f, c);
}

e_countryCode_deprecated::value e_countryCode_deprecated::
_xsd_e_countryCode_deprecated_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_countryCode_deprecated_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_countryCode_deprecated_indexes_,
                    _xsd_e_countryCode_deprecated_indexes_ + 9,
                    *this,
                    c));

  if (i == _xsd_e_countryCode_deprecated_indexes_ + 9 || _xsd_e_countryCode_deprecated_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_countryCode_deprecated::
_xsd_e_countryCode_deprecated_literals_[9] =
{
  "OpenDRIVE",
  "Austria",
  "Brazil",
  "China",
  "France",
  "Germany",
  "Italy",
  "Switzerland",
  "USA"
};

const e_countryCode_deprecated::value e_countryCode_deprecated::
_xsd_e_countryCode_deprecated_indexes_[9] =
{
  ::e_countryCode_deprecated::Austria,
  ::e_countryCode_deprecated::Brazil,
  ::e_countryCode_deprecated::China,
  ::e_countryCode_deprecated::France,
  ::e_countryCode_deprecated::Germany,
  ::e_countryCode_deprecated::Italy,
  ::e_countryCode_deprecated::OpenDRIVE,
  ::e_countryCode_deprecated::Switzerland,
  ::e_countryCode_deprecated::USA
};

// e_countryCode_iso3166alpha2
//

e_countryCode_iso3166alpha2::
e_countryCode_iso3166alpha2 ()
: ::xml_schema::string ()
{
}

e_countryCode_iso3166alpha2::
e_countryCode_iso3166alpha2 (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

e_countryCode_iso3166alpha2::
e_countryCode_iso3166alpha2 (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

e_countryCode_iso3166alpha2::
e_countryCode_iso3166alpha2 (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

e_countryCode_iso3166alpha2::
e_countryCode_iso3166alpha2 (const e_countryCode_iso3166alpha2& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

e_countryCode_iso3166alpha2::
e_countryCode_iso3166alpha2 (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

e_countryCode_iso3166alpha2::
e_countryCode_iso3166alpha2 (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

e_countryCode_iso3166alpha2::
e_countryCode_iso3166alpha2 (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

e_countryCode_iso3166alpha2* e_countryCode_iso3166alpha2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_countryCode_iso3166alpha2 (*this, f, c);
}

e_countryCode_iso3166alpha2::
~e_countryCode_iso3166alpha2 ()
{
}

// e_countryCode_iso3166alpha3_deprecated
//

e_countryCode_iso3166alpha3_deprecated::
e_countryCode_iso3166alpha3_deprecated ()
: ::xml_schema::string ()
{
}

e_countryCode_iso3166alpha3_deprecated::
e_countryCode_iso3166alpha3_deprecated (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

e_countryCode_iso3166alpha3_deprecated::
e_countryCode_iso3166alpha3_deprecated (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

e_countryCode_iso3166alpha3_deprecated::
e_countryCode_iso3166alpha3_deprecated (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

e_countryCode_iso3166alpha3_deprecated::
e_countryCode_iso3166alpha3_deprecated (const e_countryCode_iso3166alpha3_deprecated& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

e_countryCode_iso3166alpha3_deprecated::
e_countryCode_iso3166alpha3_deprecated (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

e_countryCode_iso3166alpha3_deprecated::
e_countryCode_iso3166alpha3_deprecated (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

e_countryCode_iso3166alpha3_deprecated::
e_countryCode_iso3166alpha3_deprecated (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

e_countryCode_iso3166alpha3_deprecated* e_countryCode_iso3166alpha3_deprecated::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_countryCode_iso3166alpha3_deprecated (*this, f, c);
}

e_countryCode_iso3166alpha3_deprecated::
~e_countryCode_iso3166alpha3_deprecated ()
{
}

// e_direction
//

e_direction::
e_direction (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_direction_convert ();
}

e_direction::
e_direction (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_direction_convert ();
}

e_direction::
e_direction (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_direction_convert ();
}

e_direction* e_direction::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_direction (*this, f, c);
}

e_direction::value e_direction::
_xsd_e_direction_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_direction_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_direction_indexes_,
                    _xsd_e_direction_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_direction_indexes_ + 2 || _xsd_e_direction_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_direction::
_xsd_e_direction_literals_[2] =
{
  "same",
  "opposite"
};

const e_direction::value e_direction::
_xsd_e_direction_indexes_[2] =
{
  ::e_direction::opposite,
  ::e_direction::same
};

// e_maxSpeedString
//

e_maxSpeedString::
e_maxSpeedString (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_maxSpeedString_convert ();
}

e_maxSpeedString::
e_maxSpeedString (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_maxSpeedString_convert ();
}

e_maxSpeedString::
e_maxSpeedString (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_maxSpeedString_convert ();
}

e_maxSpeedString* e_maxSpeedString::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_maxSpeedString (*this, f, c);
}

e_maxSpeedString::value e_maxSpeedString::
_xsd_e_maxSpeedString_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_maxSpeedString_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_maxSpeedString_indexes_,
                    _xsd_e_maxSpeedString_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_maxSpeedString_indexes_ + 2 || _xsd_e_maxSpeedString_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_maxSpeedString::
_xsd_e_maxSpeedString_literals_[2] =
{
  "no limit",
  "undefined"
};

const e_maxSpeedString::value e_maxSpeedString::
_xsd_e_maxSpeedString_indexes_[2] =
{
  ::e_maxSpeedString::no_limit,
  ::e_maxSpeedString::undefined
};

// e_paramPoly3_pRange
//

e_paramPoly3_pRange::
e_paramPoly3_pRange (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_paramPoly3_pRange_convert ();
}

e_paramPoly3_pRange::
e_paramPoly3_pRange (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_paramPoly3_pRange_convert ();
}

e_paramPoly3_pRange::
e_paramPoly3_pRange (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_paramPoly3_pRange_convert ();
}

e_paramPoly3_pRange* e_paramPoly3_pRange::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_paramPoly3_pRange (*this, f, c);
}

e_paramPoly3_pRange::value e_paramPoly3_pRange::
_xsd_e_paramPoly3_pRange_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_paramPoly3_pRange_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_paramPoly3_pRange_indexes_,
                    _xsd_e_paramPoly3_pRange_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_paramPoly3_pRange_indexes_ + 2 || _xsd_e_paramPoly3_pRange_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_paramPoly3_pRange::
_xsd_e_paramPoly3_pRange_literals_[2] =
{
  "arcLength",
  "normalized"
};

const e_paramPoly3_pRange::value e_paramPoly3_pRange::
_xsd_e_paramPoly3_pRange_indexes_[2] =
{
  ::e_paramPoly3_pRange::arcLength,
  ::e_paramPoly3_pRange::normalized
};

// e_road_link_elementType
//

e_road_link_elementType::
e_road_link_elementType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_road_link_elementType_convert ();
}

e_road_link_elementType::
e_road_link_elementType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_road_link_elementType_convert ();
}

e_road_link_elementType::
e_road_link_elementType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_road_link_elementType_convert ();
}

e_road_link_elementType* e_road_link_elementType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_road_link_elementType (*this, f, c);
}

e_road_link_elementType::value e_road_link_elementType::
_xsd_e_road_link_elementType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_link_elementType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_road_link_elementType_indexes_,
                    _xsd_e_road_link_elementType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_road_link_elementType_indexes_ + 2 || _xsd_e_road_link_elementType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_road_link_elementType::
_xsd_e_road_link_elementType_literals_[2] =
{
  "road",
  "junction"
};

const e_road_link_elementType::value e_road_link_elementType::
_xsd_e_road_link_elementType_indexes_[2] =
{
  ::e_road_link_elementType::junction,
  ::e_road_link_elementType::road
};

// e_roadType
//

e_roadType::
e_roadType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_roadType_convert ();
}

e_roadType::
e_roadType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_roadType_convert ();
}

e_roadType::
e_roadType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_roadType_convert ();
}

e_roadType* e_roadType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_roadType (*this, f, c);
}

e_roadType::value e_roadType::
_xsd_e_roadType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_roadType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_roadType_indexes_,
                    _xsd_e_roadType_indexes_ + 13,
                    *this,
                    c));

  if (i == _xsd_e_roadType_indexes_ + 13 || _xsd_e_roadType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_roadType::
_xsd_e_roadType_literals_[13] =
{
  "unknown",
  "rural",
  "motorway",
  "town",
  "lowSpeed",
  "pedestrian",
  "bicycle",
  "townExpressway",
  "townCollector",
  "townArterial",
  "townPrivate",
  "townLocal",
  "townPlayStreet"
};

const e_roadType::value e_roadType::
_xsd_e_roadType_indexes_[13] =
{
  ::e_roadType::bicycle,
  ::e_roadType::lowSpeed,
  ::e_roadType::motorway,
  ::e_roadType::pedestrian,
  ::e_roadType::rural,
  ::e_roadType::town,
  ::e_roadType::townArterial,
  ::e_roadType::townCollector,
  ::e_roadType::townExpressway,
  ::e_roadType::townLocal,
  ::e_roadType::townPlayStreet,
  ::e_roadType::townPrivate,
  ::e_roadType::unknown
};

// e_trafficRule
//

e_trafficRule::
e_trafficRule (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_trafficRule_convert ();
}

e_trafficRule::
e_trafficRule (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_trafficRule_convert ();
}

e_trafficRule::
e_trafficRule (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_trafficRule_convert ();
}

e_trafficRule* e_trafficRule::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_trafficRule (*this, f, c);
}

e_trafficRule::value e_trafficRule::
_xsd_e_trafficRule_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_trafficRule_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_trafficRule_indexes_,
                    _xsd_e_trafficRule_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_trafficRule_indexes_ + 2 || _xsd_e_trafficRule_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_trafficRule::
_xsd_e_trafficRule_literals_[2] =
{
  "RHT",
  "LHT"
};

const e_trafficRule::value e_trafficRule::
_xsd_e_trafficRule_indexes_[2] =
{
  ::e_trafficRule::LHT,
  ::e_trafficRule::RHT
};

// t_maxSpeed
//

t_maxSpeed::
t_maxSpeed (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

t_maxSpeed::
t_maxSpeed (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

t_maxSpeed::
t_maxSpeed (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

t_maxSpeed* t_maxSpeed::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_maxSpeed (*this, f, c);
}

// t_road
//

t_road::
t_road (const planView_type& planView,
        const lanes_type& lanes,
        const length_type& length,
        const id_type& id,
        const junction_type& junction)
: ::_OpenDriveElement (),
  link_ (this),
  type_ (this),
  planView_ (planView, this),
  elevationProfile_ (this),
  lateralProfile_ (this),
  lanes_ (lanes, this),
  objects_ (this),
  signals_ (this),
  surface_ (this),
  railroad_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  name_ (this),
  length_ (length, this),
  id_ (id, this),
  junction_ (junction, this),
  rule_ (this)
{
}

t_road::
t_road (::std::auto_ptr< planView_type > planView,
        ::std::auto_ptr< lanes_type > lanes,
        const length_type& length,
        const id_type& id,
        const junction_type& junction)
: ::_OpenDriveElement (),
  link_ (this),
  type_ (this),
  planView_ (planView, this),
  elevationProfile_ (this),
  lateralProfile_ (this),
  lanes_ (lanes, this),
  objects_ (this),
  signals_ (this),
  surface_ (this),
  railroad_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  name_ (this),
  length_ (length, this),
  id_ (id, this),
  junction_ (junction, this),
  rule_ (this)
{
}

t_road::
t_road (const t_road& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  link_ (x.link_, f, this),
  type_ (x.type_, f, this),
  planView_ (x.planView_, f, this),
  elevationProfile_ (x.elevationProfile_, f, this),
  lateralProfile_ (x.lateralProfile_, f, this),
  lanes_ (x.lanes_, f, this),
  objects_ (x.objects_, f, this),
  signals_ (x.signals_, f, this),
  surface_ (x.surface_, f, this),
  railroad_ (x.railroad_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  name_ (x.name_, f, this),
  length_ (x.length_, f, this),
  id_ (x.id_, f, this),
  junction_ (x.junction_, f, this),
  rule_ (x.rule_, f, this)
{
}

t_road::
t_road (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  link_ (this),
  type_ (this),
  planView_ (this),
  elevationProfile_ (this),
  lateralProfile_ (this),
  lanes_ (this),
  objects_ (this),
  signals_ (this),
  surface_ (this),
  railroad_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  name_ (this),
  length_ (this),
  id_ (this),
  junction_ (this),
  rule_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // link
    //
    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< link_type > r (
        link_traits::create (i, f, this));

      if (!this->link_)
      {
        this->link_.set (r);
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type_.push_back (r);
      continue;
    }

    // planView
    //
    if (n.name () == "planView" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< planView_type > r (
        planView_traits::create (i, f, this));

      if (!planView_.present ())
      {
        this->planView_.set (r);
        continue;
      }
    }

    // elevationProfile
    //
    if (n.name () == "elevationProfile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< elevationProfile_type > r (
        elevationProfile_traits::create (i, f, this));

      if (!this->elevationProfile_)
      {
        this->elevationProfile_.set (r);
        continue;
      }
    }

    // lateralProfile
    //
    if (n.name () == "lateralProfile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lateralProfile_type > r (
        lateralProfile_traits::create (i, f, this));

      if (!this->lateralProfile_)
      {
        this->lateralProfile_.set (r);
        continue;
      }
    }

    // lanes
    //
    if (n.name () == "lanes" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lanes_type > r (
        lanes_traits::create (i, f, this));

      if (!lanes_.present ())
      {
        this->lanes_.set (r);
        continue;
      }
    }

    // objects
    //
    if (n.name () == "objects" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< objects_type > r (
        objects_traits::create (i, f, this));

      if (!this->objects_)
      {
        this->objects_.set (r);
        continue;
      }
    }

    // signals
    //
    if (n.name () == "signals" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< signals_type > r (
        signals_traits::create (i, f, this));

      if (!this->signals_)
      {
        this->signals_.set (r);
        continue;
      }
    }

    // surface
    //
    if (n.name () == "surface" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< surface_type > r (
        surface_traits::create (i, f, this));

      if (!this->surface_)
      {
        this->surface_.set (r);
        continue;
      }
    }

    // railroad
    //
    if (n.name () == "railroad" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< railroad_type > r (
        railroad_traits::create (i, f, this));

      if (!this->railroad_)
      {
        this->railroad_.set (r);
        continue;
      }
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  if (!planView_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "planView",
      "");
  }

  if (!lanes_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "lanes",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "junction" && n.namespace_ ().empty ())
    {
      this->junction_.set (junction_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rule" && n.namespace_ ().empty ())
    {
      this->rule_.set (rule_traits::create (i, f, this));
      continue;
    }
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!junction_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "junction",
      "");
  }
}

t_road* t_road::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road (*this, f, c);
}

t_road& t_road::
operator= (const t_road& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->link_ = x.link_;
    this->type_ = x.type_;
    this->planView_ = x.planView_;
    this->elevationProfile_ = x.elevationProfile_;
    this->lateralProfile_ = x.lateralProfile_;
    this->lanes_ = x.lanes_;
    this->objects_ = x.objects_;
    this->signals_ = x.signals_;
    this->surface_ = x.surface_;
    this->railroad_ = x.railroad_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->name_ = x.name_;
    this->length_ = x.length_;
    this->id_ = x.id_;
    this->junction_ = x.junction_;
    this->rule_ = x.rule_;
  }

  return *this;
}

t_road::
~t_road ()
{
}

// t_road_elevationProfile
//

t_road_elevationProfile::
t_road_elevationProfile ()
: ::_OpenDriveElement (),
  elevation_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_road_elevationProfile::
t_road_elevationProfile (const t_road_elevationProfile& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  elevation_ (x.elevation_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_elevationProfile::
t_road_elevationProfile (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  elevation_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_elevationProfile::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // elevation
    //
    if (n.name () == "elevation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< elevation_type > r (
        elevation_traits::create (i, f, this));

      this->elevation_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_road_elevationProfile* t_road_elevationProfile::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_elevationProfile (*this, f, c);
}

t_road_elevationProfile& t_road_elevationProfile::
operator= (const t_road_elevationProfile& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->elevation_ = x.elevation_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_elevationProfile::
~t_road_elevationProfile ()
{
}

// t_road_elevationProfile_elevation
//

t_road_elevationProfile_elevation::
t_road_elevationProfile_elevation (const s_type& s,
                                   const a_type& a,
                                   const b_type& b,
                                   const c_type& c,
                                   const d_type& d)
: ::_OpenDriveElement (),
  s_ (s, this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_elevationProfile_elevation::
t_road_elevationProfile_elevation (const t_road_elevationProfile_elevation& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  s_ (x.s_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_elevationProfile_elevation::
t_road_elevationProfile_elevation (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  s_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_elevationProfile_elevation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_elevationProfile_elevation* t_road_elevationProfile_elevation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_elevationProfile_elevation (*this, f, c);
}

t_road_elevationProfile_elevation& t_road_elevationProfile_elevation::
operator= (const t_road_elevationProfile_elevation& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->s_ = x.s_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_elevationProfile_elevation::
~t_road_elevationProfile_elevation ()
{
}

// t_road_lateralProfile
//

t_road_lateralProfile::
t_road_lateralProfile ()
: ::_OpenDriveElement (),
  superelevation_ (this),
  shape_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_road_lateralProfile::
t_road_lateralProfile (const t_road_lateralProfile& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  superelevation_ (x.superelevation_, f, this),
  shape_ (x.shape_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_lateralProfile::
t_road_lateralProfile (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  superelevation_ (this),
  shape_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_lateralProfile::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // superelevation
    //
    if (n.name () == "superelevation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< superelevation_type > r (
        superelevation_traits::create (i, f, this));

      this->superelevation_.push_back (r);
      continue;
    }

    // shape
    //
    if (n.name () == "shape" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< shape_type > r (
        shape_traits::create (i, f, this));

      this->shape_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_road_lateralProfile* t_road_lateralProfile::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lateralProfile (*this, f, c);
}

t_road_lateralProfile& t_road_lateralProfile::
operator= (const t_road_lateralProfile& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->superelevation_ = x.superelevation_;
    this->shape_ = x.shape_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_lateralProfile::
~t_road_lateralProfile ()
{
}

// t_road_lateralProfile_shape
//

t_road_lateralProfile_shape::
t_road_lateralProfile_shape (const s_type& s,
                             const t_type& t,
                             const a_type& a,
                             const b_type& b,
                             const c_type& c,
                             const d_type& d)
: ::_OpenDriveElement (),
  s_ (s, this),
  t_ (t, this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_lateralProfile_shape::
t_road_lateralProfile_shape (const t_road_lateralProfile_shape& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_lateralProfile_shape::
t_road_lateralProfile_shape (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  s_ (this),
  t_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_lateralProfile_shape::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_lateralProfile_shape* t_road_lateralProfile_shape::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lateralProfile_shape (*this, f, c);
}

t_road_lateralProfile_shape& t_road_lateralProfile_shape::
operator= (const t_road_lateralProfile_shape& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_lateralProfile_shape::
~t_road_lateralProfile_shape ()
{
}

// t_road_lateralProfile_superelevation
//

t_road_lateralProfile_superelevation::
t_road_lateralProfile_superelevation (const s_type& s,
                                      const a_type& a,
                                      const b_type& b,
                                      const c_type& c,
                                      const d_type& d)
: ::_OpenDriveElement (),
  s_ (s, this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_lateralProfile_superelevation::
t_road_lateralProfile_superelevation (const t_road_lateralProfile_superelevation& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  s_ (x.s_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_lateralProfile_superelevation::
t_road_lateralProfile_superelevation (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  s_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_lateralProfile_superelevation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_lateralProfile_superelevation* t_road_lateralProfile_superelevation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lateralProfile_superelevation (*this, f, c);
}

t_road_lateralProfile_superelevation& t_road_lateralProfile_superelevation::
operator= (const t_road_lateralProfile_superelevation& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->s_ = x.s_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_lateralProfile_superelevation::
~t_road_lateralProfile_superelevation ()
{
}

// t_road_link
//

t_road_link::
t_road_link ()
: ::_OpenDriveElement (),
  predecessor_ (this),
  successor_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_road_link::
t_road_link (const t_road_link& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  predecessor_ (x.predecessor_, f, this),
  successor_ (x.successor_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_link::
t_road_link (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  predecessor_ (this),
  successor_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_link::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // predecessor
    //
    if (n.name () == "predecessor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< predecessor_type > r (
        predecessor_traits::create (i, f, this));

      if (!this->predecessor_)
      {
        this->predecessor_.set (r);
        continue;
      }
    }

    // successor
    //
    if (n.name () == "successor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< successor_type > r (
        successor_traits::create (i, f, this));

      if (!this->successor_)
      {
        this->successor_.set (r);
        continue;
      }
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_road_link* t_road_link::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_link (*this, f, c);
}

t_road_link& t_road_link::
operator= (const t_road_link& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->predecessor_ = x.predecessor_;
    this->successor_ = x.successor_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_link::
~t_road_link ()
{
}

// t_road_link_predecessorSuccessor
//

t_road_link_predecessorSuccessor::
t_road_link_predecessorSuccessor (const elementId_type& elementId)
: ::_OpenDriveElement (),
  elementId_ (elementId, this),
  elementType_ (this),
  contactPoint_ (this),
  elementS_ (this),
  elementDir_ (this)
{
}

t_road_link_predecessorSuccessor::
t_road_link_predecessorSuccessor (const t_road_link_predecessorSuccessor& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  elementId_ (x.elementId_, f, this),
  elementType_ (x.elementType_, f, this),
  contactPoint_ (x.contactPoint_, f, this),
  elementS_ (x.elementS_, f, this),
  elementDir_ (x.elementDir_, f, this)
{
}

t_road_link_predecessorSuccessor::
t_road_link_predecessorSuccessor (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  elementId_ (this),
  elementType_ (this),
  contactPoint_ (this),
  elementS_ (this),
  elementDir_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_link_predecessorSuccessor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "elementId" && n.namespace_ ().empty ())
    {
      this->elementId_.set (elementId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementType" && n.namespace_ ().empty ())
    {
      this->elementType_.set (elementType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "contactPoint" && n.namespace_ ().empty ())
    {
      this->contactPoint_.set (contactPoint_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementS" && n.namespace_ ().empty ())
    {
      this->elementS_.set (elementS_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementDir" && n.namespace_ ().empty ())
    {
      this->elementDir_.set (elementDir_traits::create (i, f, this));
      continue;
    }
  }

  if (!elementId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "elementId",
      "");
  }
}

t_road_link_predecessorSuccessor* t_road_link_predecessorSuccessor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_link_predecessorSuccessor (*this, f, c);
}

t_road_link_predecessorSuccessor& t_road_link_predecessorSuccessor::
operator= (const t_road_link_predecessorSuccessor& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->elementId_ = x.elementId_;
    this->elementType_ = x.elementType_;
    this->contactPoint_ = x.contactPoint_;
    this->elementS_ = x.elementS_;
    this->elementDir_ = x.elementDir_;
  }

  return *this;
}

t_road_link_predecessorSuccessor::
~t_road_link_predecessorSuccessor ()
{
}

// t_road_planView
//

t_road_planView::
t_road_planView ()
: ::_OpenDriveElement (),
  geometry_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_road_planView::
t_road_planView (const t_road_planView& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  geometry_ (x.geometry_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_planView::
t_road_planView (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  geometry_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_planView::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // geometry
    //
    if (n.name () == "geometry" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geometry_type > r (
        geometry_traits::create (i, f, this));

      this->geometry_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_road_planView* t_road_planView::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_planView (*this, f, c);
}

t_road_planView& t_road_planView::
operator= (const t_road_planView& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->geometry_ = x.geometry_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_planView::
~t_road_planView ()
{
}

// t_road_planView_geometry
//

t_road_planView_geometry::
t_road_planView_geometry (const s_type& s,
                          const x_type& x,
                          const y_type& y,
                          const hdg_type& hdg,
                          const length_type& length)
: ::_OpenDriveElement (),
  line_ (this),
  spiral_ (this),
  arc_ (this),
  poly3_ (this),
  paramPoly3_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  s_ (s, this),
  x_ (x, this),
  y_ (y, this),
  hdg_ (hdg, this),
  length_ (length, this)
{
}

t_road_planView_geometry::
t_road_planView_geometry (const t_road_planView_geometry& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  line_ (x.line_, f, this),
  spiral_ (x.spiral_, f, this),
  arc_ (x.arc_, f, this),
  poly3_ (x.poly3_, f, this),
  paramPoly3_ (x.paramPoly3_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  hdg_ (x.hdg_, f, this),
  length_ (x.length_, f, this)
{
}

t_road_planView_geometry::
t_road_planView_geometry (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  line_ (this),
  spiral_ (this),
  arc_ (this),
  poly3_ (this),
  paramPoly3_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  s_ (this),
  x_ (this),
  y_ (this),
  hdg_ (this),
  length_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_planView_geometry::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // line
    //
    if (n.name () == "line" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< line_type > r (
        line_traits::create (i, f, this));

      if (!this->line_)
      {
        this->line_.set (r);
        continue;
      }
    }

    // spiral
    //
    if (n.name () == "spiral" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< spiral_type > r (
        spiral_traits::create (i, f, this));

      if (!this->spiral_)
      {
        this->spiral_.set (r);
        continue;
      }
    }

    // arc
    //
    if (n.name () == "arc" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< arc_type > r (
        arc_traits::create (i, f, this));

      if (!this->arc_)
      {
        this->arc_.set (r);
        continue;
      }
    }

    // poly3
    //
    if (n.name () == "poly3" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< poly3_type > r (
        poly3_traits::create (i, f, this));

      if (!this->poly3_)
      {
        this->poly3_.set (r);
        continue;
      }
    }

    // paramPoly3
    //
    if (n.name () == "paramPoly3" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< paramPoly3_type > r (
        paramPoly3_traits::create (i, f, this));

      if (!this->paramPoly3_)
      {
        this->paramPoly3_.set (r);
        continue;
      }
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hdg" && n.namespace_ ().empty ())
    {
      this->hdg_.set (hdg_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!hdg_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "hdg",
      "");
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }
}

t_road_planView_geometry* t_road_planView_geometry::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_planView_geometry (*this, f, c);
}

t_road_planView_geometry& t_road_planView_geometry::
operator= (const t_road_planView_geometry& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->line_ = x.line_;
    this->spiral_ = x.spiral_;
    this->arc_ = x.arc_;
    this->poly3_ = x.poly3_;
    this->paramPoly3_ = x.paramPoly3_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->hdg_ = x.hdg_;
    this->length_ = x.length_;
  }

  return *this;
}

t_road_planView_geometry::
~t_road_planView_geometry ()
{
}

// t_road_planView_geometry_arc
//

t_road_planView_geometry_arc::
t_road_planView_geometry_arc (const curvature_type& curvature)
: ::_OpenDriveElement (),
  curvature_ (curvature, this)
{
}

t_road_planView_geometry_arc::
t_road_planView_geometry_arc (const t_road_planView_geometry_arc& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  curvature_ (x.curvature_, f, this)
{
}

t_road_planView_geometry_arc::
t_road_planView_geometry_arc (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  curvature_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_planView_geometry_arc::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "curvature" && n.namespace_ ().empty ())
    {
      this->curvature_.set (curvature_traits::create (i, f, this));
      continue;
    }
  }

  if (!curvature_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "curvature",
      "");
  }
}

t_road_planView_geometry_arc* t_road_planView_geometry_arc::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_planView_geometry_arc (*this, f, c);
}

t_road_planView_geometry_arc& t_road_planView_geometry_arc::
operator= (const t_road_planView_geometry_arc& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->curvature_ = x.curvature_;
  }

  return *this;
}

t_road_planView_geometry_arc::
~t_road_planView_geometry_arc ()
{
}

// t_road_planView_geometry_line
//

t_road_planView_geometry_line::
t_road_planView_geometry_line ()
: ::_OpenDriveElement ()
{
}

t_road_planView_geometry_line::
t_road_planView_geometry_line (const t_road_planView_geometry_line& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c)
{
}

t_road_planView_geometry_line::
t_road_planView_geometry_line (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::_OpenDriveElement (e, f, c)
{
}

t_road_planView_geometry_line::
t_road_planView_geometry_line (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::_OpenDriveElement (a, f, c)
{
}

t_road_planView_geometry_line::
t_road_planView_geometry_line (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::_OpenDriveElement (s, e, f, c)
{
}

t_road_planView_geometry_line* t_road_planView_geometry_line::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_planView_geometry_line (*this, f, c);
}

t_road_planView_geometry_line::
~t_road_planView_geometry_line ()
{
}

// t_road_planView_geometry_paramPoly3
//

t_road_planView_geometry_paramPoly3::
t_road_planView_geometry_paramPoly3 (const aU_type& aU,
                                     const bU_type& bU,
                                     const cU_type& cU,
                                     const dU_type& dU,
                                     const aV_type& aV,
                                     const bV_type& bV,
                                     const cV_type& cV,
                                     const dV_type& dV,
                                     const pRange_type& pRange)
: ::_OpenDriveElement (),
  aU_ (aU, this),
  bU_ (bU, this),
  cU_ (cU, this),
  dU_ (dU, this),
  aV_ (aV, this),
  bV_ (bV, this),
  cV_ (cV, this),
  dV_ (dV, this),
  pRange_ (pRange, this)
{
}

t_road_planView_geometry_paramPoly3::
t_road_planView_geometry_paramPoly3 (const t_road_planView_geometry_paramPoly3& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  aU_ (x.aU_, f, this),
  bU_ (x.bU_, f, this),
  cU_ (x.cU_, f, this),
  dU_ (x.dU_, f, this),
  aV_ (x.aV_, f, this),
  bV_ (x.bV_, f, this),
  cV_ (x.cV_, f, this),
  dV_ (x.dV_, f, this),
  pRange_ (x.pRange_, f, this)
{
}

t_road_planView_geometry_paramPoly3::
t_road_planView_geometry_paramPoly3 (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  aU_ (this),
  bU_ (this),
  cU_ (this),
  dU_ (this),
  aV_ (this),
  bV_ (this),
  cV_ (this),
  dV_ (this),
  pRange_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_planView_geometry_paramPoly3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "aU" && n.namespace_ ().empty ())
    {
      this->aU_.set (aU_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "bU" && n.namespace_ ().empty ())
    {
      this->bU_.set (bU_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "cU" && n.namespace_ ().empty ())
    {
      this->cU_.set (cU_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dU" && n.namespace_ ().empty ())
    {
      this->dU_.set (dU_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "aV" && n.namespace_ ().empty ())
    {
      this->aV_.set (aV_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "bV" && n.namespace_ ().empty ())
    {
      this->bV_.set (bV_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "cV" && n.namespace_ ().empty ())
    {
      this->cV_.set (cV_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dV" && n.namespace_ ().empty ())
    {
      this->dV_.set (dV_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "pRange" && n.namespace_ ().empty ())
    {
      this->pRange_.set (pRange_traits::create (i, f, this));
      continue;
    }
  }

  if (!aU_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "aU",
      "");
  }

  if (!bU_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "bU",
      "");
  }

  if (!cU_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "cU",
      "");
  }

  if (!dU_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "dU",
      "");
  }

  if (!aV_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "aV",
      "");
  }

  if (!bV_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "bV",
      "");
  }

  if (!cV_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "cV",
      "");
  }

  if (!dV_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "dV",
      "");
  }

  if (!pRange_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "pRange",
      "");
  }
}

t_road_planView_geometry_paramPoly3* t_road_planView_geometry_paramPoly3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_planView_geometry_paramPoly3 (*this, f, c);
}

t_road_planView_geometry_paramPoly3& t_road_planView_geometry_paramPoly3::
operator= (const t_road_planView_geometry_paramPoly3& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->aU_ = x.aU_;
    this->bU_ = x.bU_;
    this->cU_ = x.cU_;
    this->dU_ = x.dU_;
    this->aV_ = x.aV_;
    this->bV_ = x.bV_;
    this->cV_ = x.cV_;
    this->dV_ = x.dV_;
    this->pRange_ = x.pRange_;
  }

  return *this;
}

t_road_planView_geometry_paramPoly3::
~t_road_planView_geometry_paramPoly3 ()
{
}

// t_road_planView_geometry_poly3
//

t_road_planView_geometry_poly3::
t_road_planView_geometry_poly3 (const a_type& a,
                                const b_type& b,
                                const c_type& c,
                                const d_type& d)
: ::_OpenDriveElement (),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_planView_geometry_poly3::
t_road_planView_geometry_poly3 (const t_road_planView_geometry_poly3& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_planView_geometry_poly3::
t_road_planView_geometry_poly3 (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_planView_geometry_poly3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_planView_geometry_poly3* t_road_planView_geometry_poly3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_planView_geometry_poly3 (*this, f, c);
}

t_road_planView_geometry_poly3& t_road_planView_geometry_poly3::
operator= (const t_road_planView_geometry_poly3& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_planView_geometry_poly3::
~t_road_planView_geometry_poly3 ()
{
}

// t_road_planView_geometry_spiral
//

t_road_planView_geometry_spiral::
t_road_planView_geometry_spiral (const curvStart_type& curvStart,
                                 const curvEnd_type& curvEnd)
: ::_OpenDriveElement (),
  curvStart_ (curvStart, this),
  curvEnd_ (curvEnd, this)
{
}

t_road_planView_geometry_spiral::
t_road_planView_geometry_spiral (const t_road_planView_geometry_spiral& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  curvStart_ (x.curvStart_, f, this),
  curvEnd_ (x.curvEnd_, f, this)
{
}

t_road_planView_geometry_spiral::
t_road_planView_geometry_spiral (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  curvStart_ (this),
  curvEnd_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_planView_geometry_spiral::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "curvStart" && n.namespace_ ().empty ())
    {
      this->curvStart_.set (curvStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "curvEnd" && n.namespace_ ().empty ())
    {
      this->curvEnd_.set (curvEnd_traits::create (i, f, this));
      continue;
    }
  }

  if (!curvStart_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "curvStart",
      "");
  }

  if (!curvEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "curvEnd",
      "");
  }
}

t_road_planView_geometry_spiral* t_road_planView_geometry_spiral::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_planView_geometry_spiral (*this, f, c);
}

t_road_planView_geometry_spiral& t_road_planView_geometry_spiral::
operator= (const t_road_planView_geometry_spiral& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->curvStart_ = x.curvStart_;
    this->curvEnd_ = x.curvEnd_;
  }

  return *this;
}

t_road_planView_geometry_spiral::
~t_road_planView_geometry_spiral ()
{
}

// t_road_surface
//

t_road_surface::
t_road_surface ()
: ::_OpenDriveElement (),
  CRG_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_road_surface::
t_road_surface (const t_road_surface& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  CRG_ (x.CRG_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_surface::
t_road_surface (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  CRG_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_surface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CRG
    //
    if (n.name () == "CRG" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CRG_type > r (
        CRG_traits::create (i, f, this));

      this->CRG_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_road_surface* t_road_surface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_surface (*this, f, c);
}

t_road_surface& t_road_surface::
operator= (const t_road_surface& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->CRG_ = x.CRG_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_surface::
~t_road_surface ()
{
}

// t_road_surface_CRG
//

t_road_surface_CRG::
t_road_surface_CRG (const file_type& file,
                    const sStart_type& sStart,
                    const sEnd_type& sEnd,
                    const orientation_type& orientation,
                    const mode_type& mode)
: ::_OpenDriveElement (),
  file_ (file, this),
  sStart_ (sStart, this),
  sEnd_ (sEnd, this),
  orientation_ (orientation, this),
  mode_ (mode, this),
  purpose_ (this),
  sOffset_ (this),
  tOffset_ (this),
  zOffset_ (this),
  zScale_ (this),
  hOffset_ (this)
{
}

t_road_surface_CRG::
t_road_surface_CRG (const t_road_surface_CRG& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  file_ (x.file_, f, this),
  sStart_ (x.sStart_, f, this),
  sEnd_ (x.sEnd_, f, this),
  orientation_ (x.orientation_, f, this),
  mode_ (x.mode_, f, this),
  purpose_ (x.purpose_, f, this),
  sOffset_ (x.sOffset_, f, this),
  tOffset_ (x.tOffset_, f, this),
  zOffset_ (x.zOffset_, f, this),
  zScale_ (x.zScale_, f, this),
  hOffset_ (x.hOffset_, f, this)
{
}

t_road_surface_CRG::
t_road_surface_CRG (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  file_ (this),
  sStart_ (this),
  sEnd_ (this),
  orientation_ (this),
  mode_ (this),
  purpose_ (this),
  sOffset_ (this),
  tOffset_ (this),
  zOffset_ (this),
  zScale_ (this),
  hOffset_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_surface_CRG::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "file" && n.namespace_ ().empty ())
    {
      this->file_.set (file_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sStart" && n.namespace_ ().empty ())
    {
      this->sStart_.set (sStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sEnd" && n.namespace_ ().empty ())
    {
      this->sEnd_.set (sEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      this->orientation_.set (orientation_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mode" && n.namespace_ ().empty ())
    {
      this->mode_.set (mode_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "purpose" && n.namespace_ ().empty ())
    {
      this->purpose_.set (purpose_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "tOffset" && n.namespace_ ().empty ())
    {
      this->tOffset_.set (tOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffset" && n.namespace_ ().empty ())
    {
      this->zOffset_.set (zOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zScale" && n.namespace_ ().empty ())
    {
      this->zScale_.set (zScale_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hOffset" && n.namespace_ ().empty ())
    {
      this->hOffset_.set (hOffset_traits::create (i, f, this));
      continue;
    }
  }

  if (!file_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "file",
      "");
  }

  if (!sStart_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sStart",
      "");
  }

  if (!sEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sEnd",
      "");
  }

  if (!orientation_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "orientation",
      "");
  }

  if (!mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "mode",
      "");
  }
}

t_road_surface_CRG* t_road_surface_CRG::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_surface_CRG (*this, f, c);
}

t_road_surface_CRG& t_road_surface_CRG::
operator= (const t_road_surface_CRG& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->file_ = x.file_;
    this->sStart_ = x.sStart_;
    this->sEnd_ = x.sEnd_;
    this->orientation_ = x.orientation_;
    this->mode_ = x.mode_;
    this->purpose_ = x.purpose_;
    this->sOffset_ = x.sOffset_;
    this->tOffset_ = x.tOffset_;
    this->zOffset_ = x.zOffset_;
    this->zScale_ = x.zScale_;
    this->hOffset_ = x.hOffset_;
  }

  return *this;
}

t_road_surface_CRG::
~t_road_surface_CRG ()
{
}

// t_road_type
//

t_road_type::
t_road_type (const s_type& s,
             const type_type& type)
: ::_OpenDriveElement (),
  speed_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  s_ (s, this),
  type_ (type, this),
  country_ (this)
{
}

t_road_type::
t_road_type (const t_road_type& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  speed_ (x.speed_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  type_ (x.type_, f, this),
  country_ (x.country_, f, this)
{
}

t_road_type::
t_road_type (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  speed_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  s_ (this),
  type_ (this),
  country_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // speed
    //
    if (n.name () == "speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< speed_type > r (
        speed_traits::create (i, f, this));

      if (!this->speed_)
      {
        this->speed_.set (r);
        continue;
      }
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "country" && n.namespace_ ().empty ())
    {
      this->country_.set (country_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

t_road_type* t_road_type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_type (*this, f, c);
}

t_road_type& t_road_type::
operator= (const t_road_type& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->speed_ = x.speed_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->type_ = x.type_;
    this->country_ = x.country_;
  }

  return *this;
}

t_road_type::
~t_road_type ()
{
}

// t_road_type_speed
//

t_road_type_speed::
t_road_type_speed (const max_type& max)
: ::_OpenDriveElement (),
  max_ (max, this),
  unit_ (this)
{
}

t_road_type_speed::
t_road_type_speed (const t_road_type_speed& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  max_ (x.max_, f, this),
  unit_ (x.unit_, f, this)
{
}

t_road_type_speed::
t_road_type_speed (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  max_ (this),
  unit_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_type_speed::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "max" && n.namespace_ ().empty ())
    {
      this->max_.set (max_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "unit" && n.namespace_ ().empty ())
    {
      this->unit_.set (unit_traits::create (i, f, this));
      continue;
    }
  }

  if (!max_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "max",
      "");
  }
}

t_road_type_speed* t_road_type_speed::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_type_speed (*this, f, c);
}

t_road_type_speed& t_road_type_speed::
operator= (const t_road_type_speed& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->max_ = x.max_;
    this->unit_ = x.unit_;
  }

  return *this;
}

t_road_type_speed::
~t_road_type_speed ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

