// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef XSD_SCHEMA_OPENDRIVE_16_CORE_HXX
#define XSD_SCHEMA_OPENDRIVE_16_CORE_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class e_dataQuality_RawData_PostProcessing;
class e_dataQuality_RawData_Source;
class e_unit;
class e_unitDistance;
class e_unitMass;
class e_unitSlope;
class e_unitSpeed;
class t_grEqZero;
class t_grZero;
class t_yesNo;
class t_zeroOne;
class _OpenDriveElement;
class t_dataQuality;
class t_dataQuality_Error;
class t_dataQuality_RawData;
class t_header;
class t_header_GeoReference;
class t_header_Offset;
class t_include;
class t_userData;
class OpenDRIVE;

#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "opendrive_16_railroad.hxx"

#include "opendrive_16_junction.hxx"

#include "opendrive_16_signal.hxx"

#include "opendrive_16_road.hxx"

class e_dataQuality_RawData_PostProcessing: public ::xml_schema::string
{
  public:
  enum value
  {
    raw,
    cleaned,
    processed,
    fused
  };

  e_dataQuality_RawData_PostProcessing (value v);

  e_dataQuality_RawData_PostProcessing (const char* v);

  e_dataQuality_RawData_PostProcessing (const ::std::string& v);

  e_dataQuality_RawData_PostProcessing (const ::xml_schema::string& v);

  e_dataQuality_RawData_PostProcessing (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  e_dataQuality_RawData_PostProcessing (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  e_dataQuality_RawData_PostProcessing (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  e_dataQuality_RawData_PostProcessing (const e_dataQuality_RawData_PostProcessing& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  virtual e_dataQuality_RawData_PostProcessing*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_dataQuality_RawData_PostProcessing&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_dataQuality_RawData_PostProcessing_convert ();
  }

  protected:
  value
  _xsd_e_dataQuality_RawData_PostProcessing_convert () const;

  public:
  static const char* const _xsd_e_dataQuality_RawData_PostProcessing_literals_[4];
  static const value _xsd_e_dataQuality_RawData_PostProcessing_indexes_[4];
};

class e_dataQuality_RawData_Source: public ::xml_schema::string
{
  public:
  enum value
  {
    sensor,
    cadaster,
    custom
  };

  e_dataQuality_RawData_Source (value v);

  e_dataQuality_RawData_Source (const char* v);

  e_dataQuality_RawData_Source (const ::std::string& v);

  e_dataQuality_RawData_Source (const ::xml_schema::string& v);

  e_dataQuality_RawData_Source (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  e_dataQuality_RawData_Source (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  e_dataQuality_RawData_Source (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  e_dataQuality_RawData_Source (const e_dataQuality_RawData_Source& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  virtual e_dataQuality_RawData_Source*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_dataQuality_RawData_Source&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_dataQuality_RawData_Source_convert ();
  }

  protected:
  value
  _xsd_e_dataQuality_RawData_Source_convert () const;

  public:
  static const char* const _xsd_e_dataQuality_RawData_Source_literals_[3];
  static const value _xsd_e_dataQuality_RawData_Source_indexes_[3];
};

class e_unit: public ::xml_schema::string
{
  public:
  enum value
  {
    m,
    km,
    ft,
    mile,
    m_s,
    mph,
    km_h,
    kg,
    t,
    cxx_
  };

  e_unit (value v);

  e_unit (const char* v);

  e_unit (const ::std::string& v);

  e_unit (const ::xml_schema::string& v);

  e_unit (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  e_unit (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  e_unit (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  e_unit (const e_unit& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual e_unit*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_unit&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_unit_convert ();
  }

  protected:
  value
  _xsd_e_unit_convert () const;

  public:
  static const char* const _xsd_e_unit_literals_[10];
  static const value _xsd_e_unit_indexes_[10];
};

class e_unitDistance: public ::xml_schema::string
{
  public:
  enum value
  {
    m,
    km,
    ft,
    mile
  };

  e_unitDistance (value v);

  e_unitDistance (const char* v);

  e_unitDistance (const ::std::string& v);

  e_unitDistance (const ::xml_schema::string& v);

  e_unitDistance (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_unitDistance (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_unitDistance (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_unitDistance (const e_unitDistance& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual e_unitDistance*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_unitDistance&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_unitDistance_convert ();
  }

  protected:
  value
  _xsd_e_unitDistance_convert () const;

  public:
  static const char* const _xsd_e_unitDistance_literals_[4];
  static const value _xsd_e_unitDistance_indexes_[4];
};

class e_unitMass: public ::xml_schema::string
{
  public:
  enum value
  {
    kg,
    t
  };

  e_unitMass (value v);

  e_unitMass (const char* v);

  e_unitMass (const ::std::string& v);

  e_unitMass (const ::xml_schema::string& v);

  e_unitMass (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_unitMass (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_unitMass (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_unitMass (const e_unitMass& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual e_unitMass*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_unitMass&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_unitMass_convert ();
  }

  protected:
  value
  _xsd_e_unitMass_convert () const;

  public:
  static const char* const _xsd_e_unitMass_literals_[2];
  static const value _xsd_e_unitMass_indexes_[2];
};

class e_unitSlope: public ::xml_schema::string
{
  public:
  enum value
  {
    cxx_
  };

  e_unitSlope (value v);

  e_unitSlope (const char* v);

  e_unitSlope (const ::std::string& v);

  e_unitSlope (const ::xml_schema::string& v);

  e_unitSlope (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_unitSlope (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_unitSlope (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_unitSlope (const e_unitSlope& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual e_unitSlope*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_unitSlope&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_unitSlope_convert ();
  }

  protected:
  value
  _xsd_e_unitSlope_convert () const;

  public:
  static const char* const _xsd_e_unitSlope_literals_[1];
  static const value _xsd_e_unitSlope_indexes_[1];
};

class e_unitSpeed: public ::xml_schema::string
{
  public:
  enum value
  {
    m_s,
    mph,
    km_h
  };

  e_unitSpeed (value v);

  e_unitSpeed (const char* v);

  e_unitSpeed (const ::std::string& v);

  e_unitSpeed (const ::xml_schema::string& v);

  e_unitSpeed (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_unitSpeed (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_unitSpeed (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_unitSpeed (const e_unitSpeed& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual e_unitSpeed*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_unitSpeed&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_unitSpeed_convert ();
  }

  protected:
  value
  _xsd_e_unitSpeed_convert () const;

  public:
  static const char* const _xsd_e_unitSpeed_literals_[3];
  static const value _xsd_e_unitSpeed_indexes_[3];
};

class t_grEqZero: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  // Constructors.
  //
  t_grEqZero (const ::xml_schema::double_&);

  t_grEqZero (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  t_grEqZero (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  t_grEqZero (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  t_grEqZero (const t_grEqZero& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual t_grEqZero*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~t_grEqZero ();
};

class t_grZero: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  // Constructors.
  //
  t_grZero (const ::xml_schema::double_&);

  t_grZero (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  t_grZero (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  t_grZero (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  t_grZero (const t_grZero& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual t_grZero*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~t_grZero ();
};

class t_yesNo: public ::xml_schema::string
{
  public:
  enum value
  {
    yes,
    no
  };

  t_yesNo (value v);

  t_yesNo (const char* v);

  t_yesNo (const ::std::string& v);

  t_yesNo (const ::xml_schema::string& v);

  t_yesNo (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  t_yesNo (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  t_yesNo (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  t_yesNo (const t_yesNo& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual t_yesNo*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_yesNo&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_t_yesNo_convert ();
  }

  protected:
  value
  _xsd_t_yesNo_convert () const;

  public:
  static const char* const _xsd_t_yesNo_literals_[2];
  static const value _xsd_t_yesNo_indexes_[2];
};

class t_zeroOne: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  // Constructors.
  //
  t_zeroOne (const ::xml_schema::double_&);

  t_zeroOne (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  t_zeroOne (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  t_zeroOne (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  t_zeroOne (const t_zeroOne& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual t_zeroOne*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~t_zeroOne ();
};

class _OpenDriveElement: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  _OpenDriveElement ();

  _OpenDriveElement (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  _OpenDriveElement (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  _OpenDriveElement (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  _OpenDriveElement (const _OpenDriveElement& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual _OpenDriveElement*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~_OpenDriveElement ();
};

class t_dataQuality: public ::xml_schema::type
{
  public:
  // error
  //
  typedef ::t_dataQuality_Error error_type;
  typedef ::xsd::cxx::tree::optional< error_type > error_optional;
  typedef ::xsd::cxx::tree::traits< error_type, char > error_traits;

  const error_optional&
  error () const;

  error_optional&
  error ();

  void
  error (const error_type& x);

  void
  error (const error_optional& x);

  void
  error (::std::auto_ptr< error_type > p);

  // rawData
  //
  typedef ::t_dataQuality_RawData rawData_type;
  typedef ::xsd::cxx::tree::optional< rawData_type > rawData_optional;
  typedef ::xsd::cxx::tree::traits< rawData_type, char > rawData_traits;

  const rawData_optional&
  rawData () const;

  rawData_optional&
  rawData ();

  void
  rawData (const rawData_type& x);

  void
  rawData (const rawData_optional& x);

  void
  rawData (::std::auto_ptr< rawData_type > p);

  // Constructors.
  //
  t_dataQuality ();

  t_dataQuality (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  t_dataQuality (const t_dataQuality& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual t_dataQuality*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_dataQuality&
  operator= (const t_dataQuality& x);

  virtual 
  ~t_dataQuality ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  error_optional error_;
  rawData_optional rawData_;
};

class t_dataQuality_Error: public ::xml_schema::type
{
  public:
  // xyAbsolute
  //
  typedef ::xml_schema::double_ xyAbsolute_type;
  typedef ::xsd::cxx::tree::traits< xyAbsolute_type, char, ::xsd::cxx::tree::schema_type::double_ > xyAbsolute_traits;

  const xyAbsolute_type&
  xyAbsolute () const;

  xyAbsolute_type&
  xyAbsolute ();

  void
  xyAbsolute (const xyAbsolute_type& x);

  // zAbsolute
  //
  typedef ::xml_schema::double_ zAbsolute_type;
  typedef ::xsd::cxx::tree::traits< zAbsolute_type, char, ::xsd::cxx::tree::schema_type::double_ > zAbsolute_traits;

  const zAbsolute_type&
  zAbsolute () const;

  zAbsolute_type&
  zAbsolute ();

  void
  zAbsolute (const zAbsolute_type& x);

  // xyRelative
  //
  typedef ::xml_schema::double_ xyRelative_type;
  typedef ::xsd::cxx::tree::traits< xyRelative_type, char, ::xsd::cxx::tree::schema_type::double_ > xyRelative_traits;

  const xyRelative_type&
  xyRelative () const;

  xyRelative_type&
  xyRelative ();

  void
  xyRelative (const xyRelative_type& x);

  // zRelative
  //
  typedef ::xml_schema::double_ zRelative_type;
  typedef ::xsd::cxx::tree::traits< zRelative_type, char, ::xsd::cxx::tree::schema_type::double_ > zRelative_traits;

  const zRelative_type&
  zRelative () const;

  zRelative_type&
  zRelative ();

  void
  zRelative (const zRelative_type& x);

  // Constructors.
  //
  t_dataQuality_Error (const xyAbsolute_type&,
                       const zAbsolute_type&,
                       const xyRelative_type&,
                       const zRelative_type&);

  t_dataQuality_Error (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  t_dataQuality_Error (const t_dataQuality_Error& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual t_dataQuality_Error*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_dataQuality_Error&
  operator= (const t_dataQuality_Error& x);

  virtual 
  ~t_dataQuality_Error ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< xyAbsolute_type > xyAbsolute_;
  ::xsd::cxx::tree::one< zAbsolute_type > zAbsolute_;
  ::xsd::cxx::tree::one< xyRelative_type > xyRelative_;
  ::xsd::cxx::tree::one< zRelative_type > zRelative_;
};

class t_dataQuality_RawData: public ::xml_schema::type
{
  public:
  // date
  //
  typedef ::xml_schema::string date_type;
  typedef ::xsd::cxx::tree::traits< date_type, char > date_traits;

  const date_type&
  date () const;

  date_type&
  date ();

  void
  date (const date_type& x);

  void
  date (::std::auto_ptr< date_type > p);

  // source
  //
  typedef ::e_dataQuality_RawData_Source source_type;
  typedef ::xsd::cxx::tree::traits< source_type, char > source_traits;

  const source_type&
  source () const;

  source_type&
  source ();

  void
  source (const source_type& x);

  void
  source (::std::auto_ptr< source_type > p);

  // sourceComment
  //
  typedef ::xml_schema::string sourceComment_type;
  typedef ::xsd::cxx::tree::optional< sourceComment_type > sourceComment_optional;
  typedef ::xsd::cxx::tree::traits< sourceComment_type, char > sourceComment_traits;

  const sourceComment_optional&
  sourceComment () const;

  sourceComment_optional&
  sourceComment ();

  void
  sourceComment (const sourceComment_type& x);

  void
  sourceComment (const sourceComment_optional& x);

  void
  sourceComment (::std::auto_ptr< sourceComment_type > p);

  // postProcessing
  //
  typedef ::e_dataQuality_RawData_PostProcessing postProcessing_type;
  typedef ::xsd::cxx::tree::traits< postProcessing_type, char > postProcessing_traits;

  const postProcessing_type&
  postProcessing () const;

  postProcessing_type&
  postProcessing ();

  void
  postProcessing (const postProcessing_type& x);

  void
  postProcessing (::std::auto_ptr< postProcessing_type > p);

  // postProcessingComment
  //
  typedef ::xml_schema::string postProcessingComment_type;
  typedef ::xsd::cxx::tree::optional< postProcessingComment_type > postProcessingComment_optional;
  typedef ::xsd::cxx::tree::traits< postProcessingComment_type, char > postProcessingComment_traits;

  const postProcessingComment_optional&
  postProcessingComment () const;

  postProcessingComment_optional&
  postProcessingComment ();

  void
  postProcessingComment (const postProcessingComment_type& x);

  void
  postProcessingComment (const postProcessingComment_optional& x);

  void
  postProcessingComment (::std::auto_ptr< postProcessingComment_type > p);

  // Constructors.
  //
  t_dataQuality_RawData (const date_type&,
                         const source_type&,
                         const postProcessing_type&);

  t_dataQuality_RawData (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  t_dataQuality_RawData (const t_dataQuality_RawData& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual t_dataQuality_RawData*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_dataQuality_RawData&
  operator= (const t_dataQuality_RawData& x);

  virtual 
  ~t_dataQuality_RawData ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< date_type > date_;
  ::xsd::cxx::tree::one< source_type > source_;
  sourceComment_optional sourceComment_;
  ::xsd::cxx::tree::one< postProcessing_type > postProcessing_;
  postProcessingComment_optional postProcessingComment_;
};

class t_header: public ::_OpenDriveElement
{
  public:
  // geoReference
  //
  typedef ::t_header_GeoReference geoReference_type;
  typedef ::xsd::cxx::tree::optional< geoReference_type > geoReference_optional;
  typedef ::xsd::cxx::tree::traits< geoReference_type, char > geoReference_traits;

  const geoReference_optional&
  geoReference () const;

  geoReference_optional&
  geoReference ();

  void
  geoReference (const geoReference_type& x);

  void
  geoReference (const geoReference_optional& x);

  void
  geoReference (::std::auto_ptr< geoReference_type > p);

  // offset
  //
  typedef ::t_header_Offset offset_type;
  typedef ::xsd::cxx::tree::optional< offset_type > offset_optional;
  typedef ::xsd::cxx::tree::traits< offset_type, char > offset_traits;

  const offset_optional&
  offset () const;

  offset_optional&
  offset ();

  void
  offset (const offset_type& x);

  void
  offset (const offset_optional& x);

  void
  offset (::std::auto_ptr< offset_type > p);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
  typedef dataQuality_sequence::iterator dataQuality_iterator;
  typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_sequence&
  dataQuality () const;

  dataQuality_sequence&
  dataQuality ();

  void
  dataQuality (const dataQuality_sequence& s);

  // revMajor
  //
  typedef ::xml_schema::integer revMajor_type;
  typedef ::xsd::cxx::tree::traits< revMajor_type, char > revMajor_traits;

  const revMajor_type&
  revMajor () const;

  static revMajor_type
  revMajor_default_value ();

  // revMinor
  //
  typedef ::xml_schema::integer revMinor_type;
  typedef ::xsd::cxx::tree::traits< revMinor_type, char > revMinor_traits;

  const revMinor_type&
  revMinor () const;

  revMinor_type&
  revMinor ();

  void
  revMinor (const revMinor_type& x);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::auto_ptr< name_type > p);

  // version
  //
  typedef ::xml_schema::string version_type;
  typedef ::xsd::cxx::tree::optional< version_type > version_optional;
  typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

  const version_optional&
  version () const;

  version_optional&
  version ();

  void
  version (const version_type& x);

  void
  version (const version_optional& x);

  void
  version (::std::auto_ptr< version_type > p);

  // date
  //
  typedef ::xml_schema::string date_type;
  typedef ::xsd::cxx::tree::optional< date_type > date_optional;
  typedef ::xsd::cxx::tree::traits< date_type, char > date_traits;

  const date_optional&
  date () const;

  date_optional&
  date ();

  void
  date (const date_type& x);

  void
  date (const date_optional& x);

  void
  date (::std::auto_ptr< date_type > p);

  // north
  //
  typedef ::xml_schema::double_ north_type;
  typedef ::xsd::cxx::tree::optional< north_type > north_optional;
  typedef ::xsd::cxx::tree::traits< north_type, char, ::xsd::cxx::tree::schema_type::double_ > north_traits;

  const north_optional&
  north () const;

  north_optional&
  north ();

  void
  north (const north_type& x);

  void
  north (const north_optional& x);

  // south
  //
  typedef ::xml_schema::double_ south_type;
  typedef ::xsd::cxx::tree::optional< south_type > south_optional;
  typedef ::xsd::cxx::tree::traits< south_type, char, ::xsd::cxx::tree::schema_type::double_ > south_traits;

  const south_optional&
  south () const;

  south_optional&
  south ();

  void
  south (const south_type& x);

  void
  south (const south_optional& x);

  // east
  //
  typedef ::xml_schema::double_ east_type;
  typedef ::xsd::cxx::tree::optional< east_type > east_optional;
  typedef ::xsd::cxx::tree::traits< east_type, char, ::xsd::cxx::tree::schema_type::double_ > east_traits;

  const east_optional&
  east () const;

  east_optional&
  east ();

  void
  east (const east_type& x);

  void
  east (const east_optional& x);

  // west
  //
  typedef ::xml_schema::double_ west_type;
  typedef ::xsd::cxx::tree::optional< west_type > west_optional;
  typedef ::xsd::cxx::tree::traits< west_type, char, ::xsd::cxx::tree::schema_type::double_ > west_traits;

  const west_optional&
  west () const;

  west_optional&
  west ();

  void
  west (const west_type& x);

  void
  west (const west_optional& x);

  // vendor
  //
  typedef ::xml_schema::string vendor_type;
  typedef ::xsd::cxx::tree::optional< vendor_type > vendor_optional;
  typedef ::xsd::cxx::tree::traits< vendor_type, char > vendor_traits;

  const vendor_optional&
  vendor () const;

  vendor_optional&
  vendor ();

  void
  vendor (const vendor_type& x);

  void
  vendor (const vendor_optional& x);

  void
  vendor (::std::auto_ptr< vendor_type > p);

  // Constructors.
  //
  t_header (const revMinor_type&);

  t_header (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  t_header (const t_header& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual t_header*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_header&
  operator= (const t_header& x);

  virtual 
  ~t_header ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  geoReference_optional geoReference_;
  offset_optional offset_;
  include_sequence include_;
  userData_sequence userData_;
  dataQuality_sequence dataQuality_;
  ::xsd::cxx::tree::one< revMajor_type > revMajor_;
  ::xsd::cxx::tree::one< revMinor_type > revMinor_;
  name_optional name_;
  version_optional version_;
  date_optional date_;
  north_optional north_;
  south_optional south_;
  east_optional east_;
  west_optional west_;
  vendor_optional vendor_;
};

class t_header_GeoReference: public ::xml_schema::type
{
  public:
  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
  typedef dataQuality_sequence::iterator dataQuality_iterator;
  typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_sequence&
  dataQuality () const;

  dataQuality_sequence&
  dataQuality ();

  void
  dataQuality (const dataQuality_sequence& s);

  // Constructors.
  //
  t_header_GeoReference ();

  t_header_GeoReference (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  t_header_GeoReference (const t_header_GeoReference& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual t_header_GeoReference*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_header_GeoReference&
  operator= (const t_header_GeoReference& x);

  virtual 
  ~t_header_GeoReference ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  include_sequence include_;
  userData_sequence userData_;
  dataQuality_sequence dataQuality_;
};

class t_header_Offset: public ::_OpenDriveElement
{
  public:
  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
  typedef dataQuality_sequence::iterator dataQuality_iterator;
  typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_sequence&
  dataQuality () const;

  dataQuality_sequence&
  dataQuality ();

  void
  dataQuality (const dataQuality_sequence& s);

  // x
  //
  typedef ::xml_schema::double_ x_type;
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

  const x_type&
  x () const;

  x_type&
  x ();

  void
  x (const x_type& x);

  // y
  //
  typedef ::xml_schema::double_ y_type;
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

  const y_type&
  y () const;

  y_type&
  y ();

  void
  y (const y_type& x);

  // z
  //
  typedef ::xml_schema::double_ z_type;
  typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

  const z_type&
  z () const;

  z_type&
  z ();

  void
  z (const z_type& x);

  // hdg
  //
  typedef ::xml_schema::float_ hdg_type;
  typedef ::xsd::cxx::tree::traits< hdg_type, char > hdg_traits;

  const hdg_type&
  hdg () const;

  hdg_type&
  hdg ();

  void
  hdg (const hdg_type& x);

  // Constructors.
  //
  t_header_Offset (const x_type&,
                   const y_type&,
                   const z_type&,
                   const hdg_type&);

  t_header_Offset (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  t_header_Offset (const t_header_Offset& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual t_header_Offset*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_header_Offset&
  operator= (const t_header_Offset& x);

  virtual 
  ~t_header_Offset ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  include_sequence include_;
  userData_sequence userData_;
  dataQuality_sequence dataQuality_;
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
  ::xsd::cxx::tree::one< z_type > z_;
  ::xsd::cxx::tree::one< hdg_type > hdg_;
};

class t_include: public ::xml_schema::type
{
  public:
  // file
  //
  typedef ::xml_schema::string file_type;
  typedef ::xsd::cxx::tree::traits< file_type, char > file_traits;

  const file_type&
  file () const;

  file_type&
  file ();

  void
  file (const file_type& x);

  void
  file (::std::auto_ptr< file_type > p);

  // Constructors.
  //
  t_include (const file_type&);

  t_include (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  t_include (const t_include& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual t_include*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_include&
  operator= (const t_include& x);

  virtual 
  ~t_include ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< file_type > file_;
};

class t_userData: public ::xml_schema::type
{
  public:
  // code
  //
  typedef ::xml_schema::string code_type;
  typedef ::xsd::cxx::tree::traits< code_type, char > code_traits;

  const code_type&
  code () const;

  code_type&
  code ();

  void
  code (const code_type& x);

  void
  code (::std::auto_ptr< code_type > p);

  // value
  //
  typedef ::xml_schema::string value_type;
  typedef ::xsd::cxx::tree::optional< value_type > value_optional;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_optional&
  value () const;

  value_optional&
  value ();

  void
  value (const value_type& x);

  void
  value (const value_optional& x);

  void
  value (::std::auto_ptr< value_type > p);

  // Constructors.
  //
  t_userData (const code_type&);

  t_userData (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  t_userData (const t_userData& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual t_userData*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_userData&
  operator= (const t_userData& x);

  virtual 
  ~t_userData ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< code_type > code_;
  value_optional value_;
};

class OpenDRIVE: public ::xml_schema::type
{
  public:
  // header
  //
  typedef ::t_header header_type;
  typedef ::xsd::cxx::tree::traits< header_type, char > header_traits;

  const header_type&
  header () const;

  header_type&
  header ();

  void
  header (const header_type& x);

  void
  header (::std::auto_ptr< header_type > p);

  // road
  //
  typedef ::t_road road_type;
  typedef ::xsd::cxx::tree::sequence< road_type > road_sequence;
  typedef road_sequence::iterator road_iterator;
  typedef road_sequence::const_iterator road_const_iterator;
  typedef ::xsd::cxx::tree::traits< road_type, char > road_traits;

  const road_sequence&
  road () const;

  road_sequence&
  road ();

  void
  road (const road_sequence& s);

  // controller
  //
  typedef ::t_controller controller_type;
  typedef ::xsd::cxx::tree::sequence< controller_type > controller_sequence;
  typedef controller_sequence::iterator controller_iterator;
  typedef controller_sequence::const_iterator controller_const_iterator;
  typedef ::xsd::cxx::tree::traits< controller_type, char > controller_traits;

  const controller_sequence&
  controller () const;

  controller_sequence&
  controller ();

  void
  controller (const controller_sequence& s);

  // junction
  //
  typedef ::t_junction junction_type;
  typedef ::xsd::cxx::tree::sequence< junction_type > junction_sequence;
  typedef junction_sequence::iterator junction_iterator;
  typedef junction_sequence::const_iterator junction_const_iterator;
  typedef ::xsd::cxx::tree::traits< junction_type, char > junction_traits;

  const junction_sequence&
  junction () const;

  junction_sequence&
  junction ();

  void
  junction (const junction_sequence& s);

  // junctionGroup
  //
  typedef ::t_junctionGroup junctionGroup_type;
  typedef ::xsd::cxx::tree::sequence< junctionGroup_type > junctionGroup_sequence;
  typedef junctionGroup_sequence::iterator junctionGroup_iterator;
  typedef junctionGroup_sequence::const_iterator junctionGroup_const_iterator;
  typedef ::xsd::cxx::tree::traits< junctionGroup_type, char > junctionGroup_traits;

  const junctionGroup_sequence&
  junctionGroup () const;

  junctionGroup_sequence&
  junctionGroup ();

  void
  junctionGroup (const junctionGroup_sequence& s);

  // station
  //
  typedef ::t_station station_type;
  typedef ::xsd::cxx::tree::sequence< station_type > station_sequence;
  typedef station_sequence::iterator station_iterator;
  typedef station_sequence::const_iterator station_const_iterator;
  typedef ::xsd::cxx::tree::traits< station_type, char > station_traits;

  const station_sequence&
  station () const;

  station_sequence&
  station ();

  void
  station (const station_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
  typedef dataQuality_sequence::iterator dataQuality_iterator;
  typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_sequence&
  dataQuality () const;

  dataQuality_sequence&
  dataQuality ();

  void
  dataQuality (const dataQuality_sequence& s);

  // Constructors.
  //
  OpenDRIVE (const header_type&);

  OpenDRIVE (::std::auto_ptr< header_type >);

  OpenDRIVE (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  OpenDRIVE (const OpenDRIVE& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual OpenDRIVE*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  OpenDRIVE&
  operator= (const OpenDRIVE& x);

  virtual 
  ~OpenDRIVE ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< header_type > header_;
  road_sequence road_;
  controller_sequence controller_;
  junction_sequence junction_;
  junctionGroup_sequence junctionGroup_;
  station_sequence station_;
  include_sequence include_;
  userData_sequence userData_;
  dataQuality_sequence dataQuality_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& uri,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& uri,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& uri,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& id,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // XSD_SCHEMA_OPENDRIVE_16_CORE_HXX
