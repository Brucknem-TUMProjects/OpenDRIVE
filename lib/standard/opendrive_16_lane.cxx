// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "opendrive_16_lane.hxx"

// e_accessRestrictionType
// 

e_accessRestrictionType::
e_accessRestrictionType (value v)
: ::xml_schema::string (_xsd_e_accessRestrictionType_literals_[v])
{
}

e_accessRestrictionType::
e_accessRestrictionType (const char* v)
: ::xml_schema::string (v)
{
}

e_accessRestrictionType::
e_accessRestrictionType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_accessRestrictionType::
e_accessRestrictionType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_accessRestrictionType::
e_accessRestrictionType (const e_accessRestrictionType& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_accessRestrictionType& e_accessRestrictionType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_accessRestrictionType_literals_[v]);

  return *this;
}


// e_laneType
// 

e_laneType::
e_laneType (value v)
: ::xml_schema::string (_xsd_e_laneType_literals_[v])
{
}

e_laneType::
e_laneType (const char* v)
: ::xml_schema::string (v)
{
}

e_laneType::
e_laneType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_laneType::
e_laneType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_laneType::
e_laneType (const e_laneType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_laneType& e_laneType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_laneType_literals_[v]);

  return *this;
}


// e_road_lanes_laneSection_lcr_lane_roadMark_laneChange
// 

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (value v)
: ::xml_schema::string (_xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_literals_[v])
{
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const char* v)
: ::xml_schema::string (v)
{
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const e_road_lanes_laneSection_lcr_lane_roadMark_laneChange& v,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange& e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_literals_[v]);

  return *this;
}


// e_road_lanes_laneSection_lr_lane_access_rule
// 

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (value v)
: ::xml_schema::string (_xsd_e_road_lanes_laneSection_lr_lane_access_rule_literals_[v])
{
}

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (const char* v)
: ::xml_schema::string (v)
{
}

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (const e_road_lanes_laneSection_lr_lane_access_rule& v,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_road_lanes_laneSection_lr_lane_access_rule& e_road_lanes_laneSection_lr_lane_access_rule::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_road_lanes_laneSection_lr_lane_access_rule_literals_[v]);

  return *this;
}


// e_roadMarkColor
// 

e_roadMarkColor::
e_roadMarkColor (value v)
: ::xml_schema::string (_xsd_e_roadMarkColor_literals_[v])
{
}

e_roadMarkColor::
e_roadMarkColor (const char* v)
: ::xml_schema::string (v)
{
}

e_roadMarkColor::
e_roadMarkColor (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkColor::
e_roadMarkColor (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkColor::
e_roadMarkColor (const e_roadMarkColor& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_roadMarkColor& e_roadMarkColor::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_roadMarkColor_literals_[v]);

  return *this;
}


// e_roadMarkRule
// 

e_roadMarkRule::
e_roadMarkRule (value v)
: ::xml_schema::string (_xsd_e_roadMarkRule_literals_[v])
{
}

e_roadMarkRule::
e_roadMarkRule (const char* v)
: ::xml_schema::string (v)
{
}

e_roadMarkRule::
e_roadMarkRule (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkRule::
e_roadMarkRule (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkRule::
e_roadMarkRule (const e_roadMarkRule& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_roadMarkRule& e_roadMarkRule::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_roadMarkRule_literals_[v]);

  return *this;
}


// e_roadMarkType
// 

e_roadMarkType::
e_roadMarkType (value v)
: ::xml_schema::string (_xsd_e_roadMarkType_literals_[v])
{
}

e_roadMarkType::
e_roadMarkType (const char* v)
: ::xml_schema::string (v)
{
}

e_roadMarkType::
e_roadMarkType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkType::
e_roadMarkType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkType::
e_roadMarkType (const e_roadMarkType& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_roadMarkType& e_roadMarkType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_roadMarkType_literals_[v]);

  return *this;
}


// e_roadMarkWeight
// 

e_roadMarkWeight::
e_roadMarkWeight (value v)
: ::xml_schema::string (_xsd_e_roadMarkWeight_literals_[v])
{
}

e_roadMarkWeight::
e_roadMarkWeight (const char* v)
: ::xml_schema::string (v)
{
}

e_roadMarkWeight::
e_roadMarkWeight (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkWeight::
e_roadMarkWeight (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkWeight::
e_roadMarkWeight (const e_roadMarkWeight& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_roadMarkWeight& e_roadMarkWeight::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_roadMarkWeight_literals_[v]);

  return *this;
}


// t_bool
// 

t_bool::
t_bool (value v)
: ::xml_schema::string (_xsd_t_bool_literals_[v])
{
}

t_bool::
t_bool (const char* v)
: ::xml_schema::string (v)
{
}

t_bool::
t_bool (const ::std::string& v)
: ::xml_schema::string (v)
{
}

t_bool::
t_bool (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

t_bool::
t_bool (const t_bool& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

t_bool& t_bool::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_t_bool_literals_[v]);

  return *this;
}


// t_road_lanes
// 

const t_road_lanes::laneOffset_sequence& t_road_lanes::
laneOffset () const
{
  return this->laneOffset_;
}

t_road_lanes::laneOffset_sequence& t_road_lanes::
laneOffset ()
{
  return this->laneOffset_;
}

void t_road_lanes::
laneOffset (const laneOffset_sequence& s)
{
  this->laneOffset_ = s;
}

const t_road_lanes::laneSection_sequence& t_road_lanes::
laneSection () const
{
  return this->laneSection_;
}

t_road_lanes::laneSection_sequence& t_road_lanes::
laneSection ()
{
  return this->laneSection_;
}

void t_road_lanes::
laneSection (const laneSection_sequence& s)
{
  this->laneSection_ = s;
}

const t_road_lanes::include_sequence& t_road_lanes::
include () const
{
  return this->include_;
}

t_road_lanes::include_sequence& t_road_lanes::
include ()
{
  return this->include_;
}

void t_road_lanes::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes::userData_sequence& t_road_lanes::
userData () const
{
  return this->userData_;
}

t_road_lanes::userData_sequence& t_road_lanes::
userData ()
{
  return this->userData_;
}

void t_road_lanes::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes::dataQuality_sequence& t_road_lanes::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes::dataQuality_sequence& t_road_lanes::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_road_lanes_laneOffset
// 

const t_road_lanes_laneOffset::s_type& t_road_lanes_laneOffset::
s () const
{
  return this->s_.get ();
}

t_road_lanes_laneOffset::s_type& t_road_lanes_laneOffset::
s ()
{
  return this->s_.get ();
}

void t_road_lanes_laneOffset::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_lanes_laneOffset::
s (::std::auto_ptr< s_type > x)
{
  this->s_.set (x);
}

const t_road_lanes_laneOffset::a_type& t_road_lanes_laneOffset::
a () const
{
  return this->a_.get ();
}

t_road_lanes_laneOffset::a_type& t_road_lanes_laneOffset::
a ()
{
  return this->a_.get ();
}

void t_road_lanes_laneOffset::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_lanes_laneOffset::b_type& t_road_lanes_laneOffset::
b () const
{
  return this->b_.get ();
}

t_road_lanes_laneOffset::b_type& t_road_lanes_laneOffset::
b ()
{
  return this->b_.get ();
}

void t_road_lanes_laneOffset::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_lanes_laneOffset::c_type& t_road_lanes_laneOffset::
c () const
{
  return this->c_.get ();
}

t_road_lanes_laneOffset::c_type& t_road_lanes_laneOffset::
c ()
{
  return this->c_.get ();
}

void t_road_lanes_laneOffset::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_lanes_laneOffset::d_type& t_road_lanes_laneOffset::
d () const
{
  return this->d_.get ();
}

t_road_lanes_laneOffset::d_type& t_road_lanes_laneOffset::
d ()
{
  return this->d_.get ();
}

void t_road_lanes_laneOffset::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_lanes_laneSection
// 

const t_road_lanes_laneSection::left_optional& t_road_lanes_laneSection::
left () const
{
  return this->left_;
}

t_road_lanes_laneSection::left_optional& t_road_lanes_laneSection::
left ()
{
  return this->left_;
}

void t_road_lanes_laneSection::
left (const left_type& x)
{
  this->left_.set (x);
}

void t_road_lanes_laneSection::
left (const left_optional& x)
{
  this->left_ = x;
}

void t_road_lanes_laneSection::
left (::std::auto_ptr< left_type > x)
{
  this->left_.set (x);
}

const t_road_lanes_laneSection::center_type& t_road_lanes_laneSection::
center () const
{
  return this->center_.get ();
}

t_road_lanes_laneSection::center_type& t_road_lanes_laneSection::
center ()
{
  return this->center_.get ();
}

void t_road_lanes_laneSection::
center (const center_type& x)
{
  this->center_.set (x);
}

void t_road_lanes_laneSection::
center (::std::auto_ptr< center_type > x)
{
  this->center_.set (x);
}

const t_road_lanes_laneSection::right_optional& t_road_lanes_laneSection::
right () const
{
  return this->right_;
}

t_road_lanes_laneSection::right_optional& t_road_lanes_laneSection::
right ()
{
  return this->right_;
}

void t_road_lanes_laneSection::
right (const right_type& x)
{
  this->right_.set (x);
}

void t_road_lanes_laneSection::
right (const right_optional& x)
{
  this->right_ = x;
}

void t_road_lanes_laneSection::
right (::std::auto_ptr< right_type > x)
{
  this->right_.set (x);
}

const t_road_lanes_laneSection::include_sequence& t_road_lanes_laneSection::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection::include_sequence& t_road_lanes_laneSection::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection::userData_sequence& t_road_lanes_laneSection::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection::userData_sequence& t_road_lanes_laneSection::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection::dataQuality_sequence& t_road_lanes_laneSection::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection::dataQuality_sequence& t_road_lanes_laneSection::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_road_lanes_laneSection::s_type& t_road_lanes_laneSection::
s () const
{
  return this->s_.get ();
}

t_road_lanes_laneSection::s_type& t_road_lanes_laneSection::
s ()
{
  return this->s_.get ();
}

void t_road_lanes_laneSection::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_lanes_laneSection::
s (::std::auto_ptr< s_type > x)
{
  this->s_.set (x);
}

const t_road_lanes_laneSection::singleSide_optional& t_road_lanes_laneSection::
singleSide () const
{
  return this->singleSide_;
}

t_road_lanes_laneSection::singleSide_optional& t_road_lanes_laneSection::
singleSide ()
{
  return this->singleSide_;
}

void t_road_lanes_laneSection::
singleSide (const singleSide_type& x)
{
  this->singleSide_.set (x);
}

void t_road_lanes_laneSection::
singleSide (const singleSide_optional& x)
{
  this->singleSide_ = x;
}

void t_road_lanes_laneSection::
singleSide (::std::auto_ptr< singleSide_type > x)
{
  this->singleSide_.set (x);
}


// t_road_lanes_laneSection_center
// 

const t_road_lanes_laneSection_center::lane_sequence& t_road_lanes_laneSection_center::
lane () const
{
  return this->lane_;
}

t_road_lanes_laneSection_center::lane_sequence& t_road_lanes_laneSection_center::
lane ()
{
  return this->lane_;
}

void t_road_lanes_laneSection_center::
lane (const lane_sequence& s)
{
  this->lane_ = s;
}

const t_road_lanes_laneSection_center::include_sequence& t_road_lanes_laneSection_center::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_center::include_sequence& t_road_lanes_laneSection_center::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_center::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_center::userData_sequence& t_road_lanes_laneSection_center::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_center::userData_sequence& t_road_lanes_laneSection_center::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_center::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_center::dataQuality_sequence& t_road_lanes_laneSection_center::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_center::dataQuality_sequence& t_road_lanes_laneSection_center::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_center::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_road_lanes_laneSection_lr_lane
// 

const t_road_lanes_laneSection_lr_lane::link_optional& t_road_lanes_laneSection_lr_lane::
link () const
{
  return this->link_;
}

t_road_lanes_laneSection_lr_lane::link_optional& t_road_lanes_laneSection_lr_lane::
link ()
{
  return this->link_;
}

void t_road_lanes_laneSection_lr_lane::
link (const link_type& x)
{
  this->link_.set (x);
}

void t_road_lanes_laneSection_lr_lane::
link (const link_optional& x)
{
  this->link_ = x;
}

void t_road_lanes_laneSection_lr_lane::
link (::std::auto_ptr< link_type > x)
{
  this->link_.set (x);
}

const t_road_lanes_laneSection_lr_lane::border_sequence& t_road_lanes_laneSection_lr_lane::
border () const
{
  return this->border_;
}

t_road_lanes_laneSection_lr_lane::border_sequence& t_road_lanes_laneSection_lr_lane::
border ()
{
  return this->border_;
}

void t_road_lanes_laneSection_lr_lane::
border (const border_sequence& s)
{
  this->border_ = s;
}

const t_road_lanes_laneSection_lr_lane::width_sequence& t_road_lanes_laneSection_lr_lane::
width () const
{
  return this->width_;
}

t_road_lanes_laneSection_lr_lane::width_sequence& t_road_lanes_laneSection_lr_lane::
width ()
{
  return this->width_;
}

void t_road_lanes_laneSection_lr_lane::
width (const width_sequence& s)
{
  this->width_ = s;
}

const t_road_lanes_laneSection_lr_lane::roadMark_sequence& t_road_lanes_laneSection_lr_lane::
roadMark () const
{
  return this->roadMark_;
}

t_road_lanes_laneSection_lr_lane::roadMark_sequence& t_road_lanes_laneSection_lr_lane::
roadMark ()
{
  return this->roadMark_;
}

void t_road_lanes_laneSection_lr_lane::
roadMark (const roadMark_sequence& s)
{
  this->roadMark_ = s;
}

const t_road_lanes_laneSection_lr_lane::material_sequence& t_road_lanes_laneSection_lr_lane::
material () const
{
  return this->material_;
}

t_road_lanes_laneSection_lr_lane::material_sequence& t_road_lanes_laneSection_lr_lane::
material ()
{
  return this->material_;
}

void t_road_lanes_laneSection_lr_lane::
material (const material_sequence& s)
{
  this->material_ = s;
}

const t_road_lanes_laneSection_lr_lane::speed_sequence& t_road_lanes_laneSection_lr_lane::
speed () const
{
  return this->speed_;
}

t_road_lanes_laneSection_lr_lane::speed_sequence& t_road_lanes_laneSection_lr_lane::
speed ()
{
  return this->speed_;
}

void t_road_lanes_laneSection_lr_lane::
speed (const speed_sequence& s)
{
  this->speed_ = s;
}

const t_road_lanes_laneSection_lr_lane::access_sequence& t_road_lanes_laneSection_lr_lane::
access () const
{
  return this->access_;
}

t_road_lanes_laneSection_lr_lane::access_sequence& t_road_lanes_laneSection_lr_lane::
access ()
{
  return this->access_;
}

void t_road_lanes_laneSection_lr_lane::
access (const access_sequence& s)
{
  this->access_ = s;
}

const t_road_lanes_laneSection_lr_lane::height_sequence& t_road_lanes_laneSection_lr_lane::
height () const
{
  return this->height_;
}

t_road_lanes_laneSection_lr_lane::height_sequence& t_road_lanes_laneSection_lr_lane::
height ()
{
  return this->height_;
}

void t_road_lanes_laneSection_lr_lane::
height (const height_sequence& s)
{
  this->height_ = s;
}

const t_road_lanes_laneSection_lr_lane::rule_sequence& t_road_lanes_laneSection_lr_lane::
rule () const
{
  return this->rule_;
}

t_road_lanes_laneSection_lr_lane::rule_sequence& t_road_lanes_laneSection_lr_lane::
rule ()
{
  return this->rule_;
}

void t_road_lanes_laneSection_lr_lane::
rule (const rule_sequence& s)
{
  this->rule_ = s;
}

const t_road_lanes_laneSection_lr_lane::include_sequence& t_road_lanes_laneSection_lr_lane::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lr_lane::include_sequence& t_road_lanes_laneSection_lr_lane::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lr_lane::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lr_lane::userData_sequence& t_road_lanes_laneSection_lr_lane::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lr_lane::userData_sequence& t_road_lanes_laneSection_lr_lane::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lr_lane::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lr_lane::dataQuality_sequence& t_road_lanes_laneSection_lr_lane::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lr_lane::dataQuality_sequence& t_road_lanes_laneSection_lr_lane::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lr_lane::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_road_lanes_laneSection_lr_lane::type_type& t_road_lanes_laneSection_lr_lane::
type () const
{
  return this->type_.get ();
}

t_road_lanes_laneSection_lr_lane::type_type& t_road_lanes_laneSection_lr_lane::
type ()
{
  return this->type_.get ();
}

void t_road_lanes_laneSection_lr_lane::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_lanes_laneSection_lr_lane::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const t_road_lanes_laneSection_lr_lane::level_optional& t_road_lanes_laneSection_lr_lane::
level () const
{
  return this->level_;
}

t_road_lanes_laneSection_lr_lane::level_optional& t_road_lanes_laneSection_lr_lane::
level ()
{
  return this->level_;
}

void t_road_lanes_laneSection_lr_lane::
level (const level_type& x)
{
  this->level_.set (x);
}

void t_road_lanes_laneSection_lr_lane::
level (const level_optional& x)
{
  this->level_ = x;
}

void t_road_lanes_laneSection_lr_lane::
level (::std::auto_ptr< level_type > x)
{
  this->level_.set (x);
}


// t_road_lanes_laneSection_center_lane
// 

const t_road_lanes_laneSection_center_lane::id_type& t_road_lanes_laneSection_center_lane::
id () const
{
  return this->id_.get ();
}

t_road_lanes_laneSection_center_lane::id_type t_road_lanes_laneSection_center_lane::
id_default_value ()
{
  return id_type (0LL);
}


// t_road_lanes_laneSection_lcr_lane_link
// 

const t_road_lanes_laneSection_lcr_lane_link::predecessor_sequence& t_road_lanes_laneSection_lcr_lane_link::
predecessor () const
{
  return this->predecessor_;
}

t_road_lanes_laneSection_lcr_lane_link::predecessor_sequence& t_road_lanes_laneSection_lcr_lane_link::
predecessor ()
{
  return this->predecessor_;
}

void t_road_lanes_laneSection_lcr_lane_link::
predecessor (const predecessor_sequence& s)
{
  this->predecessor_ = s;
}

const t_road_lanes_laneSection_lcr_lane_link::successor_sequence& t_road_lanes_laneSection_lcr_lane_link::
successor () const
{
  return this->successor_;
}

t_road_lanes_laneSection_lcr_lane_link::successor_sequence& t_road_lanes_laneSection_lcr_lane_link::
successor ()
{
  return this->successor_;
}

void t_road_lanes_laneSection_lcr_lane_link::
successor (const successor_sequence& s)
{
  this->successor_ = s;
}

const t_road_lanes_laneSection_lcr_lane_link::include_sequence& t_road_lanes_laneSection_lcr_lane_link::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lcr_lane_link::include_sequence& t_road_lanes_laneSection_lcr_lane_link::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lcr_lane_link::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lcr_lane_link::userData_sequence& t_road_lanes_laneSection_lcr_lane_link::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lcr_lane_link::userData_sequence& t_road_lanes_laneSection_lcr_lane_link::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lcr_lane_link::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lcr_lane_link::dataQuality_sequence& t_road_lanes_laneSection_lcr_lane_link::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lcr_lane_link::dataQuality_sequence& t_road_lanes_laneSection_lcr_lane_link::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lcr_lane_link::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor
// 

const t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::id_type& t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
id () const
{
  return this->id_.get ();
}

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::id_type& t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
id ()
{
  return this->id_.get ();
}

void t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
id (const id_type& x)
{
  this->id_.set (x);
}


// t_road_lanes_laneSection_lcr_lane_roadMark
// 

const t_road_lanes_laneSection_lcr_lane_roadMark::sway_sequence& t_road_lanes_laneSection_lcr_lane_roadMark::
sway () const
{
  return this->sway_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::sway_sequence& t_road_lanes_laneSection_lcr_lane_roadMark::
sway ()
{
  return this->sway_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
sway (const sway_sequence& s)
{
  this->sway_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark::type_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
type () const
{
  return this->type_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::type_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
type ()
{
  return this->type_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
type (const type_optional& x)
{
  this->type_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark::explicit_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
explicit_ () const
{
  return this->explicit__;
}

t_road_lanes_laneSection_lcr_lane_roadMark::explicit_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
explicit_ ()
{
  return this->explicit__;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
explicit_ (const explicit_type& x)
{
  this->explicit__.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
explicit_ (const explicit_optional& x)
{
  this->explicit__ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
explicit_ (::std::auto_ptr< explicit_type > x)
{
  this->explicit__.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark::dataQuality_sequence& t_road_lanes_laneSection_lcr_lane_roadMark::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::dataQuality_sequence& t_road_lanes_laneSection_lcr_lane_roadMark::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark::sOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark::sOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
sOffset (::std::auto_ptr< sOffset_type > x)
{
  this->sOffset_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark::type1_type& t_road_lanes_laneSection_lcr_lane_roadMark::
type1 () const
{
  return this->type1_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark::type1_type& t_road_lanes_laneSection_lcr_lane_roadMark::
type1 ()
{
  return this->type1_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
type1 (const type1_type& x)
{
  this->type1_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
type1 (::std::auto_ptr< type1_type > x)
{
  this->type1_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark::weight_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
weight () const
{
  return this->weight_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::weight_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
weight ()
{
  return this->weight_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
weight (const weight_type& x)
{
  this->weight_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
weight (const weight_optional& x)
{
  this->weight_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
weight (::std::auto_ptr< weight_type > x)
{
  this->weight_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark::color_type& t_road_lanes_laneSection_lcr_lane_roadMark::
color () const
{
  return this->color_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark::color_type& t_road_lanes_laneSection_lcr_lane_roadMark::
color ()
{
  return this->color_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
color (const color_type& x)
{
  this->color_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark::material_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
material () const
{
  return this->material_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::material_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
material ()
{
  return this->material_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
material (const material_type& x)
{
  this->material_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
material (const material_optional& x)
{
  this->material_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
material (::std::auto_ptr< material_type > x)
{
  this->material_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark::width_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
width () const
{
  return this->width_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::width_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
width ()
{
  return this->width_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
width (const width_type& x)
{
  this->width_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
width (const width_optional& x)
{
  this->width_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
width (::std::auto_ptr< width_type > x)
{
  this->width_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark::laneChange_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
laneChange () const
{
  return this->laneChange_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::laneChange_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
laneChange ()
{
  return this->laneChange_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
laneChange (const laneChange_type& x)
{
  this->laneChange_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
laneChange (const laneChange_optional& x)
{
  this->laneChange_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
laneChange (::std::auto_ptr< laneChange_type > x)
{
  this->laneChange_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark::height_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
height () const
{
  return this->height_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::height_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
height ()
{
  return this->height_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
height (const height_type& x)
{
  this->height_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
height (const height_optional& x)
{
  this->height_ = x;
}


// t_road_lanes_laneSection_lcr_lane_roadMark_explicit
// 

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit::line_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
line () const
{
  return this->line_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::line_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
line ()
{
  return this->line_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
line (const line_sequence& s)
{
  this->line_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit::dataQuality_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::dataQuality_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line
// 

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::length_type& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
length () const
{
  return this->length_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::length_type& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
length ()
{
  return this->length_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
length (::std::auto_ptr< length_type > x)
{
  this->length_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::tOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
tOffset () const
{
  return this->tOffset_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::tOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
tOffset ()
{
  return this->tOffset_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
tOffset (const tOffset_type& x)
{
  this->tOffset_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::sOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::sOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
sOffset (::std::auto_ptr< sOffset_type > x)
{
  this->sOffset_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::rule_optional& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
rule () const
{
  return this->rule_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::rule_optional& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
rule ()
{
  return this->rule_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
rule (const rule_type& x)
{
  this->rule_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
rule (const rule_optional& x)
{
  this->rule_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
rule (::std::auto_ptr< rule_type > x)
{
  this->rule_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::width_optional& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
width () const
{
  return this->width_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::width_optional& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
width ()
{
  return this->width_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
width (const width_type& x)
{
  this->width_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
width (const width_optional& x)
{
  this->width_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
width (::std::auto_ptr< width_type > x)
{
  this->width_.set (x);
}


// t_road_lanes_laneSection_lcr_lane_roadMark_sway
// 

const t_road_lanes_laneSection_lcr_lane_roadMark_sway::ds_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
ds () const
{
  return this->ds_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::ds_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
ds ()
{
  return this->ds_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
ds (const ds_type& x)
{
  this->ds_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
ds (::std::auto_ptr< ds_type > x)
{
  this->ds_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_sway::a_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
a () const
{
  return this->a_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::a_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
a ()
{
  return this->a_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_sway::b_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
b () const
{
  return this->b_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::b_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
b ()
{
  return this->b_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_sway::c_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
c () const
{
  return this->c_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::c_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
c ()
{
  return this->c_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_sway::d_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
d () const
{
  return this->d_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::d_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
d ()
{
  return this->d_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_lanes_laneSection_lcr_lane_roadMark_type
// 

const t_road_lanes_laneSection_lcr_lane_roadMark_type::line_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type::
line () const
{
  return this->line_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::line_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type::
line ()
{
  return this->line_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
line (const line_sequence& s)
{
  this->line_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type::dataQuality_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::dataQuality_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type::name_type& t_road_lanes_laneSection_lcr_lane_roadMark_type::
name () const
{
  return this->name_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::name_type& t_road_lanes_laneSection_lcr_lane_roadMark_type::
name ()
{
  return this->name_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type::width_type& t_road_lanes_laneSection_lcr_lane_roadMark_type::
width () const
{
  return this->width_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::width_type& t_road_lanes_laneSection_lcr_lane_roadMark_type::
width ()
{
  return this->width_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
width (const width_type& x)
{
  this->width_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
width (::std::auto_ptr< width_type > x)
{
  this->width_.set (x);
}


// t_road_lanes_laneSection_lcr_lane_roadMark_type_line
// 

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::length_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
length () const
{
  return this->length_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::length_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
length ()
{
  return this->length_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
length (::std::auto_ptr< length_type > x)
{
  this->length_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::space_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
space () const
{
  return this->space_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::space_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
space ()
{
  return this->space_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
space (const space_type& x)
{
  this->space_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
space (::std::auto_ptr< space_type > x)
{
  this->space_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::tOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
tOffset () const
{
  return this->tOffset_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::tOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
tOffset ()
{
  return this->tOffset_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
tOffset (const tOffset_type& x)
{
  this->tOffset_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::sOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::sOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
sOffset (::std::auto_ptr< sOffset_type > x)
{
  this->sOffset_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::rule_optional& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
rule () const
{
  return this->rule_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::rule_optional& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
rule ()
{
  return this->rule_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
rule (const rule_type& x)
{
  this->rule_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
rule (const rule_optional& x)
{
  this->rule_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
rule (::std::auto_ptr< rule_type > x)
{
  this->rule_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::width_optional& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
width () const
{
  return this->width_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::width_optional& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
width ()
{
  return this->width_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
width (const width_type& x)
{
  this->width_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
width (const width_optional& x)
{
  this->width_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
width (::std::auto_ptr< width_type > x)
{
  this->width_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::color_optional& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
color () const
{
  return this->color_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::color_optional& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
color ()
{
  return this->color_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
color (const color_type& x)
{
  this->color_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
color (const color_optional& x)
{
  this->color_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}


// t_road_lanes_laneSection_left
// 

const t_road_lanes_laneSection_left::lane_sequence& t_road_lanes_laneSection_left::
lane () const
{
  return this->lane_;
}

t_road_lanes_laneSection_left::lane_sequence& t_road_lanes_laneSection_left::
lane ()
{
  return this->lane_;
}

void t_road_lanes_laneSection_left::
lane (const lane_sequence& s)
{
  this->lane_ = s;
}

const t_road_lanes_laneSection_left::include_sequence& t_road_lanes_laneSection_left::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_left::include_sequence& t_road_lanes_laneSection_left::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_left::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_left::userData_sequence& t_road_lanes_laneSection_left::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_left::userData_sequence& t_road_lanes_laneSection_left::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_left::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_left::dataQuality_sequence& t_road_lanes_laneSection_left::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_left::dataQuality_sequence& t_road_lanes_laneSection_left::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_left::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_road_lanes_laneSection_left_lane
// 

const t_road_lanes_laneSection_left_lane::id_type& t_road_lanes_laneSection_left_lane::
id () const
{
  return this->id_.get ();
}

t_road_lanes_laneSection_left_lane::id_type& t_road_lanes_laneSection_left_lane::
id ()
{
  return this->id_.get ();
}

void t_road_lanes_laneSection_left_lane::
id (const id_type& x)
{
  this->id_.set (x);
}


// t_road_lanes_laneSection_lr_lane_access
// 

const t_road_lanes_laneSection_lr_lane_access::sOffset_type& t_road_lanes_laneSection_lr_lane_access::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lr_lane_access::sOffset_type& t_road_lanes_laneSection_lr_lane_access::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lr_lane_access::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lr_lane_access::
sOffset (::std::auto_ptr< sOffset_type > x)
{
  this->sOffset_.set (x);
}

const t_road_lanes_laneSection_lr_lane_access::rule_optional& t_road_lanes_laneSection_lr_lane_access::
rule () const
{
  return this->rule_;
}

t_road_lanes_laneSection_lr_lane_access::rule_optional& t_road_lanes_laneSection_lr_lane_access::
rule ()
{
  return this->rule_;
}

void t_road_lanes_laneSection_lr_lane_access::
rule (const rule_type& x)
{
  this->rule_.set (x);
}

void t_road_lanes_laneSection_lr_lane_access::
rule (const rule_optional& x)
{
  this->rule_ = x;
}

void t_road_lanes_laneSection_lr_lane_access::
rule (::std::auto_ptr< rule_type > x)
{
  this->rule_.set (x);
}

const t_road_lanes_laneSection_lr_lane_access::restriction_type& t_road_lanes_laneSection_lr_lane_access::
restriction () const
{
  return this->restriction_.get ();
}

t_road_lanes_laneSection_lr_lane_access::restriction_type& t_road_lanes_laneSection_lr_lane_access::
restriction ()
{
  return this->restriction_.get ();
}

void t_road_lanes_laneSection_lr_lane_access::
restriction (const restriction_type& x)
{
  this->restriction_.set (x);
}

void t_road_lanes_laneSection_lr_lane_access::
restriction (::std::auto_ptr< restriction_type > x)
{
  this->restriction_.set (x);
}


// t_road_lanes_laneSection_lr_lane_border
// 

const t_road_lanes_laneSection_lr_lane_border::sOffset_type& t_road_lanes_laneSection_lr_lane_border::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lr_lane_border::sOffset_type& t_road_lanes_laneSection_lr_lane_border::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lr_lane_border::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lr_lane_border::
sOffset (::std::auto_ptr< sOffset_type > x)
{
  this->sOffset_.set (x);
}

const t_road_lanes_laneSection_lr_lane_border::a_type& t_road_lanes_laneSection_lr_lane_border::
a () const
{
  return this->a_.get ();
}

t_road_lanes_laneSection_lr_lane_border::a_type& t_road_lanes_laneSection_lr_lane_border::
a ()
{
  return this->a_.get ();
}

void t_road_lanes_laneSection_lr_lane_border::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_lanes_laneSection_lr_lane_border::b_type& t_road_lanes_laneSection_lr_lane_border::
b () const
{
  return this->b_.get ();
}

t_road_lanes_laneSection_lr_lane_border::b_type& t_road_lanes_laneSection_lr_lane_border::
b ()
{
  return this->b_.get ();
}

void t_road_lanes_laneSection_lr_lane_border::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_lanes_laneSection_lr_lane_border::c_type& t_road_lanes_laneSection_lr_lane_border::
c () const
{
  return this->c_.get ();
}

t_road_lanes_laneSection_lr_lane_border::c_type& t_road_lanes_laneSection_lr_lane_border::
c ()
{
  return this->c_.get ();
}

void t_road_lanes_laneSection_lr_lane_border::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_lanes_laneSection_lr_lane_border::d_type& t_road_lanes_laneSection_lr_lane_border::
d () const
{
  return this->d_.get ();
}

t_road_lanes_laneSection_lr_lane_border::d_type& t_road_lanes_laneSection_lr_lane_border::
d ()
{
  return this->d_.get ();
}

void t_road_lanes_laneSection_lr_lane_border::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_lanes_laneSection_lr_lane_height
// 

const t_road_lanes_laneSection_lr_lane_height::sOffset_type& t_road_lanes_laneSection_lr_lane_height::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lr_lane_height::sOffset_type& t_road_lanes_laneSection_lr_lane_height::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lr_lane_height::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lr_lane_height::
sOffset (::std::auto_ptr< sOffset_type > x)
{
  this->sOffset_.set (x);
}

const t_road_lanes_laneSection_lr_lane_height::inner_type& t_road_lanes_laneSection_lr_lane_height::
inner () const
{
  return this->inner_.get ();
}

t_road_lanes_laneSection_lr_lane_height::inner_type& t_road_lanes_laneSection_lr_lane_height::
inner ()
{
  return this->inner_.get ();
}

void t_road_lanes_laneSection_lr_lane_height::
inner (const inner_type& x)
{
  this->inner_.set (x);
}

const t_road_lanes_laneSection_lr_lane_height::outer_type& t_road_lanes_laneSection_lr_lane_height::
outer () const
{
  return this->outer_.get ();
}

t_road_lanes_laneSection_lr_lane_height::outer_type& t_road_lanes_laneSection_lr_lane_height::
outer ()
{
  return this->outer_.get ();
}

void t_road_lanes_laneSection_lr_lane_height::
outer (const outer_type& x)
{
  this->outer_.set (x);
}


// t_road_lanes_laneSection_lr_lane_material
// 

const t_road_lanes_laneSection_lr_lane_material::sOffset_type& t_road_lanes_laneSection_lr_lane_material::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lr_lane_material::sOffset_type& t_road_lanes_laneSection_lr_lane_material::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lr_lane_material::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lr_lane_material::
sOffset (::std::auto_ptr< sOffset_type > x)
{
  this->sOffset_.set (x);
}

const t_road_lanes_laneSection_lr_lane_material::surface_optional& t_road_lanes_laneSection_lr_lane_material::
surface () const
{
  return this->surface_;
}

t_road_lanes_laneSection_lr_lane_material::surface_optional& t_road_lanes_laneSection_lr_lane_material::
surface ()
{
  return this->surface_;
}

void t_road_lanes_laneSection_lr_lane_material::
surface (const surface_type& x)
{
  this->surface_.set (x);
}

void t_road_lanes_laneSection_lr_lane_material::
surface (const surface_optional& x)
{
  this->surface_ = x;
}

void t_road_lanes_laneSection_lr_lane_material::
surface (::std::auto_ptr< surface_type > x)
{
  this->surface_.set (x);
}

const t_road_lanes_laneSection_lr_lane_material::friction_type& t_road_lanes_laneSection_lr_lane_material::
friction () const
{
  return this->friction_.get ();
}

t_road_lanes_laneSection_lr_lane_material::friction_type& t_road_lanes_laneSection_lr_lane_material::
friction ()
{
  return this->friction_.get ();
}

void t_road_lanes_laneSection_lr_lane_material::
friction (const friction_type& x)
{
  this->friction_.set (x);
}

void t_road_lanes_laneSection_lr_lane_material::
friction (::std::auto_ptr< friction_type > x)
{
  this->friction_.set (x);
}

const t_road_lanes_laneSection_lr_lane_material::roughness_optional& t_road_lanes_laneSection_lr_lane_material::
roughness () const
{
  return this->roughness_;
}

t_road_lanes_laneSection_lr_lane_material::roughness_optional& t_road_lanes_laneSection_lr_lane_material::
roughness ()
{
  return this->roughness_;
}

void t_road_lanes_laneSection_lr_lane_material::
roughness (const roughness_type& x)
{
  this->roughness_.set (x);
}

void t_road_lanes_laneSection_lr_lane_material::
roughness (const roughness_optional& x)
{
  this->roughness_ = x;
}

void t_road_lanes_laneSection_lr_lane_material::
roughness (::std::auto_ptr< roughness_type > x)
{
  this->roughness_.set (x);
}


// t_road_lanes_laneSection_lr_lane_rule
// 

const t_road_lanes_laneSection_lr_lane_rule::sOffset_type& t_road_lanes_laneSection_lr_lane_rule::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lr_lane_rule::sOffset_type& t_road_lanes_laneSection_lr_lane_rule::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lr_lane_rule::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lr_lane_rule::
sOffset (::std::auto_ptr< sOffset_type > x)
{
  this->sOffset_.set (x);
}

const t_road_lanes_laneSection_lr_lane_rule::value_type& t_road_lanes_laneSection_lr_lane_rule::
value () const
{
  return this->value_.get ();
}

t_road_lanes_laneSection_lr_lane_rule::value_type& t_road_lanes_laneSection_lr_lane_rule::
value ()
{
  return this->value_.get ();
}

void t_road_lanes_laneSection_lr_lane_rule::
value (const value_type& x)
{
  this->value_.set (x);
}

void t_road_lanes_laneSection_lr_lane_rule::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}


// t_road_lanes_laneSection_lr_lane_speed
// 

const t_road_lanes_laneSection_lr_lane_speed::sOffset_type& t_road_lanes_laneSection_lr_lane_speed::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lr_lane_speed::sOffset_type& t_road_lanes_laneSection_lr_lane_speed::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lr_lane_speed::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lr_lane_speed::
sOffset (::std::auto_ptr< sOffset_type > x)
{
  this->sOffset_.set (x);
}

const t_road_lanes_laneSection_lr_lane_speed::max_type& t_road_lanes_laneSection_lr_lane_speed::
max () const
{
  return this->max_.get ();
}

t_road_lanes_laneSection_lr_lane_speed::max_type& t_road_lanes_laneSection_lr_lane_speed::
max ()
{
  return this->max_.get ();
}

void t_road_lanes_laneSection_lr_lane_speed::
max (const max_type& x)
{
  this->max_.set (x);
}

void t_road_lanes_laneSection_lr_lane_speed::
max (::std::auto_ptr< max_type > x)
{
  this->max_.set (x);
}

const t_road_lanes_laneSection_lr_lane_speed::unit_optional& t_road_lanes_laneSection_lr_lane_speed::
unit () const
{
  return this->unit_;
}

t_road_lanes_laneSection_lr_lane_speed::unit_optional& t_road_lanes_laneSection_lr_lane_speed::
unit ()
{
  return this->unit_;
}

void t_road_lanes_laneSection_lr_lane_speed::
unit (const unit_type& x)
{
  this->unit_.set (x);
}

void t_road_lanes_laneSection_lr_lane_speed::
unit (const unit_optional& x)
{
  this->unit_ = x;
}

void t_road_lanes_laneSection_lr_lane_speed::
unit (::std::auto_ptr< unit_type > x)
{
  this->unit_.set (x);
}


// t_road_lanes_laneSection_lr_lane_width
// 

const t_road_lanes_laneSection_lr_lane_width::sOffset_type& t_road_lanes_laneSection_lr_lane_width::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lr_lane_width::sOffset_type& t_road_lanes_laneSection_lr_lane_width::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lr_lane_width::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lr_lane_width::
sOffset (::std::auto_ptr< sOffset_type > x)
{
  this->sOffset_.set (x);
}

const t_road_lanes_laneSection_lr_lane_width::a_type& t_road_lanes_laneSection_lr_lane_width::
a () const
{
  return this->a_.get ();
}

t_road_lanes_laneSection_lr_lane_width::a_type& t_road_lanes_laneSection_lr_lane_width::
a ()
{
  return this->a_.get ();
}

void t_road_lanes_laneSection_lr_lane_width::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_lanes_laneSection_lr_lane_width::b_type& t_road_lanes_laneSection_lr_lane_width::
b () const
{
  return this->b_.get ();
}

t_road_lanes_laneSection_lr_lane_width::b_type& t_road_lanes_laneSection_lr_lane_width::
b ()
{
  return this->b_.get ();
}

void t_road_lanes_laneSection_lr_lane_width::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_lanes_laneSection_lr_lane_width::c_type& t_road_lanes_laneSection_lr_lane_width::
c () const
{
  return this->c_.get ();
}

t_road_lanes_laneSection_lr_lane_width::c_type& t_road_lanes_laneSection_lr_lane_width::
c ()
{
  return this->c_.get ();
}

void t_road_lanes_laneSection_lr_lane_width::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_lanes_laneSection_lr_lane_width::d_type& t_road_lanes_laneSection_lr_lane_width::
d () const
{
  return this->d_.get ();
}

t_road_lanes_laneSection_lr_lane_width::d_type& t_road_lanes_laneSection_lr_lane_width::
d ()
{
  return this->d_.get ();
}

void t_road_lanes_laneSection_lr_lane_width::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_lanes_laneSection_right
// 

const t_road_lanes_laneSection_right::lane_sequence& t_road_lanes_laneSection_right::
lane () const
{
  return this->lane_;
}

t_road_lanes_laneSection_right::lane_sequence& t_road_lanes_laneSection_right::
lane ()
{
  return this->lane_;
}

void t_road_lanes_laneSection_right::
lane (const lane_sequence& s)
{
  this->lane_ = s;
}

const t_road_lanes_laneSection_right::include_sequence& t_road_lanes_laneSection_right::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_right::include_sequence& t_road_lanes_laneSection_right::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_right::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_right::userData_sequence& t_road_lanes_laneSection_right::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_right::userData_sequence& t_road_lanes_laneSection_right::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_right::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_right::dataQuality_sequence& t_road_lanes_laneSection_right::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_right::dataQuality_sequence& t_road_lanes_laneSection_right::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_right::
dataQuality (const dataQuality_sequence& s)
{
  this->dataQuality_ = s;
}


// t_road_lanes_laneSection_right_lane
// 

const t_road_lanes_laneSection_right_lane::id_type& t_road_lanes_laneSection_right_lane::
id () const
{
  return this->id_.get ();
}

t_road_lanes_laneSection_right_lane::id_type& t_road_lanes_laneSection_right_lane::
id ()
{
  return this->id_.get ();
}

void t_road_lanes_laneSection_right_lane::
id (const id_type& x)
{
  this->id_.set (x);
}


// t_road_objects_object_laneValidity
// 

const t_road_objects_object_laneValidity::fromLane_type& t_road_objects_object_laneValidity::
fromLane () const
{
  return this->fromLane_.get ();
}

t_road_objects_object_laneValidity::fromLane_type& t_road_objects_object_laneValidity::
fromLane ()
{
  return this->fromLane_.get ();
}

void t_road_objects_object_laneValidity::
fromLane (const fromLane_type& x)
{
  this->fromLane_.set (x);
}

const t_road_objects_object_laneValidity::toLane_type& t_road_objects_object_laneValidity::
toLane () const
{
  return this->toLane_.get ();
}

t_road_objects_object_laneValidity::toLane_type& t_road_objects_object_laneValidity::
toLane ()
{
  return this->toLane_.get ();
}

void t_road_objects_object_laneValidity::
toLane (const toLane_type& x)
{
  this->toLane_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// e_accessRestrictionType
//

e_accessRestrictionType::
e_accessRestrictionType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_accessRestrictionType_convert ();
}

e_accessRestrictionType::
e_accessRestrictionType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_accessRestrictionType_convert ();
}

e_accessRestrictionType::
e_accessRestrictionType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_accessRestrictionType_convert ();
}

e_accessRestrictionType* e_accessRestrictionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_accessRestrictionType (*this, f, c);
}

e_accessRestrictionType::value e_accessRestrictionType::
_xsd_e_accessRestrictionType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_accessRestrictionType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_accessRestrictionType_indexes_,
                    _xsd_e_accessRestrictionType_indexes_ + 14,
                    *this,
                    c));

  if (i == _xsd_e_accessRestrictionType_indexes_ + 14 || _xsd_e_accessRestrictionType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_accessRestrictionType::
_xsd_e_accessRestrictionType_literals_[14] =
{
  "simulator",
  "autonomousTraffic",
  "pedestrian",
  "passengerCar",
  "bus",
  "delivery",
  "emergency",
  "taxi",
  "throughTraffic",
  "truck",
  "bicycle",
  "motorcycle",
  "none",
  "trucks"
};

const e_accessRestrictionType::value e_accessRestrictionType::
_xsd_e_accessRestrictionType_indexes_[14] =
{
  ::e_accessRestrictionType::autonomousTraffic,
  ::e_accessRestrictionType::bicycle,
  ::e_accessRestrictionType::bus,
  ::e_accessRestrictionType::delivery,
  ::e_accessRestrictionType::emergency,
  ::e_accessRestrictionType::motorcycle,
  ::e_accessRestrictionType::none,
  ::e_accessRestrictionType::passengerCar,
  ::e_accessRestrictionType::pedestrian,
  ::e_accessRestrictionType::simulator,
  ::e_accessRestrictionType::taxi,
  ::e_accessRestrictionType::throughTraffic,
  ::e_accessRestrictionType::truck,
  ::e_accessRestrictionType::trucks
};

// e_laneType
//

e_laneType::
e_laneType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_laneType_convert ();
}

e_laneType::
e_laneType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_laneType_convert ();
}

e_laneType::
e_laneType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_laneType_convert ();
}

e_laneType* e_laneType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_laneType (*this, f, c);
}

e_laneType::value e_laneType::
_xsd_e_laneType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_laneType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_laneType_indexes_,
                    _xsd_e_laneType_indexes_ + 28,
                    *this,
                    c));

  if (i == _xsd_e_laneType_indexes_ + 28 || _xsd_e_laneType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_laneType::
_xsd_e_laneType_literals_[28] =
{
  "shoulder",
  "border",
  "driving",
  "stop",
  "none",
  "restricted",
  "parking",
  "median",
  "biking",
  "sidewalk",
  "curb",
  "exit",
  "entry",
  "onRamp",
  "offRamp",
  "connectingRamp",
  "bidirectional",
  "special1",
  "special2",
  "special3",
  "roadWorks",
  "tram",
  "rail",
  "bus",
  "taxi",
  "HOV",
  "mwyEntry",
  "mwyExit"
};

const e_laneType::value e_laneType::
_xsd_e_laneType_indexes_[28] =
{
  ::e_laneType::HOV,
  ::e_laneType::bidirectional,
  ::e_laneType::biking,
  ::e_laneType::border,
  ::e_laneType::bus,
  ::e_laneType::connectingRamp,
  ::e_laneType::curb,
  ::e_laneType::driving,
  ::e_laneType::entry,
  ::e_laneType::exit,
  ::e_laneType::median,
  ::e_laneType::mwyEntry,
  ::e_laneType::mwyExit,
  ::e_laneType::none,
  ::e_laneType::offRamp,
  ::e_laneType::onRamp,
  ::e_laneType::parking,
  ::e_laneType::rail,
  ::e_laneType::restricted,
  ::e_laneType::roadWorks,
  ::e_laneType::shoulder,
  ::e_laneType::sidewalk,
  ::e_laneType::special1,
  ::e_laneType::special2,
  ::e_laneType::special3,
  ::e_laneType::stop,
  ::e_laneType::taxi,
  ::e_laneType::tram
};

// e_road_lanes_laneSection_lcr_lane_roadMark_laneChange
//

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_convert ();
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const ::xercesc::DOMAttr& a,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_convert ();
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const ::std::string& s,
                                                       const ::xercesc::DOMElement* e,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_convert ();
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange* e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (*this, f, c);
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::value e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
_xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_indexes_,
                    _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_indexes_ + 4 || _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
_xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_literals_[4] =
{
  "increase",
  "decrease",
  "both",
  "none"
};

const e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::value e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
_xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_indexes_[4] =
{
  ::e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::both,
  ::e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::decrease,
  ::e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::increase,
  ::e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::none
};

// e_road_lanes_laneSection_lr_lane_access_rule
//

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_road_lanes_laneSection_lr_lane_access_rule_convert ();
}

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (const ::xercesc::DOMAttr& a,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_road_lanes_laneSection_lr_lane_access_rule_convert ();
}

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (const ::std::string& s,
                                              const ::xercesc::DOMElement* e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_road_lanes_laneSection_lr_lane_access_rule_convert ();
}

e_road_lanes_laneSection_lr_lane_access_rule* e_road_lanes_laneSection_lr_lane_access_rule::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_road_lanes_laneSection_lr_lane_access_rule (*this, f, c);
}

e_road_lanes_laneSection_lr_lane_access_rule::value e_road_lanes_laneSection_lr_lane_access_rule::
_xsd_e_road_lanes_laneSection_lr_lane_access_rule_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_lanes_laneSection_lr_lane_access_rule_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_road_lanes_laneSection_lr_lane_access_rule_indexes_,
                    _xsd_e_road_lanes_laneSection_lr_lane_access_rule_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_road_lanes_laneSection_lr_lane_access_rule_indexes_ + 2 || _xsd_e_road_lanes_laneSection_lr_lane_access_rule_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_road_lanes_laneSection_lr_lane_access_rule::
_xsd_e_road_lanes_laneSection_lr_lane_access_rule_literals_[2] =
{
  "allow",
  "deny"
};

const e_road_lanes_laneSection_lr_lane_access_rule::value e_road_lanes_laneSection_lr_lane_access_rule::
_xsd_e_road_lanes_laneSection_lr_lane_access_rule_indexes_[2] =
{
  ::e_road_lanes_laneSection_lr_lane_access_rule::allow,
  ::e_road_lanes_laneSection_lr_lane_access_rule::deny
};

// e_roadMarkColor
//

e_roadMarkColor::
e_roadMarkColor (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_roadMarkColor_convert ();
}

e_roadMarkColor::
e_roadMarkColor (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_roadMarkColor_convert ();
}

e_roadMarkColor::
e_roadMarkColor (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_roadMarkColor_convert ();
}

e_roadMarkColor* e_roadMarkColor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_roadMarkColor (*this, f, c);
}

e_roadMarkColor::value e_roadMarkColor::
_xsd_e_roadMarkColor_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_roadMarkColor_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_roadMarkColor_indexes_,
                    _xsd_e_roadMarkColor_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_e_roadMarkColor_indexes_ + 7 || _xsd_e_roadMarkColor_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_roadMarkColor::
_xsd_e_roadMarkColor_literals_[7] =
{
  "standard",
  "blue",
  "green",
  "red",
  "white",
  "yellow",
  "orange"
};

const e_roadMarkColor::value e_roadMarkColor::
_xsd_e_roadMarkColor_indexes_[7] =
{
  ::e_roadMarkColor::blue,
  ::e_roadMarkColor::green,
  ::e_roadMarkColor::orange,
  ::e_roadMarkColor::red,
  ::e_roadMarkColor::standard,
  ::e_roadMarkColor::white,
  ::e_roadMarkColor::yellow
};

// e_roadMarkRule
//

e_roadMarkRule::
e_roadMarkRule (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_roadMarkRule_convert ();
}

e_roadMarkRule::
e_roadMarkRule (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_roadMarkRule_convert ();
}

e_roadMarkRule::
e_roadMarkRule (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_roadMarkRule_convert ();
}

e_roadMarkRule* e_roadMarkRule::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_roadMarkRule (*this, f, c);
}

e_roadMarkRule::value e_roadMarkRule::
_xsd_e_roadMarkRule_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_roadMarkRule_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_roadMarkRule_indexes_,
                    _xsd_e_roadMarkRule_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_e_roadMarkRule_indexes_ + 3 || _xsd_e_roadMarkRule_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_roadMarkRule::
_xsd_e_roadMarkRule_literals_[3] =
{
  "no passing",
  "caution",
  "none"
};

const e_roadMarkRule::value e_roadMarkRule::
_xsd_e_roadMarkRule_indexes_[3] =
{
  ::e_roadMarkRule::caution,
  ::e_roadMarkRule::no_passing,
  ::e_roadMarkRule::none
};

// e_roadMarkType
//

e_roadMarkType::
e_roadMarkType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_roadMarkType_convert ();
}

e_roadMarkType::
e_roadMarkType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_roadMarkType_convert ();
}

e_roadMarkType::
e_roadMarkType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_roadMarkType_convert ();
}

e_roadMarkType* e_roadMarkType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_roadMarkType (*this, f, c);
}

e_roadMarkType::value e_roadMarkType::
_xsd_e_roadMarkType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_roadMarkType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_roadMarkType_indexes_,
                    _xsd_e_roadMarkType_indexes_ + 12,
                    *this,
                    c));

  if (i == _xsd_e_roadMarkType_indexes_ + 12 || _xsd_e_roadMarkType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_roadMarkType::
_xsd_e_roadMarkType_literals_[12] =
{
  "none",
  "solid",
  "broken",
  "solid solid",
  "solid broken",
  "broken solid",
  "broken broken",
  "botts dots",
  "grass",
  "curb",
  "custom",
  "edge"
};

const e_roadMarkType::value e_roadMarkType::
_xsd_e_roadMarkType_indexes_[12] =
{
  ::e_roadMarkType::botts_dots,
  ::e_roadMarkType::broken,
  ::e_roadMarkType::broken_broken,
  ::e_roadMarkType::broken_solid,
  ::e_roadMarkType::curb,
  ::e_roadMarkType::custom,
  ::e_roadMarkType::edge,
  ::e_roadMarkType::grass,
  ::e_roadMarkType::none,
  ::e_roadMarkType::solid,
  ::e_roadMarkType::solid_broken,
  ::e_roadMarkType::solid_solid
};

// e_roadMarkWeight
//

e_roadMarkWeight::
e_roadMarkWeight (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_roadMarkWeight_convert ();
}

e_roadMarkWeight::
e_roadMarkWeight (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_roadMarkWeight_convert ();
}

e_roadMarkWeight::
e_roadMarkWeight (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_roadMarkWeight_convert ();
}

e_roadMarkWeight* e_roadMarkWeight::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_roadMarkWeight (*this, f, c);
}

e_roadMarkWeight::value e_roadMarkWeight::
_xsd_e_roadMarkWeight_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_roadMarkWeight_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_roadMarkWeight_indexes_,
                    _xsd_e_roadMarkWeight_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_roadMarkWeight_indexes_ + 2 || _xsd_e_roadMarkWeight_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_roadMarkWeight::
_xsd_e_roadMarkWeight_literals_[2] =
{
  "standard",
  "bold"
};

const e_roadMarkWeight::value e_roadMarkWeight::
_xsd_e_roadMarkWeight_indexes_[2] =
{
  ::e_roadMarkWeight::bold,
  ::e_roadMarkWeight::standard
};

// t_bool
//

t_bool::
t_bool (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_t_bool_convert ();
}

t_bool::
t_bool (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_t_bool_convert ();
}

t_bool::
t_bool (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_t_bool_convert ();
}

t_bool* t_bool::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_bool (*this, f, c);
}

t_bool::value t_bool::
_xsd_t_bool_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_t_bool_literals_);
  const value* i (::std::lower_bound (
                    _xsd_t_bool_indexes_,
                    _xsd_t_bool_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_t_bool_indexes_ + 2 || _xsd_t_bool_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const t_bool::
_xsd_t_bool_literals_[2] =
{
  "true",
  "false"
};

const t_bool::value t_bool::
_xsd_t_bool_indexes_[2] =
{
  ::t_bool::false_,
  ::t_bool::true_
};

// t_road_lanes
//

t_road_lanes::
t_road_lanes ()
: ::_OpenDriveElement (),
  laneOffset_ (this),
  laneSection_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_road_lanes::
t_road_lanes (const t_road_lanes& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  laneOffset_ (x.laneOffset_, f, this),
  laneSection_ (x.laneSection_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_lanes::
t_road_lanes (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  laneOffset_ (this),
  laneSection_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_lanes::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // laneOffset
    //
    if (n.name () == "laneOffset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< laneOffset_type > r (
        laneOffset_traits::create (i, f, this));

      this->laneOffset_.push_back (r);
      continue;
    }

    // laneSection
    //
    if (n.name () == "laneSection" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< laneSection_type > r (
        laneSection_traits::create (i, f, this));

      this->laneSection_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_road_lanes* t_road_lanes::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes (*this, f, c);
}

t_road_lanes& t_road_lanes::
operator= (const t_road_lanes& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->laneOffset_ = x.laneOffset_;
    this->laneSection_ = x.laneSection_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_lanes::
~t_road_lanes ()
{
}

// t_road_lanes_laneOffset
//

t_road_lanes_laneOffset::
t_road_lanes_laneOffset (const s_type& s,
                         const a_type& a,
                         const b_type& b,
                         const c_type& c,
                         const d_type& d)
: ::_OpenDriveElement (),
  s_ (s, this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_lanes_laneOffset::
t_road_lanes_laneOffset (const t_road_lanes_laneOffset& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  s_ (x.s_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_lanes_laneOffset::
t_road_lanes_laneOffset (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  s_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneOffset::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_lanes_laneOffset* t_road_lanes_laneOffset::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneOffset (*this, f, c);
}

t_road_lanes_laneOffset& t_road_lanes_laneOffset::
operator= (const t_road_lanes_laneOffset& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->s_ = x.s_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_lanes_laneOffset::
~t_road_lanes_laneOffset ()
{
}

// t_road_lanes_laneSection
//

t_road_lanes_laneSection::
t_road_lanes_laneSection (const center_type& center,
                          const s_type& s)
: ::_OpenDriveElement (),
  left_ (this),
  center_ (center, this),
  right_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  s_ (s, this),
  singleSide_ (this)
{
}

t_road_lanes_laneSection::
t_road_lanes_laneSection (::std::auto_ptr< center_type > center,
                          const s_type& s)
: ::_OpenDriveElement (),
  left_ (this),
  center_ (center, this),
  right_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  s_ (s, this),
  singleSide_ (this)
{
}

t_road_lanes_laneSection::
t_road_lanes_laneSection (const t_road_lanes_laneSection& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  left_ (x.left_, f, this),
  center_ (x.center_, f, this),
  right_ (x.right_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  singleSide_ (x.singleSide_, f, this)
{
}

t_road_lanes_laneSection::
t_road_lanes_laneSection (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  left_ (this),
  center_ (this),
  right_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  s_ (this),
  singleSide_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // left
    //
    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< left_type > r (
        left_traits::create (i, f, this));

      if (!this->left_)
      {
        this->left_.set (r);
        continue;
      }
    }

    // center
    //
    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< center_type > r (
        center_traits::create (i, f, this));

      if (!center_.present ())
      {
        this->center_.set (r);
        continue;
      }
    }

    // right
    //
    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< right_type > r (
        right_traits::create (i, f, this));

      if (!this->right_)
      {
        this->right_.set (r);
        continue;
      }
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  if (!center_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "center",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "singleSide" && n.namespace_ ().empty ())
    {
      this->singleSide_.set (singleSide_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }
}

t_road_lanes_laneSection* t_road_lanes_laneSection::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection (*this, f, c);
}

t_road_lanes_laneSection& t_road_lanes_laneSection::
operator= (const t_road_lanes_laneSection& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->left_ = x.left_;
    this->center_ = x.center_;
    this->right_ = x.right_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->singleSide_ = x.singleSide_;
  }

  return *this;
}

t_road_lanes_laneSection::
~t_road_lanes_laneSection ()
{
}

// t_road_lanes_laneSection_center
//

t_road_lanes_laneSection_center::
t_road_lanes_laneSection_center ()
: ::_OpenDriveElement (),
  lane_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_road_lanes_laneSection_center::
t_road_lanes_laneSection_center (const t_road_lanes_laneSection_center& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  lane_ (x.lane_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_lanes_laneSection_center::
t_road_lanes_laneSection_center (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  lane_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_center::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // lane
    //
    if (n.name () == "lane" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lane_type > r (
        lane_traits::create (i, f, this));

      this->lane_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_road_lanes_laneSection_center* t_road_lanes_laneSection_center::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_center (*this, f, c);
}

t_road_lanes_laneSection_center& t_road_lanes_laneSection_center::
operator= (const t_road_lanes_laneSection_center& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->lane_ = x.lane_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_lanes_laneSection_center::
~t_road_lanes_laneSection_center ()
{
}

// t_road_lanes_laneSection_lr_lane
//

t_road_lanes_laneSection_lr_lane::
t_road_lanes_laneSection_lr_lane (const type_type& type)
: ::_OpenDriveElement (),
  link_ (this),
  border_ (this),
  width_ (this),
  roadMark_ (this),
  material_ (this),
  speed_ (this),
  access_ (this),
  height_ (this),
  rule_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  type_ (type, this),
  level_ (this)
{
}

t_road_lanes_laneSection_lr_lane::
t_road_lanes_laneSection_lr_lane (const t_road_lanes_laneSection_lr_lane& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  link_ (x.link_, f, this),
  border_ (x.border_, f, this),
  width_ (x.width_, f, this),
  roadMark_ (x.roadMark_, f, this),
  material_ (x.material_, f, this),
  speed_ (x.speed_, f, this),
  access_ (x.access_, f, this),
  height_ (x.height_, f, this),
  rule_ (x.rule_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  type_ (x.type_, f, this),
  level_ (x.level_, f, this)
{
}

t_road_lanes_laneSection_lr_lane::
t_road_lanes_laneSection_lr_lane (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  link_ (this),
  border_ (this),
  width_ (this),
  roadMark_ (this),
  material_ (this),
  speed_ (this),
  access_ (this),
  height_ (this),
  rule_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  type_ (this),
  level_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // link
    //
    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< link_type > r (
        link_traits::create (i, f, this));

      if (!this->link_)
      {
        this->link_.set (r);
        continue;
      }
    }

    // border
    //
    if (n.name () == "border" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< border_type > r (
        border_traits::create (i, f, this));

      this->border_.push_back (r);
      continue;
    }

    // width
    //
    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< width_type > r (
        width_traits::create (i, f, this));

      this->width_.push_back (r);
      continue;
    }

    // roadMark
    //
    if (n.name () == "roadMark" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< roadMark_type > r (
        roadMark_traits::create (i, f, this));

      this->roadMark_.push_back (r);
      continue;
    }

    // material
    //
    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< material_type > r (
        material_traits::create (i, f, this));

      this->material_.push_back (r);
      continue;
    }

    // speed
    //
    if (n.name () == "speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< speed_type > r (
        speed_traits::create (i, f, this));

      this->speed_.push_back (r);
      continue;
    }

    // access
    //
    if (n.name () == "access" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< access_type > r (
        access_traits::create (i, f, this));

      this->access_.push_back (r);
      continue;
    }

    // height
    //
    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< height_type > r (
        height_traits::create (i, f, this));

      this->height_.push_back (r);
      continue;
    }

    // rule
    //
    if (n.name () == "rule" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rule_type > r (
        rule_traits::create (i, f, this));

      this->rule_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "level" && n.namespace_ ().empty ())
    {
      this->level_.set (level_traits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

t_road_lanes_laneSection_lr_lane* t_road_lanes_laneSection_lr_lane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane (*this, f, c);
}

t_road_lanes_laneSection_lr_lane& t_road_lanes_laneSection_lr_lane::
operator= (const t_road_lanes_laneSection_lr_lane& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->link_ = x.link_;
    this->border_ = x.border_;
    this->width_ = x.width_;
    this->roadMark_ = x.roadMark_;
    this->material_ = x.material_;
    this->speed_ = x.speed_;
    this->access_ = x.access_;
    this->height_ = x.height_;
    this->rule_ = x.rule_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->type_ = x.type_;
    this->level_ = x.level_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane::
~t_road_lanes_laneSection_lr_lane ()
{
}

// t_road_lanes_laneSection_center_lane
//

t_road_lanes_laneSection_center_lane::
t_road_lanes_laneSection_center_lane (const type_type& type)
: ::t_road_lanes_laneSection_lr_lane (type),
  id_ (id_default_value (), this)
{
}

t_road_lanes_laneSection_center_lane::
t_road_lanes_laneSection_center_lane (const t_road_lanes_laneSection_center_lane& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::t_road_lanes_laneSection_lr_lane (x, f, c),
  id_ (x.id_, f, this)
{
}

t_road_lanes_laneSection_center_lane::
t_road_lanes_laneSection_center_lane (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::t_road_lanes_laneSection_lr_lane (e, f | ::xml_schema::flags::base, c),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_center_lane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::t_road_lanes_laneSection_lr_lane::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    this->id_.set (id_default_value ());
  }
}

t_road_lanes_laneSection_center_lane* t_road_lanes_laneSection_center_lane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_center_lane (*this, f, c);
}

t_road_lanes_laneSection_center_lane& t_road_lanes_laneSection_center_lane::
operator= (const t_road_lanes_laneSection_center_lane& x)
{
  if (this != &x)
  {
    static_cast< ::t_road_lanes_laneSection_lr_lane& > (*this) = x;
    this->id_ = x.id_;
  }

  return *this;
}

t_road_lanes_laneSection_center_lane::
~t_road_lanes_laneSection_center_lane ()
{
}

// t_road_lanes_laneSection_lcr_lane_link
//

t_road_lanes_laneSection_lcr_lane_link::
t_road_lanes_laneSection_lcr_lane_link ()
: ::_OpenDriveElement (),
  predecessor_ (this),
  successor_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_road_lanes_laneSection_lcr_lane_link::
t_road_lanes_laneSection_lcr_lane_link (const t_road_lanes_laneSection_lcr_lane_link& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  predecessor_ (x.predecessor_, f, this),
  successor_ (x.successor_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_link::
t_road_lanes_laneSection_lcr_lane_link (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  predecessor_ (this),
  successor_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_link::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // predecessor
    //
    if (n.name () == "predecessor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< predecessor_type > r (
        predecessor_traits::create (i, f, this));

      this->predecessor_.push_back (r);
      continue;
    }

    // successor
    //
    if (n.name () == "successor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< successor_type > r (
        successor_traits::create (i, f, this));

      this->successor_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_road_lanes_laneSection_lcr_lane_link* t_road_lanes_laneSection_lcr_lane_link::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_link (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_link& t_road_lanes_laneSection_lcr_lane_link::
operator= (const t_road_lanes_laneSection_lcr_lane_link& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->predecessor_ = x.predecessor_;
    this->successor_ = x.successor_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_link::
~t_road_lanes_laneSection_lcr_lane_link ()
{
}

// t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor
//

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor (const id_type& id)
: ::_OpenDriveElement (),
  id_ (id, this)
{
}

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor (const t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor& x,
                                                             ::xml_schema::flags f,
                                                             ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  id_ (x.id_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor (const ::xercesc::DOMElement& e,
                                                             ::xml_schema::flags f,
                                                             ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor* t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor& t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
operator= (const t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->id_ = x.id_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
~t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor ()
{
}

// t_road_lanes_laneSection_lcr_lane_roadMark
//

t_road_lanes_laneSection_lcr_lane_roadMark::
t_road_lanes_laneSection_lcr_lane_roadMark (const sOffset_type& sOffset,
                                            const type1_type& type1,
                                            const color_type& color)
: ::_OpenDriveElement (),
  sway_ (this),
  type_ (this),
  explicit__ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  sOffset_ (sOffset, this),
  type1_ (type1, this),
  weight_ (this),
  color_ (color, this),
  material_ (this),
  width_ (this),
  laneChange_ (this),
  height_ (this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark::
t_road_lanes_laneSection_lcr_lane_roadMark (const t_road_lanes_laneSection_lcr_lane_roadMark& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  sway_ (x.sway_, f, this),
  type_ (x.type_, f, this),
  explicit__ (x.explicit__, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  sOffset_ (x.sOffset_, f, this),
  type1_ (x.type1_, f, this),
  weight_ (x.weight_, f, this),
  color_ (x.color_, f, this),
  material_ (x.material_, f, this),
  width_ (x.width_, f, this),
  laneChange_ (x.laneChange_, f, this),
  height_ (x.height_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark::
t_road_lanes_laneSection_lcr_lane_roadMark (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  sway_ (this),
  type_ (this),
  explicit__ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  sOffset_ (this),
  type1_ (this),
  weight_ (this),
  color_ (this),
  material_ (this),
  width_ (this),
  laneChange_ (this),
  height_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // sway
    //
    if (n.name () == "sway" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< sway_type > r (
        sway_traits::create (i, f, this));

      this->sway_.push_back (r);
      continue;
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!this->type_)
      {
        this->type_.set (r);
        continue;
      }
    }

    // explicit
    //
    if (n.name () == "explicit" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< explicit_type > r (
        explicit_traits::create (i, f, this));

      if (!this->explicit__)
      {
        this->explicit__.set (r);
        continue;
      }
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type1_.set (type1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "weight" && n.namespace_ ().empty ())
    {
      this->weight_.set (weight_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      this->color_.set (color_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      this->material_.set (material_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "laneChange" && n.namespace_ ().empty ())
    {
      this->laneChange_.set (laneChange_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!type1_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!color_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "color",
      "");
  }
}

t_road_lanes_laneSection_lcr_lane_roadMark* t_road_lanes_laneSection_lcr_lane_roadMark::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_roadMark (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_roadMark& t_road_lanes_laneSection_lcr_lane_roadMark::
operator= (const t_road_lanes_laneSection_lcr_lane_roadMark& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->sway_ = x.sway_;
    this->type_ = x.type_;
    this->explicit__ = x.explicit__;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->sOffset_ = x.sOffset_;
    this->type1_ = x.type1_;
    this->weight_ = x.weight_;
    this->color_ = x.color_;
    this->material_ = x.material_;
    this->width_ = x.width_;
    this->laneChange_ = x.laneChange_;
    this->height_ = x.height_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_roadMark::
~t_road_lanes_laneSection_lcr_lane_roadMark ()
{
}

// t_road_lanes_laneSection_lcr_lane_roadMark_explicit
//

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
t_road_lanes_laneSection_lcr_lane_roadMark_explicit ()
: ::_OpenDriveElement (),
  line_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
t_road_lanes_laneSection_lcr_lane_roadMark_explicit (const t_road_lanes_laneSection_lcr_lane_roadMark_explicit& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  line_ (x.line_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
t_road_lanes_laneSection_lcr_lane_roadMark_explicit (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  line_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // line
    //
    if (n.name () == "line" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< line_type > r (
        line_traits::create (i, f, this));

      this->line_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit* t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_roadMark_explicit (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
operator= (const t_road_lanes_laneSection_lcr_lane_roadMark_explicit& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->line_ = x.line_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
~t_road_lanes_laneSection_lcr_lane_roadMark_explicit ()
{
}

// t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line
//

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line (const length_type& length,
                                                          const tOffset_type& tOffset,
                                                          const sOffset_type& sOffset)
: ::_OpenDriveElement (),
  length_ (length, this),
  tOffset_ (tOffset, this),
  sOffset_ (sOffset, this),
  rule_ (this),
  width_ (this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line (const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line& x,
                                                          ::xml_schema::flags f,
                                                          ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  length_ (x.length_, f, this),
  tOffset_ (x.tOffset_, f, this),
  sOffset_ (x.sOffset_, f, this),
  rule_ (x.rule_, f, this),
  width_ (x.width_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::flags f,
                                                          ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  length_ (this),
  tOffset_ (this),
  sOffset_ (this),
  rule_ (this),
  width_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "tOffset" && n.namespace_ ().empty ())
    {
      this->tOffset_.set (tOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rule" && n.namespace_ ().empty ())
    {
      this->rule_.set (rule_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }

  if (!tOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "tOffset",
      "");
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line* t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
operator= (const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->length_ = x.length_;
    this->tOffset_ = x.tOffset_;
    this->sOffset_ = x.sOffset_;
    this->rule_ = x.rule_;
    this->width_ = x.width_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
~t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line ()
{
}

// t_road_lanes_laneSection_lcr_lane_roadMark_sway
//

t_road_lanes_laneSection_lcr_lane_roadMark_sway::
t_road_lanes_laneSection_lcr_lane_roadMark_sway (const ds_type& ds,
                                                 const a_type& a,
                                                 const b_type& b,
                                                 const c_type& c,
                                                 const d_type& d)
: ::_OpenDriveElement (),
  ds_ (ds, this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::
t_road_lanes_laneSection_lcr_lane_roadMark_sway (const t_road_lanes_laneSection_lcr_lane_roadMark_sway& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  ds_ (x.ds_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::
t_road_lanes_laneSection_lcr_lane_roadMark_sway (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  ds_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ds" && n.namespace_ ().empty ())
    {
      this->ds_.set (ds_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!ds_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "ds",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway* t_road_lanes_laneSection_lcr_lane_roadMark_sway::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_roadMark_sway (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
operator= (const t_road_lanes_laneSection_lcr_lane_roadMark_sway& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->ds_ = x.ds_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::
~t_road_lanes_laneSection_lcr_lane_roadMark_sway ()
{
}

// t_road_lanes_laneSection_lcr_lane_roadMark_type
//

t_road_lanes_laneSection_lcr_lane_roadMark_type::
t_road_lanes_laneSection_lcr_lane_roadMark_type (const name_type& name,
                                                 const width_type& width)
: ::_OpenDriveElement (),
  line_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  name_ (name, this),
  width_ (width, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::
t_road_lanes_laneSection_lcr_lane_roadMark_type (const t_road_lanes_laneSection_lcr_lane_roadMark_type& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  line_ (x.line_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  name_ (x.name_, f, this),
  width_ (x.width_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::
t_road_lanes_laneSection_lcr_lane_roadMark_type (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  line_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this),
  name_ (this),
  width_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // line
    //
    if (n.name () == "line" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< line_type > r (
        line_traits::create (i, f, this));

      this->line_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!width_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "width",
      "");
  }
}

t_road_lanes_laneSection_lcr_lane_roadMark_type* t_road_lanes_laneSection_lcr_lane_roadMark_type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_roadMark_type (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_roadMark_type& t_road_lanes_laneSection_lcr_lane_roadMark_type::
operator= (const t_road_lanes_laneSection_lcr_lane_roadMark_type& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->line_ = x.line_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
    this->name_ = x.name_;
    this->width_ = x.width_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::
~t_road_lanes_laneSection_lcr_lane_roadMark_type ()
{
}

// t_road_lanes_laneSection_lcr_lane_roadMark_type_line
//

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
t_road_lanes_laneSection_lcr_lane_roadMark_type_line (const length_type& length,
                                                      const space_type& space,
                                                      const tOffset_type& tOffset,
                                                      const sOffset_type& sOffset)
: ::_OpenDriveElement (),
  length_ (length, this),
  space_ (space, this),
  tOffset_ (tOffset, this),
  sOffset_ (sOffset, this),
  rule_ (this),
  width_ (this),
  color_ (this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
t_road_lanes_laneSection_lcr_lane_roadMark_type_line (const t_road_lanes_laneSection_lcr_lane_roadMark_type_line& x,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  length_ (x.length_, f, this),
  space_ (x.space_, f, this),
  tOffset_ (x.tOffset_, f, this),
  sOffset_ (x.sOffset_, f, this),
  rule_ (x.rule_, f, this),
  width_ (x.width_, f, this),
  color_ (x.color_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
t_road_lanes_laneSection_lcr_lane_roadMark_type_line (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  length_ (this),
  space_ (this),
  tOffset_ (this),
  sOffset_ (this),
  rule_ (this),
  width_ (this),
  color_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "space" && n.namespace_ ().empty ())
    {
      this->space_.set (space_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "tOffset" && n.namespace_ ().empty ())
    {
      this->tOffset_.set (tOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rule" && n.namespace_ ().empty ())
    {
      this->rule_.set (rule_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      this->color_.set (color_traits::create (i, f, this));
      continue;
    }
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }

  if (!space_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "space",
      "");
  }

  if (!tOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "tOffset",
      "");
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line* t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_roadMark_type_line (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
operator= (const t_road_lanes_laneSection_lcr_lane_roadMark_type_line& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->length_ = x.length_;
    this->space_ = x.space_;
    this->tOffset_ = x.tOffset_;
    this->sOffset_ = x.sOffset_;
    this->rule_ = x.rule_;
    this->width_ = x.width_;
    this->color_ = x.color_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
~t_road_lanes_laneSection_lcr_lane_roadMark_type_line ()
{
}

// t_road_lanes_laneSection_left
//

t_road_lanes_laneSection_left::
t_road_lanes_laneSection_left ()
: ::_OpenDriveElement (),
  lane_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_road_lanes_laneSection_left::
t_road_lanes_laneSection_left (const t_road_lanes_laneSection_left& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  lane_ (x.lane_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_lanes_laneSection_left::
t_road_lanes_laneSection_left (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  lane_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_left::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // lane
    //
    if (n.name () == "lane" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lane_type > r (
        lane_traits::create (i, f, this));

      this->lane_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_road_lanes_laneSection_left* t_road_lanes_laneSection_left::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_left (*this, f, c);
}

t_road_lanes_laneSection_left& t_road_lanes_laneSection_left::
operator= (const t_road_lanes_laneSection_left& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->lane_ = x.lane_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_lanes_laneSection_left::
~t_road_lanes_laneSection_left ()
{
}

// t_road_lanes_laneSection_left_lane
//

t_road_lanes_laneSection_left_lane::
t_road_lanes_laneSection_left_lane (const type_type& type,
                                    const id_type& id)
: ::t_road_lanes_laneSection_lr_lane (type),
  id_ (id, this)
{
}

t_road_lanes_laneSection_left_lane::
t_road_lanes_laneSection_left_lane (const t_road_lanes_laneSection_left_lane& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::t_road_lanes_laneSection_lr_lane (x, f, c),
  id_ (x.id_, f, this)
{
}

t_road_lanes_laneSection_left_lane::
t_road_lanes_laneSection_left_lane (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::t_road_lanes_laneSection_lr_lane (e, f | ::xml_schema::flags::base, c),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_left_lane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::t_road_lanes_laneSection_lr_lane::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_road_lanes_laneSection_left_lane* t_road_lanes_laneSection_left_lane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_left_lane (*this, f, c);
}

t_road_lanes_laneSection_left_lane& t_road_lanes_laneSection_left_lane::
operator= (const t_road_lanes_laneSection_left_lane& x)
{
  if (this != &x)
  {
    static_cast< ::t_road_lanes_laneSection_lr_lane& > (*this) = x;
    this->id_ = x.id_;
  }

  return *this;
}

t_road_lanes_laneSection_left_lane::
~t_road_lanes_laneSection_left_lane ()
{
}

// t_road_lanes_laneSection_lr_lane_access
//

t_road_lanes_laneSection_lr_lane_access::
t_road_lanes_laneSection_lr_lane_access (const sOffset_type& sOffset,
                                         const restriction_type& restriction)
: ::_OpenDriveElement (),
  sOffset_ (sOffset, this),
  rule_ (this),
  restriction_ (restriction, this)
{
}

t_road_lanes_laneSection_lr_lane_access::
t_road_lanes_laneSection_lr_lane_access (const t_road_lanes_laneSection_lr_lane_access& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  sOffset_ (x.sOffset_, f, this),
  rule_ (x.rule_, f, this),
  restriction_ (x.restriction_, f, this)
{
}

t_road_lanes_laneSection_lr_lane_access::
t_road_lanes_laneSection_lr_lane_access (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  sOffset_ (this),
  rule_ (this),
  restriction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane_access::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rule" && n.namespace_ ().empty ())
    {
      this->rule_.set (rule_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "restriction" && n.namespace_ ().empty ())
    {
      this->restriction_.set (restriction_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!restriction_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "restriction",
      "");
  }
}

t_road_lanes_laneSection_lr_lane_access* t_road_lanes_laneSection_lr_lane_access::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane_access (*this, f, c);
}

t_road_lanes_laneSection_lr_lane_access& t_road_lanes_laneSection_lr_lane_access::
operator= (const t_road_lanes_laneSection_lr_lane_access& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->sOffset_ = x.sOffset_;
    this->rule_ = x.rule_;
    this->restriction_ = x.restriction_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane_access::
~t_road_lanes_laneSection_lr_lane_access ()
{
}

// t_road_lanes_laneSection_lr_lane_border
//

t_road_lanes_laneSection_lr_lane_border::
t_road_lanes_laneSection_lr_lane_border (const sOffset_type& sOffset,
                                         const a_type& a,
                                         const b_type& b,
                                         const c_type& c,
                                         const d_type& d)
: ::_OpenDriveElement (),
  sOffset_ (sOffset, this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_lanes_laneSection_lr_lane_border::
t_road_lanes_laneSection_lr_lane_border (const t_road_lanes_laneSection_lr_lane_border& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  sOffset_ (x.sOffset_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_lanes_laneSection_lr_lane_border::
t_road_lanes_laneSection_lr_lane_border (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  sOffset_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane_border::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_lanes_laneSection_lr_lane_border* t_road_lanes_laneSection_lr_lane_border::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane_border (*this, f, c);
}

t_road_lanes_laneSection_lr_lane_border& t_road_lanes_laneSection_lr_lane_border::
operator= (const t_road_lanes_laneSection_lr_lane_border& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->sOffset_ = x.sOffset_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane_border::
~t_road_lanes_laneSection_lr_lane_border ()
{
}

// t_road_lanes_laneSection_lr_lane_height
//

t_road_lanes_laneSection_lr_lane_height::
t_road_lanes_laneSection_lr_lane_height (const sOffset_type& sOffset,
                                         const inner_type& inner,
                                         const outer_type& outer)
: ::_OpenDriveElement (),
  sOffset_ (sOffset, this),
  inner_ (inner, this),
  outer_ (outer, this)
{
}

t_road_lanes_laneSection_lr_lane_height::
t_road_lanes_laneSection_lr_lane_height (const t_road_lanes_laneSection_lr_lane_height& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  sOffset_ (x.sOffset_, f, this),
  inner_ (x.inner_, f, this),
  outer_ (x.outer_, f, this)
{
}

t_road_lanes_laneSection_lr_lane_height::
t_road_lanes_laneSection_lr_lane_height (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  sOffset_ (this),
  inner_ (this),
  outer_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane_height::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "inner" && n.namespace_ ().empty ())
    {
      this->inner_.set (inner_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "outer" && n.namespace_ ().empty ())
    {
      this->outer_.set (outer_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!inner_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "inner",
      "");
  }

  if (!outer_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "outer",
      "");
  }
}

t_road_lanes_laneSection_lr_lane_height* t_road_lanes_laneSection_lr_lane_height::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane_height (*this, f, c);
}

t_road_lanes_laneSection_lr_lane_height& t_road_lanes_laneSection_lr_lane_height::
operator= (const t_road_lanes_laneSection_lr_lane_height& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->sOffset_ = x.sOffset_;
    this->inner_ = x.inner_;
    this->outer_ = x.outer_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane_height::
~t_road_lanes_laneSection_lr_lane_height ()
{
}

// t_road_lanes_laneSection_lr_lane_material
//

t_road_lanes_laneSection_lr_lane_material::
t_road_lanes_laneSection_lr_lane_material (const sOffset_type& sOffset,
                                           const friction_type& friction)
: ::_OpenDriveElement (),
  sOffset_ (sOffset, this),
  surface_ (this),
  friction_ (friction, this),
  roughness_ (this)
{
}

t_road_lanes_laneSection_lr_lane_material::
t_road_lanes_laneSection_lr_lane_material (const t_road_lanes_laneSection_lr_lane_material& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  sOffset_ (x.sOffset_, f, this),
  surface_ (x.surface_, f, this),
  friction_ (x.friction_, f, this),
  roughness_ (x.roughness_, f, this)
{
}

t_road_lanes_laneSection_lr_lane_material::
t_road_lanes_laneSection_lr_lane_material (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  sOffset_ (this),
  surface_ (this),
  friction_ (this),
  roughness_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane_material::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "surface" && n.namespace_ ().empty ())
    {
      this->surface_.set (surface_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "friction" && n.namespace_ ().empty ())
    {
      this->friction_.set (friction_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "roughness" && n.namespace_ ().empty ())
    {
      this->roughness_.set (roughness_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!friction_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "friction",
      "");
  }
}

t_road_lanes_laneSection_lr_lane_material* t_road_lanes_laneSection_lr_lane_material::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane_material (*this, f, c);
}

t_road_lanes_laneSection_lr_lane_material& t_road_lanes_laneSection_lr_lane_material::
operator= (const t_road_lanes_laneSection_lr_lane_material& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->sOffset_ = x.sOffset_;
    this->surface_ = x.surface_;
    this->friction_ = x.friction_;
    this->roughness_ = x.roughness_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane_material::
~t_road_lanes_laneSection_lr_lane_material ()
{
}

// t_road_lanes_laneSection_lr_lane_rule
//

t_road_lanes_laneSection_lr_lane_rule::
t_road_lanes_laneSection_lr_lane_rule (const sOffset_type& sOffset,
                                       const value_type& value)
: ::_OpenDriveElement (),
  sOffset_ (sOffset, this),
  value_ (value, this)
{
}

t_road_lanes_laneSection_lr_lane_rule::
t_road_lanes_laneSection_lr_lane_rule (const t_road_lanes_laneSection_lr_lane_rule& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  sOffset_ (x.sOffset_, f, this),
  value_ (x.value_, f, this)
{
}

t_road_lanes_laneSection_lr_lane_rule::
t_road_lanes_laneSection_lr_lane_rule (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  sOffset_ (this),
  value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane_rule::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (value_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "value",
      "");
  }
}

t_road_lanes_laneSection_lr_lane_rule* t_road_lanes_laneSection_lr_lane_rule::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane_rule (*this, f, c);
}

t_road_lanes_laneSection_lr_lane_rule& t_road_lanes_laneSection_lr_lane_rule::
operator= (const t_road_lanes_laneSection_lr_lane_rule& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->sOffset_ = x.sOffset_;
    this->value_ = x.value_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane_rule::
~t_road_lanes_laneSection_lr_lane_rule ()
{
}

// t_road_lanes_laneSection_lr_lane_speed
//

t_road_lanes_laneSection_lr_lane_speed::
t_road_lanes_laneSection_lr_lane_speed (const sOffset_type& sOffset,
                                        const max_type& max)
: ::_OpenDriveElement (),
  sOffset_ (sOffset, this),
  max_ (max, this),
  unit_ (this)
{
}

t_road_lanes_laneSection_lr_lane_speed::
t_road_lanes_laneSection_lr_lane_speed (const t_road_lanes_laneSection_lr_lane_speed& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  sOffset_ (x.sOffset_, f, this),
  max_ (x.max_, f, this),
  unit_ (x.unit_, f, this)
{
}

t_road_lanes_laneSection_lr_lane_speed::
t_road_lanes_laneSection_lr_lane_speed (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  sOffset_ (this),
  max_ (this),
  unit_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane_speed::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "max" && n.namespace_ ().empty ())
    {
      this->max_.set (max_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "unit" && n.namespace_ ().empty ())
    {
      this->unit_.set (unit_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!max_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "max",
      "");
  }
}

t_road_lanes_laneSection_lr_lane_speed* t_road_lanes_laneSection_lr_lane_speed::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane_speed (*this, f, c);
}

t_road_lanes_laneSection_lr_lane_speed& t_road_lanes_laneSection_lr_lane_speed::
operator= (const t_road_lanes_laneSection_lr_lane_speed& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->sOffset_ = x.sOffset_;
    this->max_ = x.max_;
    this->unit_ = x.unit_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane_speed::
~t_road_lanes_laneSection_lr_lane_speed ()
{
}

// t_road_lanes_laneSection_lr_lane_width
//

t_road_lanes_laneSection_lr_lane_width::
t_road_lanes_laneSection_lr_lane_width (const sOffset_type& sOffset,
                                        const a_type& a,
                                        const b_type& b,
                                        const c_type& c,
                                        const d_type& d)
: ::_OpenDriveElement (),
  sOffset_ (sOffset, this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_lanes_laneSection_lr_lane_width::
t_road_lanes_laneSection_lr_lane_width (const t_road_lanes_laneSection_lr_lane_width& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  sOffset_ (x.sOffset_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_lanes_laneSection_lr_lane_width::
t_road_lanes_laneSection_lr_lane_width (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  sOffset_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane_width::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_lanes_laneSection_lr_lane_width* t_road_lanes_laneSection_lr_lane_width::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane_width (*this, f, c);
}

t_road_lanes_laneSection_lr_lane_width& t_road_lanes_laneSection_lr_lane_width::
operator= (const t_road_lanes_laneSection_lr_lane_width& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->sOffset_ = x.sOffset_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane_width::
~t_road_lanes_laneSection_lr_lane_width ()
{
}

// t_road_lanes_laneSection_right
//

t_road_lanes_laneSection_right::
t_road_lanes_laneSection_right ()
: ::_OpenDriveElement (),
  lane_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
}

t_road_lanes_laneSection_right::
t_road_lanes_laneSection_right (const t_road_lanes_laneSection_right& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  lane_ (x.lane_, f, this),
  include_ (x.include_, f, this),
  userData_ (x.userData_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_lanes_laneSection_right::
t_road_lanes_laneSection_right (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  lane_ (this),
  include_ (this),
  userData_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_right::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // lane
    //
    if (n.name () == "lane" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lane_type > r (
        lane_traits::create (i, f, this));

      this->lane_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      this->dataQuality_.push_back (r);
      continue;
    }

    break;
  }
}

t_road_lanes_laneSection_right* t_road_lanes_laneSection_right::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_right (*this, f, c);
}

t_road_lanes_laneSection_right& t_road_lanes_laneSection_right::
operator= (const t_road_lanes_laneSection_right& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->lane_ = x.lane_;
    this->include_ = x.include_;
    this->userData_ = x.userData_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_lanes_laneSection_right::
~t_road_lanes_laneSection_right ()
{
}

// t_road_lanes_laneSection_right_lane
//

t_road_lanes_laneSection_right_lane::
t_road_lanes_laneSection_right_lane (const type_type& type,
                                     const id_type& id)
: ::t_road_lanes_laneSection_lr_lane (type),
  id_ (id, this)
{
}

t_road_lanes_laneSection_right_lane::
t_road_lanes_laneSection_right_lane (const t_road_lanes_laneSection_right_lane& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::t_road_lanes_laneSection_lr_lane (x, f, c),
  id_ (x.id_, f, this)
{
}

t_road_lanes_laneSection_right_lane::
t_road_lanes_laneSection_right_lane (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::t_road_lanes_laneSection_lr_lane (e, f | ::xml_schema::flags::base, c),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_right_lane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::t_road_lanes_laneSection_lr_lane::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_road_lanes_laneSection_right_lane* t_road_lanes_laneSection_right_lane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_right_lane (*this, f, c);
}

t_road_lanes_laneSection_right_lane& t_road_lanes_laneSection_right_lane::
operator= (const t_road_lanes_laneSection_right_lane& x)
{
  if (this != &x)
  {
    static_cast< ::t_road_lanes_laneSection_lr_lane& > (*this) = x;
    this->id_ = x.id_;
  }

  return *this;
}

t_road_lanes_laneSection_right_lane::
~t_road_lanes_laneSection_right_lane ()
{
}

// t_road_objects_object_laneValidity
//

t_road_objects_object_laneValidity::
t_road_objects_object_laneValidity (const fromLane_type& fromLane,
                                    const toLane_type& toLane)
: ::_OpenDriveElement (),
  fromLane_ (fromLane, this),
  toLane_ (toLane, this)
{
}

t_road_objects_object_laneValidity::
t_road_objects_object_laneValidity (const t_road_objects_object_laneValidity& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::_OpenDriveElement (x, f, c),
  fromLane_ (x.fromLane_, f, this),
  toLane_ (x.toLane_, f, this)
{
}

t_road_objects_object_laneValidity::
t_road_objects_object_laneValidity (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::_OpenDriveElement (e, f | ::xml_schema::flags::base, c),
  fromLane_ (this),
  toLane_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_laneValidity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "fromLane" && n.namespace_ ().empty ())
    {
      this->fromLane_.set (fromLane_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "toLane" && n.namespace_ ().empty ())
    {
      this->toLane_.set (toLane_traits::create (i, f, this));
      continue;
    }
  }

  if (!fromLane_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "fromLane",
      "");
  }

  if (!toLane_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "toLane",
      "");
  }
}

t_road_objects_object_laneValidity* t_road_objects_object_laneValidity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_laneValidity (*this, f, c);
}

t_road_objects_object_laneValidity& t_road_objects_object_laneValidity::
operator= (const t_road_objects_object_laneValidity& x)
{
  if (this != &x)
  {
    static_cast< ::_OpenDriveElement& > (*this) = x;
    this->fromLane_ = x.fromLane_;
    this->toLane_ = x.toLane_;
  }

  return *this;
}

t_road_objects_object_laneValidity::
~t_road_objects_object_laneValidity ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

