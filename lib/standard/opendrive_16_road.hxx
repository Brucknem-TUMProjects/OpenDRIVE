// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef XSD_SCHEMA_OPENDRIVE_16_ROAD_HXX
#define XSD_SCHEMA_OPENDRIVE_16_ROAD_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class e_countryCode;
class e_countryCode_deprecated;
class e_countryCode_iso3166alpha2;
class e_countryCode_iso3166alpha3_deprecated;
class e_direction;
class e_maxSpeedString;
class e_paramPoly3_pRange;
class e_road_link_elementType;
class e_roadType;
class e_trafficRule;
class t_maxSpeed;
class t_road;
class t_road_elevationProfile;
class t_road_elevationProfile_elevation;
class t_road_lateralProfile;
class t_road_lateralProfile_shape;
class t_road_lateralProfile_superelevation;
class t_road_link;
class t_road_link_predecessorSuccessor;
class t_road_planView;
class t_road_planView_geometry;
class t_road_planView_geometry_arc;
class t_road_planView_geometry_line;
class t_road_planView_geometry_paramPoly3;
class t_road_planView_geometry_poly3;
class t_road_planView_geometry_spiral;
class t_road_surface;
class t_road_surface_CRG;
class t_road_type;
class t_road_type_speed;

#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "opendrive_16_junction.hxx"

#include "opendrive_16_railroad.hxx"

#include "opendrive_16_signal.hxx"

#include "opendrive_16_object.hxx"

#include "opendrive_16_lane.hxx"

#include "opendrive_16_core.hxx"

class e_countryCode: public ::xml_schema::string
{
  public:

  e_countryCode (const char* v);

  e_countryCode (const ::std::string& v);

  e_countryCode (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  e_countryCode (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  e_countryCode (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  e_countryCode (const e_countryCode& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual e_countryCode*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;
};

class e_countryCode_deprecated: public ::xml_schema::string
{
  public:
  enum value
  {
    OpenDRIVE,
    Austria,
    Brazil,
    China,
    France,
    Germany,
    Italy,
    Switzerland,
    USA
  };

  e_countryCode_deprecated (value v);

  e_countryCode_deprecated (const char* v);

  e_countryCode_deprecated (const ::std::string& v);

  e_countryCode_deprecated (const ::xml_schema::string& v);

  e_countryCode_deprecated (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  e_countryCode_deprecated (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  e_countryCode_deprecated (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  e_countryCode_deprecated (const e_countryCode_deprecated& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  virtual e_countryCode_deprecated*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_countryCode_deprecated&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_countryCode_deprecated_convert ();
  }

  protected:
  value
  _xsd_e_countryCode_deprecated_convert () const;

  public:
  static const char* const _xsd_e_countryCode_deprecated_literals_[9];
  static const value _xsd_e_countryCode_deprecated_indexes_[9];
};

class e_countryCode_iso3166alpha2: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  e_countryCode_iso3166alpha2 ();

  e_countryCode_iso3166alpha2 (const char*);

  e_countryCode_iso3166alpha2 (const ::std::string&);

  e_countryCode_iso3166alpha2 (const ::xml_schema::string&);

  e_countryCode_iso3166alpha2 (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  e_countryCode_iso3166alpha2 (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  e_countryCode_iso3166alpha2 (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  e_countryCode_iso3166alpha2 (const e_countryCode_iso3166alpha2& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  virtual e_countryCode_iso3166alpha2*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~e_countryCode_iso3166alpha2 ();
};

class e_countryCode_iso3166alpha3_deprecated: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  e_countryCode_iso3166alpha3_deprecated ();

  e_countryCode_iso3166alpha3_deprecated (const char*);

  e_countryCode_iso3166alpha3_deprecated (const ::std::string&);

  e_countryCode_iso3166alpha3_deprecated (const ::xml_schema::string&);

  e_countryCode_iso3166alpha3_deprecated (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  e_countryCode_iso3166alpha3_deprecated (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  e_countryCode_iso3166alpha3_deprecated (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  e_countryCode_iso3166alpha3_deprecated (const e_countryCode_iso3166alpha3_deprecated& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  virtual e_countryCode_iso3166alpha3_deprecated*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~e_countryCode_iso3166alpha3_deprecated ();
};

class e_direction: public ::xml_schema::string
{
  public:
  enum value
  {
    same,
    opposite
  };

  e_direction (value v);

  e_direction (const char* v);

  e_direction (const ::std::string& v);

  e_direction (const ::xml_schema::string& v);

  e_direction (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_direction (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_direction (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_direction (const e_direction& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual e_direction*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_direction&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_direction_convert ();
  }

  protected:
  value
  _xsd_e_direction_convert () const;

  public:
  static const char* const _xsd_e_direction_literals_[2];
  static const value _xsd_e_direction_indexes_[2];
};

class e_maxSpeedString: public ::xml_schema::string
{
  public:
  enum value
  {
    no_limit,
    undefined
  };

  e_maxSpeedString (value v);

  e_maxSpeedString (const char* v);

  e_maxSpeedString (const ::std::string& v);

  e_maxSpeedString (const ::xml_schema::string& v);

  e_maxSpeedString (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  e_maxSpeedString (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  e_maxSpeedString (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  e_maxSpeedString (const e_maxSpeedString& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual e_maxSpeedString*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_maxSpeedString&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_maxSpeedString_convert ();
  }

  protected:
  value
  _xsd_e_maxSpeedString_convert () const;

  public:
  static const char* const _xsd_e_maxSpeedString_literals_[2];
  static const value _xsd_e_maxSpeedString_indexes_[2];
};

class e_paramPoly3_pRange: public ::xml_schema::string
{
  public:
  enum value
  {
    arcLength,
    normalized
  };

  e_paramPoly3_pRange (value v);

  e_paramPoly3_pRange (const char* v);

  e_paramPoly3_pRange (const ::std::string& v);

  e_paramPoly3_pRange (const ::xml_schema::string& v);

  e_paramPoly3_pRange (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  e_paramPoly3_pRange (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  e_paramPoly3_pRange (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  e_paramPoly3_pRange (const e_paramPoly3_pRange& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual e_paramPoly3_pRange*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_paramPoly3_pRange&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_paramPoly3_pRange_convert ();
  }

  protected:
  value
  _xsd_e_paramPoly3_pRange_convert () const;

  public:
  static const char* const _xsd_e_paramPoly3_pRange_literals_[2];
  static const value _xsd_e_paramPoly3_pRange_indexes_[2];
};

class e_road_link_elementType: public ::xml_schema::string
{
  public:
  enum value
  {
    road,
    junction
  };

  e_road_link_elementType (value v);

  e_road_link_elementType (const char* v);

  e_road_link_elementType (const ::std::string& v);

  e_road_link_elementType (const ::xml_schema::string& v);

  e_road_link_elementType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  e_road_link_elementType (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  e_road_link_elementType (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  e_road_link_elementType (const e_road_link_elementType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual e_road_link_elementType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_road_link_elementType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_road_link_elementType_convert ();
  }

  protected:
  value
  _xsd_e_road_link_elementType_convert () const;

  public:
  static const char* const _xsd_e_road_link_elementType_literals_[2];
  static const value _xsd_e_road_link_elementType_indexes_[2];
};

class e_roadType: public ::xml_schema::string
{
  public:
  enum value
  {
    unknown,
    rural,
    motorway,
    town,
    lowSpeed,
    pedestrian,
    bicycle,
    townExpressway,
    townCollector,
    townArterial,
    townPrivate,
    townLocal,
    townPlayStreet
  };

  e_roadType (value v);

  e_roadType (const char* v);

  e_roadType (const ::std::string& v);

  e_roadType (const ::xml_schema::string& v);

  e_roadType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_roadType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_roadType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_roadType (const e_roadType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual e_roadType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_roadType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_roadType_convert ();
  }

  protected:
  value
  _xsd_e_roadType_convert () const;

  public:
  static const char* const _xsd_e_roadType_literals_[13];
  static const value _xsd_e_roadType_indexes_[13];
};

class e_trafficRule: public ::xml_schema::string
{
  public:
  enum value
  {
    RHT,
    LHT
  };

  e_trafficRule (value v);

  e_trafficRule (const char* v);

  e_trafficRule (const ::std::string& v);

  e_trafficRule (const ::xml_schema::string& v);

  e_trafficRule (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  e_trafficRule (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  e_trafficRule (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  e_trafficRule (const e_trafficRule& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual e_trafficRule*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_trafficRule&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_trafficRule_convert ();
  }

  protected:
  value
  _xsd_e_trafficRule_convert () const;

  public:
  static const char* const _xsd_e_trafficRule_literals_[2];
  static const value _xsd_e_trafficRule_indexes_[2];
};

class t_maxSpeed: public ::xml_schema::string
{
  public:

  t_maxSpeed (const char* v);

  t_maxSpeed (const ::std::string& v);

  t_maxSpeed (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  t_maxSpeed (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  t_maxSpeed (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  t_maxSpeed (const t_maxSpeed& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual t_maxSpeed*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;
};

class t_road: public ::_OpenDriveElement
{
  public:
  // link
  //
  typedef ::t_road_link link_type;
  typedef ::xsd::cxx::tree::optional< link_type > link_optional;
  typedef ::xsd::cxx::tree::traits< link_type, char > link_traits;

  const link_optional&
  link () const;

  link_optional&
  link ();

  void
  link (const link_type& x);

  void
  link (const link_optional& x);

  void
  link (::std::auto_ptr< link_type > p);

  // type
  //
  typedef ::t_road_type type_type;
  typedef ::xsd::cxx::tree::sequence< type_type > type_sequence;
  typedef type_sequence::iterator type_iterator;
  typedef type_sequence::const_iterator type_const_iterator;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_sequence&
  type () const;

  type_sequence&
  type ();

  void
  type (const type_sequence& s);

  // planView
  //
  typedef ::t_road_planView planView_type;
  typedef ::xsd::cxx::tree::traits< planView_type, char > planView_traits;

  const planView_type&
  planView () const;

  planView_type&
  planView ();

  void
  planView (const planView_type& x);

  void
  planView (::std::auto_ptr< planView_type > p);

  // elevationProfile
  //
  typedef ::t_road_elevationProfile elevationProfile_type;
  typedef ::xsd::cxx::tree::optional< elevationProfile_type > elevationProfile_optional;
  typedef ::xsd::cxx::tree::traits< elevationProfile_type, char > elevationProfile_traits;

  const elevationProfile_optional&
  elevationProfile () const;

  elevationProfile_optional&
  elevationProfile ();

  void
  elevationProfile (const elevationProfile_type& x);

  void
  elevationProfile (const elevationProfile_optional& x);

  void
  elevationProfile (::std::auto_ptr< elevationProfile_type > p);

  // lateralProfile
  //
  typedef ::t_road_lateralProfile lateralProfile_type;
  typedef ::xsd::cxx::tree::optional< lateralProfile_type > lateralProfile_optional;
  typedef ::xsd::cxx::tree::traits< lateralProfile_type, char > lateralProfile_traits;

  const lateralProfile_optional&
  lateralProfile () const;

  lateralProfile_optional&
  lateralProfile ();

  void
  lateralProfile (const lateralProfile_type& x);

  void
  lateralProfile (const lateralProfile_optional& x);

  void
  lateralProfile (::std::auto_ptr< lateralProfile_type > p);

  // lanes
  //
  typedef ::t_road_lanes lanes_type;
  typedef ::xsd::cxx::tree::traits< lanes_type, char > lanes_traits;

  const lanes_type&
  lanes () const;

  lanes_type&
  lanes ();

  void
  lanes (const lanes_type& x);

  void
  lanes (::std::auto_ptr< lanes_type > p);

  // objects
  //
  typedef ::t_road_objects objects_type;
  typedef ::xsd::cxx::tree::optional< objects_type > objects_optional;
  typedef ::xsd::cxx::tree::traits< objects_type, char > objects_traits;

  const objects_optional&
  objects () const;

  objects_optional&
  objects ();

  void
  objects (const objects_type& x);

  void
  objects (const objects_optional& x);

  void
  objects (::std::auto_ptr< objects_type > p);

  // signals
  //
  typedef ::t_road_signals signals_type;
  typedef ::xsd::cxx::tree::optional< signals_type > signals_optional;
  typedef ::xsd::cxx::tree::traits< signals_type, char > signals_traits;

  const signals_optional&
  signals () const;

  signals_optional&
  signals ();

  void
  signals (const signals_type& x);

  void
  signals (const signals_optional& x);

  void
  signals (::std::auto_ptr< signals_type > p);

  // surface
  //
  typedef ::t_road_surface surface_type;
  typedef ::xsd::cxx::tree::optional< surface_type > surface_optional;
  typedef ::xsd::cxx::tree::traits< surface_type, char > surface_traits;

  const surface_optional&
  surface () const;

  surface_optional&
  surface ();

  void
  surface (const surface_type& x);

  void
  surface (const surface_optional& x);

  void
  surface (::std::auto_ptr< surface_type > p);

  // railroad
  //
  typedef ::t_road_railroad railroad_type;
  typedef ::xsd::cxx::tree::optional< railroad_type > railroad_optional;
  typedef ::xsd::cxx::tree::traits< railroad_type, char > railroad_traits;

  const railroad_optional&
  railroad () const;

  railroad_optional&
  railroad ();

  void
  railroad (const railroad_type& x);

  void
  railroad (const railroad_optional& x);

  void
  railroad (::std::auto_ptr< railroad_type > p);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
  typedef dataQuality_sequence::iterator dataQuality_iterator;
  typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_sequence&
  dataQuality () const;

  dataQuality_sequence&
  dataQuality ();

  void
  dataQuality (const dataQuality_sequence& s);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::auto_ptr< name_type > p);

  // length
  //
  typedef ::xml_schema::string length_type;
  typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

  const length_type&
  length () const;

  length_type&
  length ();

  void
  length (const length_type& x);

  void
  length (::std::auto_ptr< length_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::auto_ptr< id_type > p);

  // junction
  //
  typedef ::xml_schema::string junction_type;
  typedef ::xsd::cxx::tree::traits< junction_type, char > junction_traits;

  const junction_type&
  junction () const;

  junction_type&
  junction ();

  void
  junction (const junction_type& x);

  void
  junction (::std::auto_ptr< junction_type > p);

  // rule
  //
  typedef ::e_trafficRule rule_type;
  typedef ::xsd::cxx::tree::optional< rule_type > rule_optional;
  typedef ::xsd::cxx::tree::traits< rule_type, char > rule_traits;

  const rule_optional&
  rule () const;

  rule_optional&
  rule ();

  void
  rule (const rule_type& x);

  void
  rule (const rule_optional& x);

  void
  rule (::std::auto_ptr< rule_type > p);

  // Constructors.
  //
  t_road (const planView_type&,
          const lanes_type&,
          const length_type&,
          const id_type&,
          const junction_type&);

  t_road (::std::auto_ptr< planView_type >,
          ::std::auto_ptr< lanes_type >,
          const length_type&,
          const id_type&,
          const junction_type&);

  t_road (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  t_road (const t_road& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual t_road*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road&
  operator= (const t_road& x);

  virtual 
  ~t_road ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  link_optional link_;
  type_sequence type_;
  ::xsd::cxx::tree::one< planView_type > planView_;
  elevationProfile_optional elevationProfile_;
  lateralProfile_optional lateralProfile_;
  ::xsd::cxx::tree::one< lanes_type > lanes_;
  objects_optional objects_;
  signals_optional signals_;
  surface_optional surface_;
  railroad_optional railroad_;
  include_sequence include_;
  userData_sequence userData_;
  dataQuality_sequence dataQuality_;
  name_optional name_;
  ::xsd::cxx::tree::one< length_type > length_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< junction_type > junction_;
  rule_optional rule_;
};

class t_road_elevationProfile: public ::_OpenDriveElement
{
  public:
  // elevation
  //
  typedef ::t_road_elevationProfile_elevation elevation_type;
  typedef ::xsd::cxx::tree::sequence< elevation_type > elevation_sequence;
  typedef elevation_sequence::iterator elevation_iterator;
  typedef elevation_sequence::const_iterator elevation_const_iterator;
  typedef ::xsd::cxx::tree::traits< elevation_type, char > elevation_traits;

  const elevation_sequence&
  elevation () const;

  elevation_sequence&
  elevation ();

  void
  elevation (const elevation_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
  typedef dataQuality_sequence::iterator dataQuality_iterator;
  typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_sequence&
  dataQuality () const;

  dataQuality_sequence&
  dataQuality ();

  void
  dataQuality (const dataQuality_sequence& s);

  // Constructors.
  //
  t_road_elevationProfile ();

  t_road_elevationProfile (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  t_road_elevationProfile (const t_road_elevationProfile& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual t_road_elevationProfile*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_elevationProfile&
  operator= (const t_road_elevationProfile& x);

  virtual 
  ~t_road_elevationProfile ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  elevation_sequence elevation_;
  include_sequence include_;
  userData_sequence userData_;
  dataQuality_sequence dataQuality_;
};

class t_road_elevationProfile_elevation: public ::_OpenDriveElement
{
  public:
  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::auto_ptr< s_type > p);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_type&
  a () const;

  a_type&
  a ();

  void
  a (const a_type& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_type&
  b () const;

  b_type&
  b ();

  void
  b (const b_type& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_type&
  c () const;

  c_type&
  c ();

  void
  c (const c_type& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_type&
  d () const;

  d_type&
  d ();

  void
  d (const d_type& x);

  // Constructors.
  //
  t_road_elevationProfile_elevation (const s_type&,
                                     const a_type&,
                                     const b_type&,
                                     const c_type&,
                                     const d_type&);

  t_road_elevationProfile_elevation (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  t_road_elevationProfile_elevation (const t_road_elevationProfile_elevation& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  virtual t_road_elevationProfile_elevation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_elevationProfile_elevation&
  operator= (const t_road_elevationProfile_elevation& x);

  virtual 
  ~t_road_elevationProfile_elevation ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< a_type > a_;
  ::xsd::cxx::tree::one< b_type > b_;
  ::xsd::cxx::tree::one< c_type > c_;
  ::xsd::cxx::tree::one< d_type > d_;
};

class t_road_lateralProfile: public ::_OpenDriveElement
{
  public:
  // superelevation
  //
  typedef ::t_road_lateralProfile_superelevation superelevation_type;
  typedef ::xsd::cxx::tree::sequence< superelevation_type > superelevation_sequence;
  typedef superelevation_sequence::iterator superelevation_iterator;
  typedef superelevation_sequence::const_iterator superelevation_const_iterator;
  typedef ::xsd::cxx::tree::traits< superelevation_type, char > superelevation_traits;

  const superelevation_sequence&
  superelevation () const;

  superelevation_sequence&
  superelevation ();

  void
  superelevation (const superelevation_sequence& s);

  // shape
  //
  typedef ::t_road_lateralProfile_shape shape_type;
  typedef ::xsd::cxx::tree::sequence< shape_type > shape_sequence;
  typedef shape_sequence::iterator shape_iterator;
  typedef shape_sequence::const_iterator shape_const_iterator;
  typedef ::xsd::cxx::tree::traits< shape_type, char > shape_traits;

  const shape_sequence&
  shape () const;

  shape_sequence&
  shape ();

  void
  shape (const shape_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
  typedef dataQuality_sequence::iterator dataQuality_iterator;
  typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_sequence&
  dataQuality () const;

  dataQuality_sequence&
  dataQuality ();

  void
  dataQuality (const dataQuality_sequence& s);

  // Constructors.
  //
  t_road_lateralProfile ();

  t_road_lateralProfile (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  t_road_lateralProfile (const t_road_lateralProfile& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual t_road_lateralProfile*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lateralProfile&
  operator= (const t_road_lateralProfile& x);

  virtual 
  ~t_road_lateralProfile ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  superelevation_sequence superelevation_;
  shape_sequence shape_;
  include_sequence include_;
  userData_sequence userData_;
  dataQuality_sequence dataQuality_;
};

class t_road_lateralProfile_shape: public ::_OpenDriveElement
{
  public:
  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::auto_ptr< s_type > p);

  // t
  //
  typedef ::xml_schema::double_ t_type;
  typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

  const t_type&
  t () const;

  t_type&
  t ();

  void
  t (const t_type& x);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_type&
  a () const;

  a_type&
  a ();

  void
  a (const a_type& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_type&
  b () const;

  b_type&
  b ();

  void
  b (const b_type& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_type&
  c () const;

  c_type&
  c ();

  void
  c (const c_type& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_type&
  d () const;

  d_type&
  d ();

  void
  d (const d_type& x);

  // Constructors.
  //
  t_road_lateralProfile_shape (const s_type&,
                               const t_type&,
                               const a_type&,
                               const b_type&,
                               const c_type&,
                               const d_type&);

  t_road_lateralProfile_shape (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  t_road_lateralProfile_shape (const t_road_lateralProfile_shape& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  virtual t_road_lateralProfile_shape*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lateralProfile_shape&
  operator= (const t_road_lateralProfile_shape& x);

  virtual 
  ~t_road_lateralProfile_shape ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< t_type > t_;
  ::xsd::cxx::tree::one< a_type > a_;
  ::xsd::cxx::tree::one< b_type > b_;
  ::xsd::cxx::tree::one< c_type > c_;
  ::xsd::cxx::tree::one< d_type > d_;
};

class t_road_lateralProfile_superelevation: public ::_OpenDriveElement
{
  public:
  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::auto_ptr< s_type > p);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_type&
  a () const;

  a_type&
  a ();

  void
  a (const a_type& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_type&
  b () const;

  b_type&
  b ();

  void
  b (const b_type& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_type&
  c () const;

  c_type&
  c ();

  void
  c (const c_type& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_type&
  d () const;

  d_type&
  d ();

  void
  d (const d_type& x);

  // Constructors.
  //
  t_road_lateralProfile_superelevation (const s_type&,
                                        const a_type&,
                                        const b_type&,
                                        const c_type&,
                                        const d_type&);

  t_road_lateralProfile_superelevation (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  t_road_lateralProfile_superelevation (const t_road_lateralProfile_superelevation& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  virtual t_road_lateralProfile_superelevation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lateralProfile_superelevation&
  operator= (const t_road_lateralProfile_superelevation& x);

  virtual 
  ~t_road_lateralProfile_superelevation ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< a_type > a_;
  ::xsd::cxx::tree::one< b_type > b_;
  ::xsd::cxx::tree::one< c_type > c_;
  ::xsd::cxx::tree::one< d_type > d_;
};

class t_road_link: public ::_OpenDriveElement
{
  public:
  // predecessor
  //
  typedef ::t_road_link_predecessorSuccessor predecessor_type;
  typedef ::xsd::cxx::tree::optional< predecessor_type > predecessor_optional;
  typedef ::xsd::cxx::tree::traits< predecessor_type, char > predecessor_traits;

  const predecessor_optional&
  predecessor () const;

  predecessor_optional&
  predecessor ();

  void
  predecessor (const predecessor_type& x);

  void
  predecessor (const predecessor_optional& x);

  void
  predecessor (::std::auto_ptr< predecessor_type > p);

  // successor
  //
  typedef ::t_road_link_predecessorSuccessor successor_type;
  typedef ::xsd::cxx::tree::optional< successor_type > successor_optional;
  typedef ::xsd::cxx::tree::traits< successor_type, char > successor_traits;

  const successor_optional&
  successor () const;

  successor_optional&
  successor ();

  void
  successor (const successor_type& x);

  void
  successor (const successor_optional& x);

  void
  successor (::std::auto_ptr< successor_type > p);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
  typedef dataQuality_sequence::iterator dataQuality_iterator;
  typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_sequence&
  dataQuality () const;

  dataQuality_sequence&
  dataQuality ();

  void
  dataQuality (const dataQuality_sequence& s);

  // Constructors.
  //
  t_road_link ();

  t_road_link (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  t_road_link (const t_road_link& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual t_road_link*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_link&
  operator= (const t_road_link& x);

  virtual 
  ~t_road_link ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  predecessor_optional predecessor_;
  successor_optional successor_;
  include_sequence include_;
  userData_sequence userData_;
  dataQuality_sequence dataQuality_;
};

class t_road_link_predecessorSuccessor: public ::_OpenDriveElement
{
  public:
  // elementId
  //
  typedef ::xml_schema::string elementId_type;
  typedef ::xsd::cxx::tree::traits< elementId_type, char > elementId_traits;

  const elementId_type&
  elementId () const;

  elementId_type&
  elementId ();

  void
  elementId (const elementId_type& x);

  void
  elementId (::std::auto_ptr< elementId_type > p);

  // elementType
  //
  typedef ::xml_schema::string elementType_type;
  typedef ::xsd::cxx::tree::optional< elementType_type > elementType_optional;
  typedef ::xsd::cxx::tree::traits< elementType_type, char > elementType_traits;

  const elementType_optional&
  elementType () const;

  elementType_optional&
  elementType ();

  void
  elementType (const elementType_type& x);

  void
  elementType (const elementType_optional& x);

  void
  elementType (::std::auto_ptr< elementType_type > p);

  // contactPoint
  //
  typedef ::xml_schema::string contactPoint_type;
  typedef ::xsd::cxx::tree::optional< contactPoint_type > contactPoint_optional;
  typedef ::xsd::cxx::tree::traits< contactPoint_type, char > contactPoint_traits;

  const contactPoint_optional&
  contactPoint () const;

  contactPoint_optional&
  contactPoint ();

  void
  contactPoint (const contactPoint_type& x);

  void
  contactPoint (const contactPoint_optional& x);

  void
  contactPoint (::std::auto_ptr< contactPoint_type > p);

  // elementS
  //
  typedef ::t_grEqZero elementS_type;
  typedef ::xsd::cxx::tree::optional< elementS_type > elementS_optional;
  typedef ::xsd::cxx::tree::traits< elementS_type, char > elementS_traits;

  const elementS_optional&
  elementS () const;

  elementS_optional&
  elementS ();

  void
  elementS (const elementS_type& x);

  void
  elementS (const elementS_optional& x);

  void
  elementS (::std::auto_ptr< elementS_type > p);

  // elementDir
  //
  typedef ::xml_schema::string elementDir_type;
  typedef ::xsd::cxx::tree::optional< elementDir_type > elementDir_optional;
  typedef ::xsd::cxx::tree::traits< elementDir_type, char > elementDir_traits;

  const elementDir_optional&
  elementDir () const;

  elementDir_optional&
  elementDir ();

  void
  elementDir (const elementDir_type& x);

  void
  elementDir (const elementDir_optional& x);

  void
  elementDir (::std::auto_ptr< elementDir_type > p);

  // Constructors.
  //
  t_road_link_predecessorSuccessor (const elementId_type&);

  t_road_link_predecessorSuccessor (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  t_road_link_predecessorSuccessor (const t_road_link_predecessorSuccessor& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  virtual t_road_link_predecessorSuccessor*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_link_predecessorSuccessor&
  operator= (const t_road_link_predecessorSuccessor& x);

  virtual 
  ~t_road_link_predecessorSuccessor ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< elementId_type > elementId_;
  elementType_optional elementType_;
  contactPoint_optional contactPoint_;
  elementS_optional elementS_;
  elementDir_optional elementDir_;
};

class t_road_planView: public ::_OpenDriveElement
{
  public:
  // geometry
  //
  typedef ::t_road_planView_geometry geometry_type;
  typedef ::xsd::cxx::tree::sequence< geometry_type > geometry_sequence;
  typedef geometry_sequence::iterator geometry_iterator;
  typedef geometry_sequence::const_iterator geometry_const_iterator;
  typedef ::xsd::cxx::tree::traits< geometry_type, char > geometry_traits;

  const geometry_sequence&
  geometry () const;

  geometry_sequence&
  geometry ();

  void
  geometry (const geometry_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
  typedef dataQuality_sequence::iterator dataQuality_iterator;
  typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_sequence&
  dataQuality () const;

  dataQuality_sequence&
  dataQuality ();

  void
  dataQuality (const dataQuality_sequence& s);

  // Constructors.
  //
  t_road_planView ();

  t_road_planView (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  t_road_planView (const t_road_planView& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual t_road_planView*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_planView&
  operator= (const t_road_planView& x);

  virtual 
  ~t_road_planView ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  geometry_sequence geometry_;
  include_sequence include_;
  userData_sequence userData_;
  dataQuality_sequence dataQuality_;
};

class t_road_planView_geometry: public ::_OpenDriveElement
{
  public:
  // line
  //
  typedef ::t_road_planView_geometry_line line_type;
  typedef ::xsd::cxx::tree::optional< line_type > line_optional;
  typedef ::xsd::cxx::tree::traits< line_type, char > line_traits;

  const line_optional&
  line () const;

  line_optional&
  line ();

  void
  line (const line_type& x);

  void
  line (const line_optional& x);

  void
  line (::std::auto_ptr< line_type > p);

  // spiral
  //
  typedef ::t_road_planView_geometry_spiral spiral_type;
  typedef ::xsd::cxx::tree::optional< spiral_type > spiral_optional;
  typedef ::xsd::cxx::tree::traits< spiral_type, char > spiral_traits;

  const spiral_optional&
  spiral () const;

  spiral_optional&
  spiral ();

  void
  spiral (const spiral_type& x);

  void
  spiral (const spiral_optional& x);

  void
  spiral (::std::auto_ptr< spiral_type > p);

  // arc
  //
  typedef ::t_road_planView_geometry_arc arc_type;
  typedef ::xsd::cxx::tree::optional< arc_type > arc_optional;
  typedef ::xsd::cxx::tree::traits< arc_type, char > arc_traits;

  const arc_optional&
  arc () const;

  arc_optional&
  arc ();

  void
  arc (const arc_type& x);

  void
  arc (const arc_optional& x);

  void
  arc (::std::auto_ptr< arc_type > p);

  // poly3
  //
  typedef ::t_road_planView_geometry_poly3 poly3_type;
  typedef ::xsd::cxx::tree::optional< poly3_type > poly3_optional;
  typedef ::xsd::cxx::tree::traits< poly3_type, char > poly3_traits;

  const poly3_optional&
  poly3 () const;

  poly3_optional&
  poly3 ();

  void
  poly3 (const poly3_type& x);

  void
  poly3 (const poly3_optional& x);

  void
  poly3 (::std::auto_ptr< poly3_type > p);

  // paramPoly3
  //
  typedef ::t_road_planView_geometry_paramPoly3 paramPoly3_type;
  typedef ::xsd::cxx::tree::optional< paramPoly3_type > paramPoly3_optional;
  typedef ::xsd::cxx::tree::traits< paramPoly3_type, char > paramPoly3_traits;

  const paramPoly3_optional&
  paramPoly3 () const;

  paramPoly3_optional&
  paramPoly3 ();

  void
  paramPoly3 (const paramPoly3_type& x);

  void
  paramPoly3 (const paramPoly3_optional& x);

  void
  paramPoly3 (::std::auto_ptr< paramPoly3_type > p);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
  typedef dataQuality_sequence::iterator dataQuality_iterator;
  typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_sequence&
  dataQuality () const;

  dataQuality_sequence&
  dataQuality ();

  void
  dataQuality (const dataQuality_sequence& s);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::auto_ptr< s_type > p);

  // x
  //
  typedef ::xml_schema::double_ x_type;
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

  const x_type&
  x () const;

  x_type&
  x ();

  void
  x (const x_type& x);

  // y
  //
  typedef ::xml_schema::double_ y_type;
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

  const y_type&
  y () const;

  y_type&
  y ();

  void
  y (const y_type& x);

  // hdg
  //
  typedef ::xml_schema::double_ hdg_type;
  typedef ::xsd::cxx::tree::traits< hdg_type, char, ::xsd::cxx::tree::schema_type::double_ > hdg_traits;

  const hdg_type&
  hdg () const;

  hdg_type&
  hdg ();

  void
  hdg (const hdg_type& x);

  // length
  //
  typedef ::xml_schema::string length_type;
  typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

  const length_type&
  length () const;

  length_type&
  length ();

  void
  length (const length_type& x);

  void
  length (::std::auto_ptr< length_type > p);

  // Constructors.
  //
  t_road_planView_geometry (const s_type&,
                            const x_type&,
                            const y_type&,
                            const hdg_type&,
                            const length_type&);

  t_road_planView_geometry (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  t_road_planView_geometry (const t_road_planView_geometry& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  virtual t_road_planView_geometry*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_planView_geometry&
  operator= (const t_road_planView_geometry& x);

  virtual 
  ~t_road_planView_geometry ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  line_optional line_;
  spiral_optional spiral_;
  arc_optional arc_;
  poly3_optional poly3_;
  paramPoly3_optional paramPoly3_;
  include_sequence include_;
  userData_sequence userData_;
  dataQuality_sequence dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
  ::xsd::cxx::tree::one< hdg_type > hdg_;
  ::xsd::cxx::tree::one< length_type > length_;
};

class t_road_planView_geometry_arc: public ::_OpenDriveElement
{
  public:
  // curvature
  //
  typedef ::xml_schema::double_ curvature_type;
  typedef ::xsd::cxx::tree::traits< curvature_type, char, ::xsd::cxx::tree::schema_type::double_ > curvature_traits;

  const curvature_type&
  curvature () const;

  curvature_type&
  curvature ();

  void
  curvature (const curvature_type& x);

  // Constructors.
  //
  t_road_planView_geometry_arc (const curvature_type&);

  t_road_planView_geometry_arc (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  t_road_planView_geometry_arc (const t_road_planView_geometry_arc& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  virtual t_road_planView_geometry_arc*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_planView_geometry_arc&
  operator= (const t_road_planView_geometry_arc& x);

  virtual 
  ~t_road_planView_geometry_arc ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< curvature_type > curvature_;
};

class t_road_planView_geometry_line: public ::_OpenDriveElement
{
  public:
  // Constructors.
  //
  t_road_planView_geometry_line ();

  t_road_planView_geometry_line (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  t_road_planView_geometry_line (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  t_road_planView_geometry_line (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  t_road_planView_geometry_line (const t_road_planView_geometry_line& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  virtual t_road_planView_geometry_line*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~t_road_planView_geometry_line ();
};

class t_road_planView_geometry_paramPoly3: public ::_OpenDriveElement
{
  public:
  // aU
  //
  typedef ::xml_schema::double_ aU_type;
  typedef ::xsd::cxx::tree::traits< aU_type, char, ::xsd::cxx::tree::schema_type::double_ > aU_traits;

  const aU_type&
  aU () const;

  aU_type&
  aU ();

  void
  aU (const aU_type& x);

  // bU
  //
  typedef ::xml_schema::double_ bU_type;
  typedef ::xsd::cxx::tree::traits< bU_type, char, ::xsd::cxx::tree::schema_type::double_ > bU_traits;

  const bU_type&
  bU () const;

  bU_type&
  bU ();

  void
  bU (const bU_type& x);

  // cU
  //
  typedef ::xml_schema::double_ cU_type;
  typedef ::xsd::cxx::tree::traits< cU_type, char, ::xsd::cxx::tree::schema_type::double_ > cU_traits;

  const cU_type&
  cU () const;

  cU_type&
  cU ();

  void
  cU (const cU_type& x);

  // dU
  //
  typedef ::xml_schema::double_ dU_type;
  typedef ::xsd::cxx::tree::traits< dU_type, char, ::xsd::cxx::tree::schema_type::double_ > dU_traits;

  const dU_type&
  dU () const;

  dU_type&
  dU ();

  void
  dU (const dU_type& x);

  // aV
  //
  typedef ::xml_schema::double_ aV_type;
  typedef ::xsd::cxx::tree::traits< aV_type, char, ::xsd::cxx::tree::schema_type::double_ > aV_traits;

  const aV_type&
  aV () const;

  aV_type&
  aV ();

  void
  aV (const aV_type& x);

  // bV
  //
  typedef ::xml_schema::double_ bV_type;
  typedef ::xsd::cxx::tree::traits< bV_type, char, ::xsd::cxx::tree::schema_type::double_ > bV_traits;

  const bV_type&
  bV () const;

  bV_type&
  bV ();

  void
  bV (const bV_type& x);

  // cV
  //
  typedef ::xml_schema::double_ cV_type;
  typedef ::xsd::cxx::tree::traits< cV_type, char, ::xsd::cxx::tree::schema_type::double_ > cV_traits;

  const cV_type&
  cV () const;

  cV_type&
  cV ();

  void
  cV (const cV_type& x);

  // dV
  //
  typedef ::xml_schema::double_ dV_type;
  typedef ::xsd::cxx::tree::traits< dV_type, char, ::xsd::cxx::tree::schema_type::double_ > dV_traits;

  const dV_type&
  dV () const;

  dV_type&
  dV ();

  void
  dV (const dV_type& x);

  // pRange
  //
  typedef ::e_paramPoly3_pRange pRange_type;
  typedef ::xsd::cxx::tree::traits< pRange_type, char > pRange_traits;

  const pRange_type&
  pRange () const;

  pRange_type&
  pRange ();

  void
  pRange (const pRange_type& x);

  void
  pRange (::std::auto_ptr< pRange_type > p);

  // Constructors.
  //
  t_road_planView_geometry_paramPoly3 (const aU_type&,
                                       const bU_type&,
                                       const cU_type&,
                                       const dU_type&,
                                       const aV_type&,
                                       const bV_type&,
                                       const cV_type&,
                                       const dV_type&,
                                       const pRange_type&);

  t_road_planView_geometry_paramPoly3 (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  t_road_planView_geometry_paramPoly3 (const t_road_planView_geometry_paramPoly3& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  virtual t_road_planView_geometry_paramPoly3*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_planView_geometry_paramPoly3&
  operator= (const t_road_planView_geometry_paramPoly3& x);

  virtual 
  ~t_road_planView_geometry_paramPoly3 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< aU_type > aU_;
  ::xsd::cxx::tree::one< bU_type > bU_;
  ::xsd::cxx::tree::one< cU_type > cU_;
  ::xsd::cxx::tree::one< dU_type > dU_;
  ::xsd::cxx::tree::one< aV_type > aV_;
  ::xsd::cxx::tree::one< bV_type > bV_;
  ::xsd::cxx::tree::one< cV_type > cV_;
  ::xsd::cxx::tree::one< dV_type > dV_;
  ::xsd::cxx::tree::one< pRange_type > pRange_;
};

class t_road_planView_geometry_poly3: public ::_OpenDriveElement
{
  public:
  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_type&
  a () const;

  a_type&
  a ();

  void
  a (const a_type& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_type&
  b () const;

  b_type&
  b ();

  void
  b (const b_type& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_type&
  c () const;

  c_type&
  c ();

  void
  c (const c_type& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_type&
  d () const;

  d_type&
  d ();

  void
  d (const d_type& x);

  // Constructors.
  //
  t_road_planView_geometry_poly3 (const a_type&,
                                  const b_type&,
                                  const c_type&,
                                  const d_type&);

  t_road_planView_geometry_poly3 (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  t_road_planView_geometry_poly3 (const t_road_planView_geometry_poly3& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  virtual t_road_planView_geometry_poly3*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_planView_geometry_poly3&
  operator= (const t_road_planView_geometry_poly3& x);

  virtual 
  ~t_road_planView_geometry_poly3 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< a_type > a_;
  ::xsd::cxx::tree::one< b_type > b_;
  ::xsd::cxx::tree::one< c_type > c_;
  ::xsd::cxx::tree::one< d_type > d_;
};

class t_road_planView_geometry_spiral: public ::_OpenDriveElement
{
  public:
  // curvStart
  //
  typedef ::xml_schema::double_ curvStart_type;
  typedef ::xsd::cxx::tree::traits< curvStart_type, char, ::xsd::cxx::tree::schema_type::double_ > curvStart_traits;

  const curvStart_type&
  curvStart () const;

  curvStart_type&
  curvStart ();

  void
  curvStart (const curvStart_type& x);

  // curvEnd
  //
  typedef ::xml_schema::double_ curvEnd_type;
  typedef ::xsd::cxx::tree::traits< curvEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > curvEnd_traits;

  const curvEnd_type&
  curvEnd () const;

  curvEnd_type&
  curvEnd ();

  void
  curvEnd (const curvEnd_type& x);

  // Constructors.
  //
  t_road_planView_geometry_spiral (const curvStart_type&,
                                   const curvEnd_type&);

  t_road_planView_geometry_spiral (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  t_road_planView_geometry_spiral (const t_road_planView_geometry_spiral& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  virtual t_road_planView_geometry_spiral*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_planView_geometry_spiral&
  operator= (const t_road_planView_geometry_spiral& x);

  virtual 
  ~t_road_planView_geometry_spiral ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< curvStart_type > curvStart_;
  ::xsd::cxx::tree::one< curvEnd_type > curvEnd_;
};

class t_road_surface: public ::_OpenDriveElement
{
  public:
  // CRG
  //
  typedef ::t_road_surface_CRG CRG_type;
  typedef ::xsd::cxx::tree::sequence< CRG_type > CRG_sequence;
  typedef CRG_sequence::iterator CRG_iterator;
  typedef CRG_sequence::const_iterator CRG_const_iterator;
  typedef ::xsd::cxx::tree::traits< CRG_type, char > CRG_traits;

  const CRG_sequence&
  CRG () const;

  CRG_sequence&
  CRG ();

  void
  CRG (const CRG_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
  typedef dataQuality_sequence::iterator dataQuality_iterator;
  typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_sequence&
  dataQuality () const;

  dataQuality_sequence&
  dataQuality ();

  void
  dataQuality (const dataQuality_sequence& s);

  // Constructors.
  //
  t_road_surface ();

  t_road_surface (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  t_road_surface (const t_road_surface& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual t_road_surface*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_surface&
  operator= (const t_road_surface& x);

  virtual 
  ~t_road_surface ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  CRG_sequence CRG_;
  include_sequence include_;
  userData_sequence userData_;
  dataQuality_sequence dataQuality_;
};

class t_road_surface_CRG: public ::_OpenDriveElement
{
  public:
  // file
  //
  typedef ::xml_schema::string file_type;
  typedef ::xsd::cxx::tree::traits< file_type, char > file_traits;

  const file_type&
  file () const;

  file_type&
  file ();

  void
  file (const file_type& x);

  void
  file (::std::auto_ptr< file_type > p);

  // sStart
  //
  typedef ::t_grEqZero sStart_type;
  typedef ::xsd::cxx::tree::traits< sStart_type, char > sStart_traits;

  const sStart_type&
  sStart () const;

  sStart_type&
  sStart ();

  void
  sStart (const sStart_type& x);

  void
  sStart (::std::auto_ptr< sStart_type > p);

  // sEnd
  //
  typedef ::t_grEqZero sEnd_type;
  typedef ::xsd::cxx::tree::traits< sEnd_type, char > sEnd_traits;

  const sEnd_type&
  sEnd () const;

  sEnd_type&
  sEnd ();

  void
  sEnd (const sEnd_type& x);

  void
  sEnd (::std::auto_ptr< sEnd_type > p);

  // orientation
  //
  typedef ::e_direction orientation_type;
  typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

  const orientation_type&
  orientation () const;

  orientation_type&
  orientation ();

  void
  orientation (const orientation_type& x);

  void
  orientation (::std::auto_ptr< orientation_type > p);

  // mode
  //
  typedef ::e_road_surface_CRG_mode mode_type;
  typedef ::xsd::cxx::tree::traits< mode_type, char > mode_traits;

  const mode_type&
  mode () const;

  mode_type&
  mode ();

  void
  mode (const mode_type& x);

  void
  mode (::std::auto_ptr< mode_type > p);

  // purpose
  //
  typedef ::e_road_surface_CRG_purpose purpose_type;
  typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
  typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

  const purpose_optional&
  purpose () const;

  purpose_optional&
  purpose ();

  void
  purpose (const purpose_type& x);

  void
  purpose (const purpose_optional& x);

  void
  purpose (::std::auto_ptr< purpose_type > p);

  // sOffset
  //
  typedef ::xml_schema::double_ sOffset_type;
  typedef ::xsd::cxx::tree::optional< sOffset_type > sOffset_optional;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > sOffset_traits;

  const sOffset_optional&
  sOffset () const;

  sOffset_optional&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (const sOffset_optional& x);

  // tOffset
  //
  typedef ::xml_schema::double_ tOffset_type;
  typedef ::xsd::cxx::tree::optional< tOffset_type > tOffset_optional;
  typedef ::xsd::cxx::tree::traits< tOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > tOffset_traits;

  const tOffset_optional&
  tOffset () const;

  tOffset_optional&
  tOffset ();

  void
  tOffset (const tOffset_type& x);

  void
  tOffset (const tOffset_optional& x);

  // zOffset
  //
  typedef ::xml_schema::double_ zOffset_type;
  typedef ::xsd::cxx::tree::optional< zOffset_type > zOffset_optional;
  typedef ::xsd::cxx::tree::traits< zOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffset_traits;

  const zOffset_optional&
  zOffset () const;

  zOffset_optional&
  zOffset ();

  void
  zOffset (const zOffset_type& x);

  void
  zOffset (const zOffset_optional& x);

  // zScale
  //
  typedef ::xml_schema::double_ zScale_type;
  typedef ::xsd::cxx::tree::optional< zScale_type > zScale_optional;
  typedef ::xsd::cxx::tree::traits< zScale_type, char, ::xsd::cxx::tree::schema_type::double_ > zScale_traits;

  const zScale_optional&
  zScale () const;

  zScale_optional&
  zScale ();

  void
  zScale (const zScale_type& x);

  void
  zScale (const zScale_optional& x);

  // hOffset
  //
  typedef ::xml_schema::double_ hOffset_type;
  typedef ::xsd::cxx::tree::optional< hOffset_type > hOffset_optional;
  typedef ::xsd::cxx::tree::traits< hOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > hOffset_traits;

  const hOffset_optional&
  hOffset () const;

  hOffset_optional&
  hOffset ();

  void
  hOffset (const hOffset_type& x);

  void
  hOffset (const hOffset_optional& x);

  // Constructors.
  //
  t_road_surface_CRG (const file_type&,
                      const sStart_type&,
                      const sEnd_type&,
                      const orientation_type&,
                      const mode_type&);

  t_road_surface_CRG (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  t_road_surface_CRG (const t_road_surface_CRG& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual t_road_surface_CRG*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_surface_CRG&
  operator= (const t_road_surface_CRG& x);

  virtual 
  ~t_road_surface_CRG ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< file_type > file_;
  ::xsd::cxx::tree::one< sStart_type > sStart_;
  ::xsd::cxx::tree::one< sEnd_type > sEnd_;
  ::xsd::cxx::tree::one< orientation_type > orientation_;
  ::xsd::cxx::tree::one< mode_type > mode_;
  purpose_optional purpose_;
  sOffset_optional sOffset_;
  tOffset_optional tOffset_;
  zOffset_optional zOffset_;
  zScale_optional zScale_;
  hOffset_optional hOffset_;
};

class t_road_type: public ::_OpenDriveElement
{
  public:
  // speed
  //
  typedef ::t_road_type_speed speed_type;
  typedef ::xsd::cxx::tree::optional< speed_type > speed_optional;
  typedef ::xsd::cxx::tree::traits< speed_type, char > speed_traits;

  const speed_optional&
  speed () const;

  speed_optional&
  speed ();

  void
  speed (const speed_type& x);

  void
  speed (const speed_optional& x);

  void
  speed (::std::auto_ptr< speed_type > p);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::sequence< dataQuality_type > dataQuality_sequence;
  typedef dataQuality_sequence::iterator dataQuality_iterator;
  typedef dataQuality_sequence::const_iterator dataQuality_const_iterator;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_sequence&
  dataQuality () const;

  dataQuality_sequence&
  dataQuality ();

  void
  dataQuality (const dataQuality_sequence& s);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::auto_ptr< s_type > p);

  // type
  //
  typedef ::e_roadType type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // country
  //
  typedef ::e_countryCode country_type;
  typedef ::xsd::cxx::tree::optional< country_type > country_optional;
  typedef ::xsd::cxx::tree::traits< country_type, char > country_traits;

  const country_optional&
  country () const;

  country_optional&
  country ();

  void
  country (const country_type& x);

  void
  country (const country_optional& x);

  void
  country (::std::auto_ptr< country_type > p);

  // Constructors.
  //
  t_road_type (const s_type&,
               const type_type&);

  t_road_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  t_road_type (const t_road_type& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual t_road_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_type&
  operator= (const t_road_type& x);

  virtual 
  ~t_road_type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  speed_optional speed_;
  include_sequence include_;
  userData_sequence userData_;
  dataQuality_sequence dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< type_type > type_;
  country_optional country_;
};

class t_road_type_speed: public ::_OpenDriveElement
{
  public:
  // max
  //
  typedef ::t_maxSpeed max_type;
  typedef ::xsd::cxx::tree::traits< max_type, char > max_traits;

  const max_type&
  max () const;

  max_type&
  max ();

  void
  max (const max_type& x);

  void
  max (::std::auto_ptr< max_type > p);

  // unit
  //
  typedef ::e_unitSpeed unit_type;
  typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
  typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

  const unit_optional&
  unit () const;

  unit_optional&
  unit ();

  void
  unit (const unit_type& x);

  void
  unit (const unit_optional& x);

  void
  unit (::std::auto_ptr< unit_type > p);

  // Constructors.
  //
  t_road_type_speed (const max_type&);

  t_road_type_speed (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  t_road_type_speed (const t_road_type_speed& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual t_road_type_speed*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_type_speed&
  operator= (const t_road_type_speed& x);

  virtual 
  ~t_road_type_speed ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< max_type > max_;
  unit_optional unit_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // XSD_SCHEMA_OPENDRIVE_16_ROAD_HXX
